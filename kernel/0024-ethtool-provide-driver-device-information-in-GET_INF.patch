From fed4645f9a2353a063bc3948e27a9ccb27d35459 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 16 Feb 2019 10:51:08 +0100
Subject: [PATCH 24/43] ethtool: provide driver/device information in GET_INFO
 request

Implement GET_INFO request to get basic driver and device information as
provided by ETHTOOL_GDRVINFO ioct command. The information is read only so
that the corresponding SET_INFO message is only used in kernel replies.

Move most of ethtool_get_drvinfo() int common.c so that the code can be
shared by both ioctl and netlink interface.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  41 ++++-
 include/uapi/linux/ethtool_netlink.h         |  30 ++++
 net/ethtool/Makefile                         |   2 +-
 net/ethtool/common.c                         |  52 ++++++
 net/ethtool/common.h                         |   2 +
 net/ethtool/info.c                           | 170 +++++++++++++++++++
 net/ethtool/ioctl.c                          |  50 +-----
 net/ethtool/netlink.c                        |   8 +
 net/ethtool/netlink.h                        |   1 +
 9 files changed, 309 insertions(+), 47 deletions(-)
 create mode 100644 net/ethtool/info.c

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index 3c5fbf466057..0f79acafda53 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -126,6 +126,8 @@ List of message types
     ETHNL_CMD_SET_STRSET		response only
     ETHNL_CMD_GET_SETTINGS
     ETHNL_CMD_SET_SETTINGS
+    ETHNL_CMD_GET_INFO
+    ETHNL_CMD_SET_INFO			response only
 
 All constants use ETHNL_CMD_ prefix, usually followed by "GET", "SET" or "ACT"
 to indicate the type.
@@ -326,6 +328,43 @@ operation) and new (after the operation); mask shows bits which have been
 changed and value their new values.
 
 
+GET_INFO
+--------
+
+GET_INFO requests information provided by ioctl commands ETHTOOL_GDRVINFO,
+ETHTOOL_GPERMADDR and ETHTOOL_GET_TS_INFO to provide basic device information.
+Common pattern is that all information is read only so that SET_INFO message
+exists but is only used by kernel for replies to GET_INFO requests. There is
+also no corresponding notification.
+
+Request contents:
+
+    ETHTOOL_A_INFO_DEV			(nested)	device identification
+    ETHTOOL_A_INFO_INFOMASK		    (u32)	    info mask
+    ETHTOOL_A_INFO_COMPACT		    (flag)	    compact bitsets
+
+Info mask bits meaning:
+
+    ETHTOOL_IM_INFO_DRVINFO		driver info (GDRVINFO)
+
+Kernel response contents:
+
+    ETHTOOL_A_INFO_DEV			(nested)	device identification
+    ETHTOOL_A_INFO_DRVINFO		    (nested)	    driver information
+        ETHTOOL_A_DRVINFO_DRIVER		(string)	driver name
+        ETHTOOL_A_DRVINFO_FWVERSION		(string)	firmware version
+        ETHTOOL_A_DRVINFO_BUSINFO		(string)	bus address
+        ETHTOOL_A_DRVINFO_EROM_VER		(string)	exp. ROM version
+
+The meaning of DRVINFO attributes follows the corresponding fields of
+ETHTOOL_GDRVINFO response. Second part with various counts and sizes is
+omitted as these are not really needed (and if they are, they can be easily
+found by different means). Driver version is also omitted as it is rather
+misleading in most cases.
+
+GET_INFO requests allow dumps.
+
+
 Request translation
 -------------------
 
@@ -337,7 +376,7 @@ ioctl command			netlink command
 ---------------------------------------------------------------------
 ETHTOOL_GSET			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SSET			ETHNL_CMD_SET_SETTINGS
-ETHTOOL_GDRVINFO		n/a
+ETHTOOL_GDRVINFO		ETHNL_CMD_GET_INFO
 ETHTOOL_GREGS			n/a
 ETHTOOL_GWOL			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SWOL			ETHNL_CMD_SET_SETTINGS
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 354a1a97eedc..c20c6d4d1b25 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -17,6 +17,8 @@ enum {
 	ETHNL_CMD_SET_STRSET,		/* only for reply */
 	ETHNL_CMD_GET_SETTINGS,
 	ETHNL_CMD_SET_SETTINGS,
+	ETHNL_CMD_GET_INFO,
+	ETHNL_CMD_SET_INFO,		/* only for reply */
 
 	__ETHNL_CMD_CNT,
 	ETHNL_CMD_MAX = (__ETHNL_CMD_CNT - 1)
@@ -202,6 +204,34 @@ enum {
 	ETHTOOL_A_FEATURES_MAX = (__ETHTOOL_A_FEATURES_CNT - 1)
 };
 
+/* GET_INFO / SET_INFO */
+
+enum {
+	ETHTOOL_A_INFO_UNSPEC,
+	ETHTOOL_A_INFO_DEV,			/* nest - ETHTOOL_A_DEV_* */
+	ETHTOOL_A_INFO_INFOMASK,		/* u32 */
+	ETHTOOL_A_INFO_COMPACT,			/* flag */
+	ETHTOOL_A_INFO_DRVINFO,			/* nest - ETHTOOL_A_DRVINFO_* */
+
+	__ETHTOOL_A_INFO_CNT,
+	ETHTOOL_A_INFO_MAX = (__ETHTOOL_A_INFO_CNT - 1)
+};
+
+#define ETHTOOL_IM_INFO_DRVINFO		(1U << 0)
+
+#define ETHTOOL_IM_INFO_ALL (ETHTOOL_IM_INFO_DRVINFO)
+
+enum {
+	ETHTOOL_A_DRVINFO_UNSPEC,
+	ETHTOOL_A_DRVINFO_DRIVER,		/* string */
+	ETHTOOL_A_DRVINFO_FWVERSION,		/* string */
+	ETHTOOL_A_DRVINFO_BUSINFO,		/* string */
+	ETHTOOL_A_DRVINFO_EROM_VER,		/* string */
+
+	__ETHTOOL_A_DRVINFO_CNT,
+	ETHTOOL_A_DRVINFO_MAX = (__ETHTOOL_A_DRVINFO_CNT - 1)
+};
+
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
 #define ETHTOOL_GENL_VERSION 1
diff --git a/net/ethtool/Makefile b/net/ethtool/Makefile
index 1155e5e9ef69..07e824c5eafa 100644
--- a/net/ethtool/Makefile
+++ b/net/ethtool/Makefile
@@ -4,4 +4,4 @@ obj-y				+= ioctl.o common.o
 
 obj-$(CONFIG_ETHTOOL_NETLINK)	+= ethtool_nl.o
 
-ethtool_nl-y	:= netlink.o bitset.o strset.o settings.o
+ethtool_nl-y	:= netlink.o bitset.o strset.o settings.o info.o
diff --git a/net/ethtool/common.c b/net/ethtool/common.c
index f4d16b9a4047..e383e5272b5d 100644
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@ -1,5 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
 
+#include <linux/rtnetlink.h>
+#include <net/devlink.h>
 #include "common.h"
 
 const char netdev_features_strings[NETDEV_FEATURE_COUNT][ETH_GSTRING_LEN] = {
@@ -148,3 +150,53 @@ int __ethtool_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 
 	return 0;
 }
+
+int __ethtool_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+
+	memset(info, 0, sizeof(*info));
+	info->cmd = ETHTOOL_GDRVINFO;
+	if (ops->get_drvinfo) {
+		ops->get_drvinfo(dev, info);
+	} else if (dev->dev.parent && dev->dev.parent->driver) {
+		strlcpy(info->bus_info, dev_name(dev->dev.parent),
+			sizeof(info->bus_info));
+		strlcpy(info->driver, dev->dev.parent->driver->name,
+			sizeof(info->driver));
+	} else {
+		return -EOPNOTSUPP;
+	}
+
+	/* this method of obtaining string set info is deprecated;
+	 * Use ETHTOOL_GSSET_INFO instead.
+	 */
+	if (ops->get_sset_count) {
+		int rc;
+
+		rc = ops->get_sset_count(dev, ETH_SS_TEST);
+		if (rc >= 0)
+			info->testinfo_len = rc;
+		rc = ops->get_sset_count(dev, ETH_SS_STATS);
+		if (rc >= 0)
+			info->n_stats = rc;
+		rc = ops->get_sset_count(dev, ETH_SS_PRIV_FLAGS);
+		if (rc >= 0)
+			info->n_priv_flags = rc;
+	}
+	if (ops->get_regs_len) {
+		int ret = ops->get_regs_len(dev);
+
+		if (ret > 0)
+			info->regdump_len = ret;
+	}
+
+	if (ops->get_eeprom_len)
+		info->eedump_len = ops->get_eeprom_len(dev);
+
+	if (!info->fw_version[0])
+		devlink_compat_running_version(dev, info->fw_version,
+					       sizeof(info->fw_version));
+
+	return 0;
+}
diff --git a/net/ethtool/common.h b/net/ethtool/common.h
index 3e39e558ac19..fa878fff1564 100644
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@ -3,6 +3,7 @@
 #ifndef _ETHTOOL_COMMON_H
 #define _ETHTOOL_COMMON_H
 
+#include <linux/netdevice.h>
 #include <linux/ethtool.h>
 
 #define ETHTOOL_DEV_FEATURE_WORDS	((NETDEV_FEATURE_COUNT + 31) / 32)
@@ -18,6 +19,7 @@ phy_tunable_strings[__ETHTOOL_PHY_TUNABLE_COUNT][ETH_GSTRING_LEN];
 
 int __ethtool_get_link(struct net_device *dev);
 int __ethtool_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol);
+int __ethtool_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info);
 
 bool convert_legacy_settings_to_link_ksettings(
 	struct ethtool_link_ksettings *link_ksettings,
diff --git a/net/ethtool/info.c b/net/ethtool/info.c
new file mode 100644
index 000000000000..7eddf54505d9
--- /dev/null
+++ b/net/ethtool/info.c
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
+
+#include "netlink.h"
+#include "common.h"
+#include "bitset.h"
+
+struct info_data {
+	struct ethnl_req_info		reqinfo_base;
+
+	/* everything below here will be reset for each device in dumps */
+	struct ethnl_reply_data		repdata_base;
+	struct ethtool_drvinfo		drvinfo;
+};
+
+static const struct nla_policy info_get_policy[ETHTOOL_A_INFO_MAX + 1] = {
+	[ETHTOOL_A_INFO_UNSPEC]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_INFO_DEV]		= { .type = NLA_NESTED },
+	[ETHTOOL_A_INFO_INFOMASK]	= { .type = NLA_U32 },
+	[ETHTOOL_A_INFO_COMPACT]	= { .type = NLA_FLAG },
+	[ETHTOOL_A_INFO_DRVINFO]	= { .type = NLA_REJECT },
+};
+
+/* parse_request() handler */
+static int info_parse(struct ethnl_req_info *req_info, struct sk_buff *skb,
+		      struct genl_info *info, const struct nlmsghdr *nlhdr)
+{
+	struct nlattr *tb[ETHTOOL_A_INFO_MAX + 1];
+	int ret;
+
+	ret = nlmsg_parse(nlhdr, GENL_HDRLEN, tb, ETHTOOL_A_INFO_MAX,
+			  info_get_policy, info ? info->extack : NULL);
+	if (ret < 0)
+		return ret;
+
+	if (tb[ETHTOOL_A_INFO_DEV]) {
+		req_info->dev = ethnl_dev_get(info, tb[ETHTOOL_A_INFO_DEV]);
+		if (IS_ERR(req_info->dev)) {
+			ret = PTR_ERR(req_info->dev);
+			req_info->dev = NULL;
+			return ret;
+		}
+	}
+	if (tb[ETHTOOL_A_INFO_INFOMASK])
+		req_info->req_mask = nla_get_u32(tb[ETHTOOL_A_INFO_INFOMASK]);
+	if (tb[ETHTOOL_A_INFO_COMPACT])
+		req_info->compact = true;
+	if (req_info->req_mask == 0)
+		req_info->req_mask = ETHTOOL_IM_INFO_ALL;
+
+	return 0;
+}
+
+/* prepare_data() handler */
+static int info_prepare(struct ethnl_req_info *req_info,
+			struct genl_info *info)
+{
+	struct info_data *data =
+		container_of(req_info, struct info_data, reqinfo_base);
+	struct net_device *dev = data->repdata_base.dev;
+	u32 req_mask = req_info->req_mask & ETHTOOL_IM_INFO_ALL;
+	int ret;
+
+	ret = ethnl_before_ops(dev);
+	if (ret < 0)
+		return ret;
+	if (req_mask & ETHTOOL_IM_INFO_DRVINFO) {
+		ret = __ethtool_get_drvinfo(dev, &data->drvinfo);
+		if (ret < 0)
+			req_mask &= ~ETHTOOL_IM_INFO_DRVINFO;
+	}
+	ethnl_after_ops(dev);
+
+	data->repdata_base.info_mask = req_mask;
+	if (req_info->req_mask & ~req_mask && info)
+		GENL_SET_ERR_MSG(info,
+				 "not all requested data could be retrieved");
+	return 0;
+}
+
+static int info_drvinfo_size(const struct ethtool_drvinfo *drvinfo)
+{
+	int len = 0;
+
+	if (drvinfo->driver[0])
+		len += ethnl_str_size(drvinfo->driver);
+	if (drvinfo->fw_version[0])
+		len += ethnl_str_size(drvinfo->fw_version);
+	if (drvinfo->bus_info[0])
+		len += ethnl_str_size(drvinfo->bus_info);
+	if (drvinfo->erom_version[0])
+		len += ethnl_str_size(drvinfo->erom_version);
+
+	return nla_total_size(len);
+}
+
+/* reply_size() handler */
+static int info_size(const struct ethnl_req_info *req_info)
+{
+	const struct info_data *data =
+		container_of(req_info, struct info_data, reqinfo_base);
+	u32 info_mask = data->repdata_base.info_mask;
+	int len = 0;
+
+	len += ethnl_dev_size();
+	if (info_mask & ETHTOOL_IM_INFO_DRVINFO)
+		len += info_drvinfo_size(&data->drvinfo);
+
+	return len;
+}
+
+static int info_fill_drvinfo(struct sk_buff *skb,
+			     const struct ethtool_drvinfo *drvinfo)
+{
+	struct nlattr *nest;
+	int ret;
+
+	nest = nla_nest_start(skb, ETHTOOL_A_INFO_DRVINFO);
+	if (!nest)
+		return -EMSGSIZE;
+	ret = -EMSGSIZE;
+	if ((drvinfo->driver[0] &&
+	     nla_put_string(skb, ETHTOOL_A_DRVINFO_DRIVER, drvinfo->driver)) ||
+	    (drvinfo->fw_version[0] &&
+	     nla_put_string(skb, ETHTOOL_A_DRVINFO_FWVERSION,
+			    drvinfo->fw_version)) ||
+	    (drvinfo->bus_info[0] &&
+	     nla_put_string(skb, ETHTOOL_A_DRVINFO_BUSINFO,
+			    drvinfo->bus_info)) ||
+	    (drvinfo->erom_version[0] &&
+	     nla_put_string(skb, ETHTOOL_A_DRVINFO_EROM_VER,
+			    drvinfo->erom_version)))
+		goto err;
+
+	nla_nest_end(skb, nest);
+	return 0;
+err:
+	nla_nest_cancel(skb, nest);
+	return ret;
+}
+
+/* fill_reply() handler */
+static int info_fill(struct sk_buff *skb,
+		     const struct ethnl_req_info *req_info)
+{
+	const struct info_data *data =
+		container_of(req_info, struct info_data, reqinfo_base);
+	u32 info_mask = data->repdata_base.info_mask;
+	int ret;
+
+	if (info_mask & ETHTOOL_IM_INFO_DRVINFO) {
+		ret = info_fill_drvinfo(skb, &data->drvinfo);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+const struct get_request_ops info_request_ops = {
+	.request_cmd		= ETHNL_CMD_GET_INFO,
+	.reply_cmd		= ETHNL_CMD_SET_INFO,
+	.dev_attrtype		= ETHTOOL_A_INFO_DEV,
+	.data_size		= sizeof(struct info_data),
+	.repdata_offset		= offsetof(struct info_data, repdata_base),
+
+	.parse_request		= info_parse,
+	.prepare_data		= info_prepare,
+	.reply_size		= info_size,
+	.fill_reply		= info_fill,
+};
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 856c778cf976..41b16af94995 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -643,54 +643,14 @@ static noinline_for_stack int ethtool_get_drvinfo(struct net_device *dev,
 						  void __user *useraddr)
 {
 	struct ethtool_drvinfo info;
-	const struct ethtool_ops *ops = dev->ethtool_ops;
-
-	memset(&info, 0, sizeof(info));
-	info.cmd = ETHTOOL_GDRVINFO;
-	if (ops->get_drvinfo) {
-		ops->get_drvinfo(dev, &info);
-	} else if (dev->dev.parent && dev->dev.parent->driver) {
-		strlcpy(info.bus_info, dev_name(dev->dev.parent),
-			sizeof(info.bus_info));
-		strlcpy(info.driver, dev->dev.parent->driver->name,
-			sizeof(info.driver));
-	} else {
-		return -EOPNOTSUPP;
-	}
-
-	/*
-	 * this method of obtaining string set info is deprecated;
-	 * Use ETHTOOL_GSSET_INFO instead.
-	 */
-	if (ops->get_sset_count) {
-		int rc;
-
-		rc = ops->get_sset_count(dev, ETH_SS_TEST);
-		if (rc >= 0)
-			info.testinfo_len = rc;
-		rc = ops->get_sset_count(dev, ETH_SS_STATS);
-		if (rc >= 0)
-			info.n_stats = rc;
-		rc = ops->get_sset_count(dev, ETH_SS_PRIV_FLAGS);
-		if (rc >= 0)
-			info.n_priv_flags = rc;
-	}
-	if (ops->get_regs_len) {
-		int ret = ops->get_regs_len(dev);
-
-		if (ret > 0)
-			info.regdump_len = ret;
-	}
-
-	if (ops->get_eeprom_len)
-		info.eedump_len = ops->get_eeprom_len(dev);
-
-	if (!info.fw_version[0])
-		devlink_compat_running_version(dev, info.fw_version,
-					       sizeof(info.fw_version));
+	int rc;
 
+	rc = __ethtool_get_drvinfo(dev, &info);
+	if (rc < 0)
+		return rc;
 	if (copy_to_user(useraddr, &info, sizeof(info)))
 		return -EFAULT;
+
 	return 0;
 }
 
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index ccb3c6ffc9c2..e3ddede7ea99 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -259,6 +259,7 @@ static int ethnl_multicast(struct sk_buff *skb, struct net_device *dev)
 const struct get_request_ops *get_requests[__ETHNL_CMD_CNT] = {
 	[ETHNL_CMD_GET_STRSET]		= &strset_request_ops,
 	[ETHNL_CMD_GET_SETTINGS]	= &settings_request_ops,
+	[ETHNL_CMD_GET_INFO]		= &info_request_ops,
 };
 
 /**
@@ -650,6 +651,13 @@ static const struct genl_ops ethtool_genl_ops[] = {
 		.flags	= GENL_UNS_ADMIN_PERM,
 		.doit	= ethnl_set_settings,
 	},
+	{
+		.cmd	= ETHNL_CMD_GET_INFO,
+		.doit	= ethnl_get_doit,
+		.start	= ethnl_get_start,
+		.dumpit	= ethnl_get_dumpit,
+		.done	= ethnl_get_done,
+	},
 };
 
 static const struct genl_multicast_group ethtool_nl_mcgrps[] = {
diff --git a/net/ethtool/netlink.h b/net/ethtool/netlink.h
index a3e86c22ddc9..6742adecd7a0 100644
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@ -244,6 +244,7 @@ struct get_request_ops {
 
 extern const struct get_request_ops strset_request_ops;
 extern const struct get_request_ops settings_request_ops;
+extern const struct get_request_ops info_request_ops;
 
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info);
 
-- 
2.21.0

