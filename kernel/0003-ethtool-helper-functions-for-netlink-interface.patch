From 5b60cd40bfd843dbcba4e2cd2302083ececabb5b Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 10 Nov 2017 15:34:56 +0100
Subject: [PATCH 3/7] ethtool: helper functions for netlink interface

Misc helpers used by ethtool netlink code.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 net/core/ethtool_netlink.c | 141 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 141 insertions(+)

diff --git a/net/core/ethtool_netlink.c b/net/core/ethtool_netlink.c
index 2421af2664a4..2cc7c8078e32 100644
--- a/net/core/ethtool_netlink.c
+++ b/net/core/ethtool_netlink.c
@@ -8,6 +8,147 @@
 
 static struct genl_family ethtool_genl_family;
 
+/* misc helper functions */
+
+static int ethnl_str_size(const char *s)
+{
+	return nla_total_size(strlen(s) + 1);
+}
+
+static int ethnl_str_ifne_size(const char *s)
+{
+	return s[0] ? ethnl_str_size(s) : 0;
+}
+
+static int ethnl_put_str_ifne(struct sk_buff *skb, int attrtype, const char *s)
+{
+	if (!s[0])
+		return 0;
+	return nla_put_string(skb, attrtype, s);
+}
+
+/* ethnl_update_* return true if the value is changed */
+static bool ethnl_update_u32(u32 *dst, struct nlattr *attr)
+{
+	u32 val;
+
+	if (!attr)
+		return false;
+	val = nla_get_u32(attr);
+	if (*dst == val)
+		return false;
+
+	*dst = val;
+	return true;
+}
+
+static bool ethnl_update_u8(u8 *dst, struct nlattr *attr)
+{
+	u8 val;
+
+	if (!attr)
+		return false;
+	val = nla_get_u32(attr);
+	if (*dst == val)
+		return false;
+
+	*dst = val;
+	return true;
+}
+
+static bool ethnl_update_binary(u8 *dst, unsigned int len, struct nlattr *attr)
+{
+	if (nla_len(attr) < len)
+		len = nla_len(attr);
+	if (!memcmp(dst, nla_data(attr), len))
+		return false;
+
+	memcpy(dst, nla_data(attr), len);
+	return true;
+}
+
+static bool ethnl_update_bitfield32(u32 *dst, struct nlattr *attr)
+{
+	struct nla_bitfield32 change;
+	u32 newval;
+
+	if (!attr)
+		return false;
+	change = nla_get_bitfield32(attr);
+	newval = (*dst & ~change.selector) | (change.value & change.selector);
+	if (*dst == newval)
+		return false;
+
+	*dst = newval;
+	return true;
+}
+
+static bool ethnl_update_bitfield8(u8 *dst, struct nlattr *attr)
+{
+	struct nla_bitfield32 change;
+	u8 newval;
+
+	if (!attr)
+		return false;
+	change = nla_get_bitfield32(attr);
+	newval = (*dst & ~(u8)change.selector) |
+		 (u8)(change.value & change.selector);
+	if (*dst == newval)
+		return false;
+
+	*dst = newval;
+	return true;
+}
+
+static struct net_device *ethnl_get_dev(struct net *net,
+					const struct ethtool_nl_msghdr *hdr)
+{
+	if (hdr->ifindex && hdr->ifname[0])
+		return ERR_PTR(-EINVAL);
+	if (hdr->ifindex)
+		return dev_get_by_index(net, hdr->ifindex);
+	if (hdr->ifname[0])
+		return dev_get_by_name(net, hdr->ifname);
+
+	return NULL;
+}
+
+/* create skb for a reply
+ * payload: payload length (without netlink, genetlink and ethnl headers)
+ * dev:     device the reply is about
+ * cmd:     ETHTOOL_CMD_* command for reply
+ * oinfo:   info for the received packet we respond to
+ * ehdrp:   place to store pointer to ethtool specific header (may be null)
+ * returns: skb or null on error
+ */
+static struct sk_buff *ethnl_reply_init(size_t payload, struct net_device *dev,
+					u8 cmd, struct genl_info *oinfo,
+					struct ethtool_nl_msghdr **ehdrp)
+{
+	struct ethtool_nl_msghdr *ehdr;
+	struct sk_buff *rskb;
+
+	rskb = genlmsg_new(sizeof(*ehdr) + payload, GFP_KERNEL);
+	if (!rskb)
+		return NULL;
+
+	ehdr = genlmsg_put_reply(rskb, oinfo, &ethtool_genl_family, 0, cmd);
+	if (!ehdr) {
+		nlmsg_free(rskb);
+		return NULL;
+	}
+	if (ehdrp)
+		*ehdrp = ehdr;
+
+	ehdr->ifindex = dev->ifindex;
+	ehdr->flags = 0;
+	ehdr->info_mask = 0;
+	strncpy(ehdr->ifname, dev->name, sizeof(ehdr->ifname));
+	ehdr->ifname[sizeof(ehdr->ifname) - 1] = '\0';
+
+	return rskb;
+}
+
 /* genetlink paperwork */
 
 static const struct genl_ops ethtool_nl_ops[] = {
-- 
2.15.0

