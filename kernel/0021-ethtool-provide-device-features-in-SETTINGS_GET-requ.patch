From 8cb8269264cc9530088e197135a8ad0d21a1b105 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 27 Jul 2018 15:42:51 +0200
Subject: [PATCH 21/44] ethtool: provide device features in SETTINGS_GET
 request

Add information about network device features (as provided by
ETHTOOL_GFEATURES ioctl command) in SETTINGS_GET reply when
ETHTOOL_IM_SETTINGS_FEATURES flag is set in the request.

This request also provides information provided by ETHTOOL_GRXCSUM,
ETHTOOL_GTXCSUM, ETHTOOL_GSG, ETHTOOL_GTSO, ETHTOOL_GUFO, ETHTOOL_GGSO,
ETHTOOL_GFLAGS and ETHTOOL_GGRO ioctl commands.

Send notification in the same format as reply when device features are
modified using ethtool ioctl intefrace or when some other code calls
netdev_update_features() or netdev_change_features().

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  36 ++++--
 include/uapi/linux/ethtool_netlink.h         |  17 ++-
 net/ethtool/common.h                         |   2 +
 net/ethtool/ioctl.c                          |   2 -
 net/ethtool/netlink.c                        |  28 ++++-
 net/ethtool/settings.c                       | 112 +++++++++++++++++++
 6 files changed, 183 insertions(+), 14 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index 8c5e7ec1f374..f2b0eeaf6461 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -253,6 +253,7 @@ Info mask bits meaning:
     ETHTOOL_IM_SETTINGS_LINKSTATE	link state
     ETHTOOL_IM_SETTINGS_WOL		struct ethtool_wolinfo
     ETHTOOL_IM_SETTINGS_DEBUG		debugging
+    ETHTOOL_IM_SETTINGS_FEATURES	features
 
 Response contents:
 
@@ -276,6 +277,11 @@ Response contents:
         ETHTOOL_A_WOL_SOPASS		    (binary)	    SecureOn password
     ETHTOOL_A_SETTINGS_DEBUG		(nested)	debugging
         ETHTOOL_A_DEBUG_MSG_MASK	    (bitfield32)    debug message mask
+    ETHTOOL_A_SETTINGS_FEATURES		(nested)	device features
+        ETHTOOL_A_FEATURES_HW		    (bitset)	    dev->hw_features
+        ETHTOOL_A_FEATURES_WANTED	    (bitset)	    dev->wanted_features
+        ETHTOOL_A_FEATURES_ACTIVE	    (bitset)	    dev->features
+        ETHTOOL_A_FEATURES_NOCHANGE	    (bitset)	    NETIF_F_NEVER_CHANGE
 
 Most of the attributes and their values have the same meaning as matching
 members of the corresponding ioctl structures. For ETHTOOL_A_LINKMODES_OURS,
@@ -289,13 +295,23 @@ ETHTOOL_A_DEBUG_MSG_MASK corresponds to message level (which is actually
 a bitfield) as reported by ETHTOOL_GMSGLVL. The selector reports all message
 types recognized by kernel and value types enabled for the device.
 
+Bitmaps contained in ETHTOOL_A_SETTINGS_FEATURES have the same meaning as
+bitmaps used in ioctl interference but attribute names are different (they are
+based on corresponding members of struct net_device). Legacy "flags" are not
+provided, if userspace needs them (most likely only ethtool for backward
+compatibility), it can calculate their values from related feature bits
+itself. ETHTOOL_A_FEATURES_HW uses mask consisting of all features recognized
+by kernel (to provide all names when using verbose bitmap format), remaining
+three use mask equal to value (to save space).
+
 SETTINGS_GET request is allowed for unprivileged user but ETHTOOL_A_WOL_SOPASS
 is only provided by kernel in response to privileged (netns CAP_NET_ADMIN)
 requests.
 
 SETTINGS_GET requests allow dumps and messages in the same format as response
 to them are broadcasted as notifications on change of these settings using
-netlink or ioctl ethtool interface.
+netlink or ioctl ethtool interface; feature notifications are also sent
+whenever netdev_update_features() or netdev_change_features() is called.
 
 
 SETTINGS_SET
@@ -367,30 +383,30 @@ ETHTOOL_GRINGPARAM		n/a
 ETHTOOL_SRINGPARAM		n/a
 ETHTOOL_GPAUSEPARAM		n/a
 ETHTOOL_SPAUSEPARAM		n/a
-ETHTOOL_GRXCSUM			n/a
+ETHTOOL_GRXCSUM			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SRXCSUM			n/a
-ETHTOOL_GTXCSUM			n/a
+ETHTOOL_GTXCSUM			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_STXCSUM			n/a
-ETHTOOL_GSG			n/a
+ETHTOOL_GSG			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SSG			n/a
 ETHTOOL_TEST			n/a
 ETHTOOL_GSTRINGS		ETHTOOL_MSG_STRSET_GET
 ETHTOOL_PHYS_ID			n/a
 ETHTOOL_GSTATS			n/a
-ETHTOOL_GTSO			n/a
+ETHTOOL_GTSO			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_STSO			n/a
 ETHTOOL_GPERMADDR		rtnetlink RTM_GETLINK
-ETHTOOL_GUFO			n/a
+ETHTOOL_GUFO			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SUFO			n/a
-ETHTOOL_GGSO			n/a
+ETHTOOL_GGSO			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SGSO			n/a
-ETHTOOL_GFLAGS			n/a
+ETHTOOL_GFLAGS			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SFLAGS			n/a
 ETHTOOL_GPFLAGS			n/a
 ETHTOOL_SPFLAGS			n/a
 ETHTOOL_GRXFH			n/a
 ETHTOOL_SRXFH			n/a
-ETHTOOL_GGRO			n/a
+ETHTOOL_GGRO			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SGRO			n/a
 ETHTOOL_GRXRINGS		n/a
 ETHTOOL_GRXCLSRLCNT		n/a
@@ -405,7 +421,7 @@ ETHTOOL_GRXNTUPLE		n/a
 ETHTOOL_GSSET_INFO		ETHTOOL_MSG_STRSET_GET
 ETHTOOL_GRXFHINDIR		n/a
 ETHTOOL_SRXFHINDIR		n/a
-ETHTOOL_GFEATURES		n/a
+ETHTOOL_GFEATURES		ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SFEATURES		n/a
 ETHTOOL_GCHANNELS		n/a
 ETHTOOL_SCHANNELS		n/a
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 177f3d22eb98..0875c5d88410 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -161,6 +161,7 @@ enum {
 	ETHTOOL_A_SETTINGS_LINK_STATE,		/* nest - _A_LINKSTATE_* */
 	ETHTOOL_A_SETTINGS_WOL,			/* nest - _A_WOL_* */
 	ETHTOOL_A_SETTINGS_DEBUG,		/* nest - _A_DEBUG_* */
+	ETHTOOL_A_SETTINGS_FEATURES,		/* nest - _A_FEATURES_* */
 
 	/* add new constants above here */
 	__ETHTOOL_A_SETTINGS_CNT,
@@ -172,12 +173,14 @@ enum {
 #define ETHTOOL_IM_SETTINGS_LINKSTATE		(1U << 2)
 #define ETHTOOL_IM_SETTINGS_WOL			(1U << 3)
 #define ETHTOOL_IM_SETTINGS_DEBUG		(1U << 4)
+#define ETHTOOL_IM_SETTINGS_FEATURES		(1U << 5)
 
 #define ETHTOOL_IM_SETTINGS_ALL (ETHTOOL_IM_SETTINGS_LINKINFO | \
 				 ETHTOOL_IM_SETTINGS_LINKMODES | \
 				 ETHTOOL_IM_SETTINGS_LINKSTATE | \
 				 ETHTOOL_IM_SETTINGS_WOL | \
-				 ETHTOOL_IM_SETTINGS_DEBUG)
+				 ETHTOOL_IM_SETTINGS_DEBUG | \
+				 ETHTOOL_IM_SETTINGS_FEATURES)
 
 #define ETHTOOL_RF_SETTINGS_ALL 0
 
@@ -235,6 +238,18 @@ enum {
 	ETHTOOL_A_DEBUG_MAX = (__ETHTOOL_A_DEBUG_CNT - 1)
 };
 
+enum {
+	ETHTOOL_A_FEATURES_UNSPEC,
+	ETHTOOL_A_FEATURES_HW,			/* bitset */
+	ETHTOOL_A_FEATURES_WANTED,		/* bitset */
+	ETHTOOL_A_FEATURES_ACTIVE,		/* bitset */
+	ETHTOOL_A_FEATURES_NOCHANGE,		/* bitset */
+
+	/* add new constants above here */
+	__ETHTOOL_A_FEATURES_CNT,
+	ETHTOOL_A_FEATURES_MAX = (__ETHTOOL_A_FEATURES_CNT - 1)
+};
+
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
 #define ETHTOOL_GENL_VERSION 1
diff --git a/net/ethtool/common.h b/net/ethtool/common.h
index c4dcb80df620..5f512dbbded5 100644
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@ -6,6 +6,8 @@
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
 
+#define ETHTOOL_DEV_FEATURE_WORDS	((NETDEV_FEATURE_COUNT + 31) / 32)
+
 extern const char
 netdev_features_strings[NETDEV_FEATURE_COUNT][ETH_GSTRING_LEN];
 extern const char
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 2f345eb7b694..16482a266eec 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -55,8 +55,6 @@ EXPORT_SYMBOL(ethtool_op_get_ts_info);
 
 /* Handlers for each ethtool command */
 
-#define ETHTOOL_DEV_FEATURE_WORDS	((NETDEV_FEATURE_COUNT + 31) / 32)
-
 static int ethtool_get_features(struct net_device *dev, void __user *useraddr)
 {
 	struct ethtool_gfeatures cmd = {
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index 4be0ba809641..f8d73dcd927c 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -682,6 +682,30 @@ void ethtool_notify(struct net_device *dev, struct netlink_ext_ack *extack,
 }
 EXPORT_SYMBOL(ethtool_notify);
 
+static void ethnl_notify_features(struct netdev_notifier_info *info)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(info);
+
+	ethtool_notify(dev, NULL, ETHTOOL_MSG_SETTINGS_NTF,
+		       ETHTOOL_IM_SETTINGS_FEATURES, NULL);
+}
+
+static int ethnl_netdev_event(struct notifier_block *this, unsigned long event,
+			      void *ptr)
+{
+	switch (event) {
+	case NETDEV_FEAT_CHANGE:
+		ethnl_notify_features(ptr);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block ethnl_netdev_notifier = {
+	.notifier_call = ethnl_netdev_event,
+};
+
 /* genetlink setup */
 
 static const struct genl_ops ethtool_genl_ops[] = {
@@ -735,7 +759,9 @@ static int __init ethnl_init(void)
 		return ret;
 	ethnl_ok = true;
 
-	return 0;
+	ret = register_netdevice_notifier(&ethnl_netdev_notifier);
+	WARN(ret < 0, "ethtool: net device notifier registration failed");
+	return ret;
 }
 
 subsys_initcall(ethnl_init);
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index a4a876268e0b..215751f59f1d 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -14,6 +14,12 @@ struct settings_data {
 	struct ethtool_link_settings	*lsettings;
 	int				link;
 	u32				msglevel;
+	struct {
+		u32	hw[ETHTOOL_DEV_FEATURE_WORDS];
+		u32	wanted[ETHTOOL_DEV_FEATURE_WORDS];
+		u32	active[ETHTOOL_DEV_FEATURE_WORDS];
+		u32	nochange[ETHTOOL_DEV_FEATURE_WORDS];
+	} features;
 	bool				lpm_empty;
 };
 
@@ -124,6 +130,7 @@ static const struct nla_policy settings_get_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_STATE]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_WOL]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_DEBUG]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_FEATURES]	= { .type = NLA_REJECT },
 };
 
 static int ethnl_get_link_ksettings(struct genl_info *info,
@@ -149,6 +156,24 @@ static int ethnl_get_wol(struct genl_info *info, struct net_device *dev,
 	return ret;
 }
 
+static void features_to_bitmap32(u32 *dest, netdev_features_t src)
+{
+	unsigned int i;
+
+	for (i = 0; i < ETHTOOL_DEV_FEATURE_WORDS; i++)
+		dest[i] = (u32)(src >> (32 * i));
+}
+
+static int ethnl_get_features(struct net_device *dev,
+			      struct settings_data *data)
+{
+	features_to_bitmap32(data->features.hw, dev->hw_features);
+	features_to_bitmap32(data->features.wanted, dev->wanted_features);
+	features_to_bitmap32(data->features.active, dev->features);
+	features_to_bitmap32(data->features.nochange, NETIF_F_NEVER_CHANGE);
+	return 0;
+}
+
 /* prepare_data() handler */
 static int settings_prepare(struct ethnl_req_info *req_info,
 			    struct genl_info *info)
@@ -198,6 +223,8 @@ static int settings_prepare(struct ethnl_req_info *req_info,
 		else
 			req_mask &= ~ETHTOOL_IM_SETTINGS_DEBUG;
 	}
+	if (req_mask & ETHTOOL_IM_SETTINGS_FEATURES)
+		ethnl_get_features(dev, data);
 	ethnl_after_ops(dev);
 
 	data->repdata_base.info_mask = req_mask;
@@ -266,6 +293,39 @@ static int settings_debug_size(void)
 	return nla_total_size(nla_total_size(sizeof(struct nla_bitfield32)));
 }
 
+static int settings_features_size(const struct settings_data *data)
+{
+	unsigned int flags = ETHNL_BITSET_LEGACY_NAMES;
+	int len = 0, ret;
+
+	if (data->reqinfo_base.global_flags & ETHTOOL_RF_COMPACT)
+		flags |= ETHNL_BITSET_COMPACT;
+
+	ret = ethnl_bitset32_size(NETDEV_FEATURE_COUNT, data->features.hw,
+				  NULL, netdev_features_strings, flags);
+	if (ret < 0)
+		return ret;
+	len += ret;
+	flags |= ETHNL_BITSET_LIST;
+	ret = ethnl_bitset32_size(NETDEV_FEATURE_COUNT, data->features.wanted,
+				  NULL, netdev_features_strings, flags);
+	if (ret < 0)
+		return ret;
+	len += ret;
+	ret = ethnl_bitset32_size(NETDEV_FEATURE_COUNT, data->features.active,
+				  NULL, netdev_features_strings, flags);
+	if (ret < 0)
+		return ret;
+	len += ret;
+	ret = ethnl_bitset32_size(NETDEV_FEATURE_COUNT, data->features.nochange,
+				  NULL, netdev_features_strings, flags);
+	if (ret < 0)
+		return ret;
+	len += ret;
+
+	return len;
+}
+
 /* reply_size() handler
  *
  * To keep things simple, reserve space for some attributes which may not
@@ -295,6 +355,12 @@ static int settings_size(const struct ethnl_req_info *req_info)
 		len += settings_wol_size();
 	if (info_mask & ETHTOOL_IM_SETTINGS_DEBUG)
 		len += settings_debug_size();
+	if (info_mask & ETHTOOL_IM_SETTINGS_FEATURES) {
+		ret = settings_features_size(data);
+		if (ret < 0)
+			return ret;
+		len += ret;
+	}
 
 	return len;
 }
@@ -432,6 +498,46 @@ static int settings_fill_debug(struct sk_buff *skb, u32 msglevel)
 	return -EMSGSIZE;
 }
 
+static int settings_fill_features(struct sk_buff *skb,
+				  const struct settings_data *data)
+{
+	unsigned int flags = ETHNL_BITSET_LEGACY_NAMES;
+	struct nlattr *feat_attr;
+	int ret;
+
+	if (data->reqinfo_base.global_flags & ETHTOOL_RF_COMPACT)
+		flags |= ETHNL_BITSET_COMPACT;
+
+	feat_attr = nla_nest_start(skb, ETHTOOL_A_SETTINGS_FEATURES);
+	if (!feat_attr)
+		return -EMSGSIZE;
+
+	ret = ethnl_put_bitset32(skb, ETHTOOL_A_FEATURES_HW,
+				 NETDEV_FEATURE_COUNT, data->features.hw, NULL,
+				 netdev_features_strings, flags);
+	if (ret < 0)
+		return ret;
+	flags |= ETHNL_BITSET_LIST;
+	ret = ethnl_put_bitset32(skb, ETHTOOL_A_FEATURES_WANTED,
+				 NETDEV_FEATURE_COUNT, data->features.wanted,
+				 NULL, netdev_features_strings, flags);
+	if (ret < 0)
+		return ret;
+	ret = ethnl_put_bitset32(skb, ETHTOOL_A_FEATURES_ACTIVE,
+				 NETDEV_FEATURE_COUNT, data->features.active,
+				 NULL, netdev_features_strings, flags);
+	if (ret < 0)
+		return ret;
+	ret = ethnl_put_bitset32(skb, ETHTOOL_A_FEATURES_NOCHANGE,
+				 NETDEV_FEATURE_COUNT, data->features.nochange,
+				 NULL, netdev_features_strings, flags);
+	if (ret < 0)
+		return ret;
+
+	nla_nest_end(skb, feat_attr);
+	return 0;
+}
+
 /* fill_reply() handler */
 static int settings_fill(struct sk_buff *skb,
 			 const struct ethnl_req_info *req_info)
@@ -469,6 +575,11 @@ static int settings_fill(struct sk_buff *skb,
 		if (ret < 0)
 			return ret;
 	}
+	if (info_mask & ETHTOOL_IM_SETTINGS_FEATURES) {
+		ret = settings_fill_features(skb, data);
+		if (ret < 0)
+			return ret;
+	}
 
 	return 0;
 }
@@ -541,6 +652,7 @@ static const struct nla_policy settings_set_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_STATE]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_NESTED },
+	[ETHTOOL_A_SETTINGS_FEATURES]		= { .type = NLA_REJECT },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
-- 
2.22.0

