From e04975f3f5617ee79e10bd4faa3e1912a54ff24b Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sun, 29 Jul 2018 14:58:36 +0200
Subject: [PATCH 24/34] ethtool: implement SET_SETTINGS request for features

Using ETHNL_SETTINGS_FEATURES attribute, userspace can modify device
features. Actual change is subject to netdev_change_features() sanity
checks so that it can differ from what was requested. Unlike with most
other requests, kernel can reply (if ETHA_FEATURES_WANT_DIFF flag is used)
with a message in the same format but with different semantics: information
about difference between user request and actual result and difference
between old and new state of dev->features.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  32 ++--
 include/uapi/linux/ethtool_netlink.h         |   1 +
 net/ethtool/settings.c                       | 156 +++++++++++++++++++
 3 files changed, 180 insertions(+), 9 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index aecfbcbafb85..70ffc69ea83a 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -363,6 +363,9 @@ to be passed with SET_SETTINGS request:
         ETHA_WOL_MODES			(bitfield32)	wake on LAN modes
         ETHA_WOL_SOPASS			(binary)	SecureOn(tm) password
     ETHA_SETTINGS_MSGLEVEL	(bitfield32)	debug level
+    ETHA_SETTINGS_FEATURES	(nested)	device features
+        ETHA_FEATURES_WANTED		(bitset)	wanted features
+        ETHA_FEATURES_WANT_DIFF		(flag)		actual diff
 
 For both bitfield32 types, value and selector work the usual way, i.e. bits
 set in selector are set to corresponding bits from value and the rest is
@@ -377,6 +380,17 @@ autoselection is done on ethtool side with ioctl interface, netlink interface
 is supposed to allow requesting changes without knowing what exactly kernel
 supports.
 
+When changing device features, only ETHA_FEATURES_WANTED is passed. As usual,
+mask defines which bits are to be set and value their values. If the request
+has ETHA_FEATURES_WANT_DIFF flag set, reply will contain a message in the same
+format as response to GET request, except only two bitsets are provided.
+ETHA_FEATURES_WANTED shows difference between requested features and actual
+result (dev->features after the operation); mask shows bits which differ and
+value their values from the original request (new values are negated). Value
+shows changes between old dev->features (before the operation) and new (after
+the operation); mask shows bits which have been changed and value their new
+values.
+
 
 Request translation
 -------------------
@@ -406,30 +420,30 @@ ETHTOOL_SRINGPARAM		n/a
 ETHTOOL_GPAUSEPARAM		n/a
 ETHTOOL_SPAUSEPARAM		n/a
 ETHTOOL_GRXCSUM			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SRXCSUM			n/a
+ETHTOOL_SRXCSUM			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GTXCSUM			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_STXCSUM			n/a
+ETHTOOL_STXCSUM			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GSG			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SSG			n/a
+ETHTOOL_SSG			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_TEST			n/a
 ETHTOOL_GSTRINGS		ETHNL_CMD_GET_STRSET
 ETHTOOL_PHYS_ID			n/a
 ETHTOOL_GSTATS			n/a
 ETHTOOL_GTSO			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_STSO			n/a
+ETHTOOL_STSO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GPERMADDR		rtnetlink RTM_GETLINK
 ETHTOOL_GUFO			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SUFO			n/a
+ETHTOOL_SUFO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GGSO			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SGSO			n/a
+ETHTOOL_SGSO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GFLAGS			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SFLAGS			n/a
+ETHTOOL_SFLAGS			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GPFLAGS			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SPFLAGS			n/a
 ETHTOOL_GRXFH			n/a
 ETHTOOL_SRXFH			n/a
 ETHTOOL_GGRO			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SGRO			n/a
+ETHTOOL_SGRO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GRXRINGS		n/a
 ETHTOOL_GRXCLSRLCNT		n/a
 ETHTOOL_GRXCLSRULE		n/a
@@ -444,7 +458,7 @@ ETHTOOL_GSSET_INFO		ETHNL_CMD_GET_STRSET
 ETHTOOL_GRXFHINDIR		n/a
 ETHTOOL_SRXFHINDIR		n/a
 ETHTOOL_GFEATURES		ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SFEATURES		n/a
+ETHTOOL_SFEATURES		ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GCHANNELS		n/a
 ETHTOOL_SCHANNELS		n/a
 ETHTOOL_SET_DUMP		n/a
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 06956150886a..087b7b167581 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -222,6 +222,7 @@ enum {
 	ETHA_FEATURES_WANTED,			/* bitset */
 	ETHA_FEATURES_ACTIVE,			/* bitset */
 	ETHA_FEATURES_NOCHANGE,			/* bitset */
+	ETHA_FEATURES_WANT_DIFF,		/* flag */
 
 	__ETHA_FEATURES_CNT,
 	ETHA_FEATURES_MAX = (__ETHA_FEATURES_CNT - 1)
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 8f649b7638a4..76f29ddc642e 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -676,6 +676,15 @@ static const struct nla_policy set_wol_policy[ETHA_LINKINFO_MAX + 1] = {
 					    .len = SOPASS_MAX },
 };
 
+static const struct nla_policy set_features_policy[ETHA_FEATURES_MAX + 1] = {
+	[ETHA_FEATURES_UNSPEC]		= { .type = NLA_REJECT },
+	[ETHA_FEATURES_HW]		= { .type = NLA_NESTED },
+	[ETHA_FEATURES_WANTED]		= { .type = NLA_NESTED },
+	[ETHA_FEATURES_ACTIVE]		= { .type = NLA_NESTED },
+	[ETHA_FEATURES_NOCHANGE]	= { .type = NLA_NESTED },
+	[ETHA_FEATURES_WANT_DIFF]	= { .type = NLA_FLAG },
+};
+
 static const struct nla_policy set_settings_policy[ETHA_SETTINGS_MAX + 1] = {
 	[ETHA_SETTINGS_UNSPEC]		= { .type = NLA_REJECT },
 	[ETHA_SETTINGS_DEV]		= { .type = NLA_NESTED },
@@ -688,6 +697,7 @@ static const struct nla_policy set_settings_policy[ETHA_SETTINGS_MAX + 1] = {
 					    .validation_data = &all_bits },
 	[ETHA_SETTINGS_WOL]		= { .type = NLA_NESTED },
 	[ETHA_SETTINGS_LINK]		= { .type = NLA_REJECT },
+	[ETHA_SETTINGS_FEATURES]	= { .type = NLA_NESTED },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
@@ -856,11 +866,147 @@ static int update_wol(struct genl_info *info, struct nlattr *nest,
 	return ret;
 }
 
+static void bitmap_from_features(unsigned long *bitmap, netdev_features_t val)
+{
+	const unsigned int words = BITS_TO_LONGS(NETDEV_FEATURE_COUNT);
+	unsigned int i;
+
+	bitmap_zero(bitmap, NETDEV_FEATURE_COUNT);
+	for (i = 0; i < words; i++)
+		bitmap[i] = (unsigned long)(val >> (i * BITS_PER_LONG));
+}
+
+static netdev_features_t features_from_bitmap(unsigned long *bitmap)
+{
+	const unsigned int words = BITS_TO_LONGS(NETDEV_FEATURE_COUNT);
+	netdev_features_t ret = 0;
+	unsigned int i;
+
+	for (i = 0; i < words; i++)
+		ret |= (netdev_features_t)(bitmap[i]) << (i * BITS_PER_LONG);
+	return ret;
+}
+
+static int update_features(struct genl_info *info, struct net_device *dev,
+			   const struct nlattr *nest, bool compact,
+			   bool *changed)
+{
+	const unsigned int bitset_flags =
+	       (compact ? ETHNL_BITSET_COMPACT : 0) |
+	       ETHNL_BITSET_LEGACY_NAMES;
+	struct nlattr *tb[ETHA_FEATURES_MAX + 1];
+	DECLARE_BITMAP(old_active, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(req_wanted, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(req_mask, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(new_active, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(wanted_diff_mask, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(active_diff_mask, NETDEV_FEATURE_COUNT);
+	struct nlattr *feat_attr;
+	struct sk_buff *rskb;
+	void *reply_payload;
+	bool mod = false;
+	int reply_len;
+	int ret;
+
+	*changed = false;
+	ret = nla_parse_nested_strict(tb, ETHA_FEATURES_MAX, nest,
+				      set_features_policy, info->extack);
+	if (ret < 0)
+		return ret;
+	if (tb[ETHA_FEATURES_HW] || !tb[ETHA_FEATURES_WANTED] ||
+	    tb[ETHA_FEATURES_ACTIVE] || tb[ETHA_FEATURES_NOCHANGE])
+		return -EINVAL;
+
+	bitmap_from_features(old_active, dev->features);
+	bitmap_copy(req_wanted, old_active, NETDEV_FEATURE_COUNT);
+	bitmap_zero(req_mask, NETDEV_FEATURE_COUNT);
+	mod = ethnl_update_bitset(req_wanted, req_mask, NETDEV_FEATURE_COUNT,
+				  tb[ETHA_FEATURES_WANTED], &ret,
+				  netdev_features_strings, true, info);
+	if (ret < 0)
+		return ret;
+	if (features_from_bitmap(req_mask) & ~NETIF_F_ETHTOOL_BITS) {
+		ETHNL_SET_ERRMSG(info,
+				 "attempt to change non-ethtool features");
+		return -EINVAL;
+	}
+	if (!mod)
+		return 0;
+
+	dev->wanted_features = features_from_bitmap(req_wanted);
+	__netdev_update_features(dev);
+	bitmap_from_features(new_active, dev->features);
+	*changed = !bitmap_equal(old_active, new_active, NETDEV_FEATURE_COUNT);
+	if (!tb[ETHA_FEATURES_WANT_DIFF])
+		return 0;
+
+	bitmap_xor(wanted_diff_mask, req_wanted, new_active,
+		   NETDEV_FEATURE_COUNT);
+	bitmap_xor(active_diff_mask, old_active, new_active,
+		   NETDEV_FEATURE_COUNT);
+	bitmap_and(wanted_diff_mask, wanted_diff_mask, req_mask,
+		   NETDEV_FEATURE_COUNT);
+	bitmap_and(req_wanted, req_wanted, wanted_diff_mask,
+		   NETDEV_FEATURE_COUNT);
+	bitmap_and(new_active, new_active, active_diff_mask,
+		   NETDEV_FEATURE_COUNT);
+
+	rskb = NULL;
+	reply_len = 0;
+	ret = ethnl_bitset_size(NETDEV_FEATURE_COUNT, req_wanted,
+				wanted_diff_mask, netdev_features_strings,
+				bitset_flags);
+	if (ret < 0)
+		goto err;
+	reply_len += ret;
+	ret = ethnl_bitset_size(NETDEV_FEATURE_COUNT, new_active,
+				active_diff_mask, netdev_features_strings,
+				bitset_flags);
+	if (ret < 0)
+		goto err;
+	reply_len += ret;
+	reply_len = dev_ident_size() + nla_total_size(reply_len);
+	ret = -ENOMEM;
+	rskb = ethnl_reply_init(reply_len, dev, ETHNL_CMD_SET_SETTINGS,
+				ETHA_SETTINGS_DEV, info, &reply_payload);
+	if (!rskb)
+		goto err;
+
+	ret = -EMSGSIZE;
+	feat_attr = ethnl_nest_start(rskb, ETHA_SETTINGS_FEATURES);
+	if (!feat_attr)
+		goto err;
+	ret = ethnl_put_bitset(rskb, ETHA_FEATURES_WANTED, NETDEV_FEATURE_COUNT,
+			       req_wanted, wanted_diff_mask,
+			       netdev_features_strings, bitset_flags);
+	if (ret < 0)
+		goto err;
+	ret = ethnl_put_bitset(rskb, ETHA_FEATURES_ACTIVE, NETDEV_FEATURE_COUNT,
+			       new_active, active_diff_mask,
+			       netdev_features_strings, bitset_flags);
+	if (ret < 0)
+		goto err;
+	nla_nest_end(rskb, feat_attr);
+
+	genlmsg_end(rskb, reply_payload);
+	return genlmsg_reply(rskb, info);
+err:
+	WARN_ONCE(ret == -EMSGSIZE,
+		  "calculated message payload length (%d) not sufficient\n",
+		  reply_len);
+	if (rskb)
+		nlmsg_free(rskb);
+	if (ret < 0)
+		ETHNL_SET_ERRMSG(info, "failed to send reply message");
+	return 0;
+}
+
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *tb[ETHA_SETTINGS_MAX + 1];
 	struct net_device *dev;
 	u32 req_mask = 0;
+	bool mod;
 	int ret;
 
 	ret = ethnlmsg_parse(info->nlhdr, tb, ETHA_SETTINGS_MAX,
@@ -907,6 +1053,16 @@ int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 			req_mask |= ETH_SETTINGS_IM_MSGLEVEL;
 		}
 	}
+	if (tb[ETHA_SETTINGS_FEATURES]) {
+		bool compact = tb[ETHA_SETTINGS_COMPACT];
+
+		ret = update_features(info, dev, tb[ETHA_SETTINGS_FEATURES],
+				      compact, &mod);
+		if (mod)
+			req_mask |= ETH_SETTINGS_IM_FEATURES;
+		if (ret < 0)
+			goto out_ops;
+	}
 	ret = 0;
 
 out_ops:
-- 
2.21.0

