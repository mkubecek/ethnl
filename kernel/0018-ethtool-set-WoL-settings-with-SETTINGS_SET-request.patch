From 50fcdbabd0ae5f16d8f79cb451bdd1759c4e6719 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 8 Mar 2019 17:50:30 +0100
Subject: [PATCH 18/45] ethtool: set WoL settings with SETTINGS_SET request

Allow enabling and disabling wake on LAN modes using SETTINGS_SET
request.

ETHTOOL_A_SETTINGS_WOL nested attribute is used to set or modify enabled WoL
modes and SecureOn(tm) password.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt | 12 +++-
 net/ethtool/settings.c                       | 67 +++++++++++++++++++-
 2 files changed, 77 insertions(+), 2 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index e87580bab161..1ffad9c19f53 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -309,6 +309,9 @@ to be passed with SETTINGS_SET request:
         ETHTOOL_A_LINKMODES_OURS	    (bitset)	    advertised link modes
         ETHTOOL_A_LINKMODES_SPEED	    (u32)	    link speed (Mb/s)
         ETHTOOL_A_LINKMODES_DUPLEX	    (u8)	    duplex mode
+    ETHTOOL_A_SETTINGS_WOL		(nested)	wake on LAN settings
+        ETHTOOL_A_WOL_MODES		    (bitfield32)    wake on LAN modes
+        ETHTOOL_A_WOL_SOPASS		    (binary)	    SecureOn password
 
 ETHTOOL_A_LINKMODES_OURS bit set allows setting advertised link modes. If
 autonegotiation is on (either set now or kept from before), advertised modes
@@ -319,6 +322,13 @@ autoselection is done on ethtool side with ioctl interface, netlink interface
 is supposed to allow requesting changes without knowing what exactly kernel
 supports.
 
+ETHTOOL_A_WOL_MODES bitfield is interpreted in the usual way, i.e. bits set in
+the selector are set to 0 or 1 according to value. To allow the semantics of
+the ioctl interface where the whole bitmap is set rather than only modified,
+selectors may have also bits not supported by device set and an error is only
+issued if any of them is also set in the value (i.e. if userspace tries to
+enable mode not supported by device).
+
 
 Request translation
 -------------------
@@ -334,7 +344,7 @@ ETHTOOL_SSET			ETHTOOL_MSG_SETTINGS_SET
 ETHTOOL_GDRVINFO		n/a
 ETHTOOL_GREGS			n/a
 ETHTOOL_GWOL			ETHTOOL_MSG_SETTINGS_GET
-ETHTOOL_SWOL			n/a
+ETHTOOL_SWOL			ETHTOOL_MSG_SETTINGS_SET
 ETHTOOL_GMSGLVL			n/a
 ETHTOOL_SMSGLVL			n/a
 ETHTOOL_NWAY_RST		n/a
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 3857911b1fa7..0c792bff8292 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -109,6 +109,12 @@ static const struct link_mode_info link_mode_params[] = {
 	__DEFINE_LINK_MODE_PARAMS(1000, T1, Full),
 };
 
+/* We want to allow ~0 as selector for backward compatibility (to just set
+ * given set of modes, whatever kernel supports) so that we allow all bits
+ * on validation and do our own sanity check later.
+ */
+static u32 all_bits = ~(u32)0;
+
 static const struct nla_policy
 settings_get_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_UNSPEC]	= { .type = NLA_REJECT },
@@ -478,6 +484,14 @@ linkmodes_set_policy[ETHTOOL_A_LINKMODES_MAX + 1] = {
 	[ETHTOOL_A_LINKMODES_DUPLEX]		= { .type = NLA_U8 },
 };
 
+static const struct nla_policy wol_set_policy[ETHTOOL_A_LINKINFO_MAX + 1] = {
+	[ETHTOOL_A_WOL_UNSPEC]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_WOL_MODES]		= { .type = NLA_BITFIELD32,
+					    .validation_data = &all_bits },
+	[ETHTOOL_A_WOL_SOPASS]		= { .type = NLA_BINARY,
+					    .len = SOPASS_MAX },
+};
+
 static const struct nla_policy
 settings_set_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_UNSPEC]		= { .type = NLA_REJECT },
@@ -485,7 +499,7 @@ settings_set_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_LINK_INFO]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_LINK_MODES]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_LINK_STATE]		= { .type = NLA_REJECT },
-	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_NESTED },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
@@ -636,6 +650,49 @@ static int ethnl_update_ksettings(struct genl_info *info, struct nlattr **tb,
 	return 0;
 }
 
+/**
+ * settings_update_wol() - update wake on lan settings from nested attribute
+ * @info: genetlink info (for error reporting)
+ * @nest: nest attribute
+ * @dev:  network device to get settings for
+ *
+ * Return: negative error on failure, 1 if settings were modified, 0 if not
+ */
+static int settings_update_wol(struct genl_info *info, struct nlattr *nest,
+			       struct net_device *dev)
+{
+	struct nlattr *tb[ETHTOOL_A_WOL_MAX + 1];
+	struct ethtool_wolinfo wolinfo = {};
+	bool mod = false;
+	int ret;
+
+	if (!nest)
+		return 0;
+	ret = nla_parse_nested(tb, ETHTOOL_A_WOL_MAX, nest, wol_set_policy,
+			       info->extack);
+	if (ret < 0)
+		return ret;
+
+	ret = ethnl_get_wol(info, dev, &wolinfo);
+	if (ret < 0)
+		return ret;
+
+	ethnl_update_bitfield32(&wolinfo.wolopts, tb[ETHTOOL_A_WOL_MODES],
+				&mod);
+	ethnl_update_binary(wolinfo.sopass, SOPASS_MAX,
+			    tb[ETHTOOL_A_WOL_SOPASS], &mod);
+	if (!mod)
+		return 0;
+
+	ret = dev->ethtool_ops->set_wol(dev, &wolinfo);
+	if (ret < 0) {
+		GENL_SET_ERR_MSG(info, "wol info update failed");
+		return ret;
+	}
+
+	return 1;
+}
+
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *tb[ETHTOOL_A_SETTINGS_MAX + 1];
@@ -669,6 +726,14 @@ int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 		if (ret < 0)
 			goto out_ops;
 	}
+	if (tb[ETHTOOL_A_SETTINGS_WOL]) {
+		ret = settings_update_wol(info, tb[ETHTOOL_A_SETTINGS_WOL],
+					  dev);
+		if (ret < 0)
+			goto out_ops;
+		if (ret)
+			req_mask |= ETHTOOL_IM_SETTINGS_WOL;
+	}
 	ret = 0;
 
 out_ops:
-- 
2.22.0

