From 1a6e062f7f6a1f537554cb07d5c4d69bee0e0aa2 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 11 Mar 2019 08:36:43 +0100
Subject: [PATCH 34/44] ethtool: set channel counts with SET_PARAMS request

Add support for setting channel counts using SET_PARAMS request with
ETHA_PARAMS_CHANNELS nested attribute. This is a replacement for
ETHTOOL_SCHANNELS ioctl command.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt | 16 +++--
 net/ethtool/common.c                         | 65 ++++++++++++++++++++
 net/ethtool/common.h                         |  3 +
 net/ethtool/ioctl.c                          | 59 +-----------------
 net/ethtool/params.c                         | 59 +++++++++++++++++-
 5 files changed, 138 insertions(+), 64 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index e2b2263c0c17..28c287c434b7 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -488,10 +488,11 @@ SET_PARAMS
 ----------
 
 SET_PARAMS request modifies the settings retrieved by GET_PARAMS, i.e. it
-replaces ETHTOOL_SCOALESCE, ETHTOOL_SRINGPARAM and ETHTOOL_SPAUSEPARAM ioctl
-commands. For each of these, relevant data attributes are contained in
-a corresponding nest attribute. Some of the attributes provided by
-GET_SETPARAMS are read only and cannot be set by SET_PARAMS request.
+replaces ETHTOOL_SCOALESCE, ETHTOOL_SRINGPARAM, ETHTOOL_SPAUSEPARAM and
+ETHTOOL_SCHANNELS ioctl commands. For each of these, relevant data attributes
+are contained in a corresponding nest attribute. Some of the attributes
+provided by GET_SETPARAMS are read only and cannot be set by SET_PARAMS
+request.
 
     ETHA_PARAMS_COALESCE	(nested)	coalescing parameters
         ETHA_COALESCE_RX_USECS			(u32)
@@ -525,6 +526,11 @@ GET_SETPARAMS are read only and cannot be set by SET_PARAMS request.
         ETHA_PAUSE_AUTONEG			(bool)
         ETHA_PAUSE_RX				(bool)
         ETHA_PAUSE_TX				(bool)
+    ETHA_PARAMS_CHANNELS	(nested)	channel counts
+        ETHA_CHANNELS_RX_COUNT			(u32)
+        ETHA_CHANNELS_TX_COUNT			(u32)
+        ETHA_CHANNELS_OTHER_COUNT		(u32)
+        ETHA_CHANNELS_COMBINED_COUNT		(u32)
 
 
 Request translation
@@ -595,7 +601,7 @@ ETHTOOL_SRXFHINDIR		n/a
 ETHTOOL_GFEATURES		ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SFEATURES		ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GCHANNELS		ETHNL_CMD_GET_PARAMS
-ETHTOOL_SCHANNELS		n/a
+ETHTOOL_SCHANNELS		ETHNL_CMD_SET_PARAMS
 ETHTOOL_SET_DUMP		n/a
 ETHTOOL_GET_DUMP_FLAG		n/a
 ETHTOOL_GET_DUMP_DATA		n/a
diff --git a/net/ethtool/common.c b/net/ethtool/common.c
index 4b2f08da910a..a30d5df409b0 100644
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@ -4,6 +4,7 @@
 #include <linux/phy.h>
 #include <linux/net_tstamp.h>
 #include <net/devlink.h>
+#include <net/xdp_sock.h>
 #include "common.h"
 
 const char netdev_features_strings[NETDEV_FEATURE_COUNT][ETH_GSTRING_LEN] = {
@@ -223,3 +224,67 @@ int __ethtool_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 
 	return 0;
 }
+
+static int ethtool_get_max_rxfh_channel(struct net_device *dev, u32 *max)
+{
+	u32 dev_size, current_max = 0;
+	u32 *indir;
+	int ret;
+
+	if (!dev->ethtool_ops->get_rxfh_indir_size ||
+	    !dev->ethtool_ops->get_rxfh)
+		return -EOPNOTSUPP;
+	dev_size = dev->ethtool_ops->get_rxfh_indir_size(dev);
+	if (dev_size == 0)
+		return -EOPNOTSUPP;
+
+	indir = kcalloc(dev_size, sizeof(indir[0]), GFP_USER);
+	if (!indir)
+		return -ENOMEM;
+
+	ret = dev->ethtool_ops->get_rxfh(dev, indir, NULL, NULL);
+	if (ret)
+		goto out;
+
+	while (dev_size--)
+		current_max = max(current_max, indir[dev_size]);
+
+	*max = current_max;
+
+out:
+	kfree(indir);
+	return ret;
+}
+
+int __ethtool_set_channels(struct net_device *dev,
+			   const struct ethtool_channels *curr,
+			   struct ethtool_channels *channels)
+{
+	u16 from_channel, to_channel;
+	u32 max_rx_in_use = 0;
+	unsigned int i;
+
+	/* ensure new counts are within the maximums */
+	if (channels->rx_count > curr->max_rx ||
+	    channels->tx_count > curr->max_tx ||
+	    channels->combined_count > curr->max_combined ||
+	    channels->other_count > curr->max_other)
+		return -EINVAL;
+
+	/* ensure the new Rx count fits within the configured Rx flow
+	 * indirection table settings */
+	if (netif_is_rxfh_configured(dev) &&
+	    !ethtool_get_max_rxfh_channel(dev, &max_rx_in_use) &&
+	    (channels->combined_count + channels->rx_count) <= max_rx_in_use)
+	    return -EINVAL;
+
+	/* Disabling channels, query zero-copy AF_XDP sockets */
+	from_channel = channels->combined_count +
+		min(channels->rx_count, channels->tx_count);
+	to_channel = curr->combined_count + max(curr->rx_count, curr->tx_count);
+	for (i = from_channel; i < to_channel; i++)
+		if (xdp_get_umem_from_qid(dev, i))
+			return -EINVAL;
+
+	return dev->ethtool_ops->set_channels(dev, channels);
+}
diff --git a/net/ethtool/common.h b/net/ethtool/common.h
index 1e00a7eecbbd..5b05f1417b9e 100644
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@ -21,6 +21,9 @@ int __ethtool_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info);
 int __ethtool_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info);
 int __ethtool_get_link(struct net_device *dev);
 int __ethtool_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol);
+int __ethtool_set_channels(struct net_device *dev,
+			   const struct ethtool_channels *curr,
+			   struct ethtool_channels *channels);
 
 bool convert_legacy_settings_to_link_ksettings(
 	struct ethtool_link_ksettings *link_ksettings,
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 4e28c8061bfa..ef9af99a59d3 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -28,7 +28,6 @@
 #include <linux/sched/signal.h>
 #include <linux/net.h>
 #include <net/devlink.h>
-#include <net/xdp_sock.h>
 #include <net/flow_offload.h>
 #include <linux/ethtool_netlink.h>
 
@@ -845,37 +844,6 @@ void netdev_rss_key_fill(void *buffer, size_t len)
 }
 EXPORT_SYMBOL(netdev_rss_key_fill);
 
-static int ethtool_get_max_rxfh_channel(struct net_device *dev, u32 *max)
-{
-	u32 dev_size, current_max = 0;
-	u32 *indir;
-	int ret;
-
-	if (!dev->ethtool_ops->get_rxfh_indir_size ||
-	    !dev->ethtool_ops->get_rxfh)
-		return -EOPNOTSUPP;
-	dev_size = dev->ethtool_ops->get_rxfh_indir_size(dev);
-	if (dev_size == 0)
-		return -EOPNOTSUPP;
-
-	indir = kcalloc(dev_size, sizeof(indir[0]), GFP_USER);
-	if (!indir)
-		return -ENOMEM;
-
-	ret = dev->ethtool_ops->get_rxfh(dev, indir, NULL, NULL);
-	if (ret)
-		goto out;
-
-	while (dev_size--)
-		current_max = max(current_max, indir[dev_size]);
-
-	*max = current_max;
-
-out:
-	kfree(indir);
-	return ret;
-}
-
 static noinline_for_stack int ethtool_get_rxfh_indir(struct net_device *dev,
 						     void __user *useraddr)
 {
@@ -1534,9 +1502,6 @@ static noinline_for_stack int ethtool_set_channels(struct net_device *dev,
 						   void __user *useraddr)
 {
 	struct ethtool_channels channels, curr = { .cmd = ETHTOOL_GCHANNELS };
-	u16 from_channel, to_channel;
-	u32 max_rx_in_use = 0;
-	unsigned int i;
 	int ret;
 
 	if (!dev->ethtool_ops->set_channels || !dev->ethtool_ops->get_channels)
@@ -1547,29 +1512,7 @@ static noinline_for_stack int ethtool_set_channels(struct net_device *dev,
 
 	dev->ethtool_ops->get_channels(dev, &curr);
 
-	/* ensure new counts are within the maximums */
-	if (channels.rx_count > curr.max_rx ||
-	    channels.tx_count > curr.max_tx ||
-	    channels.combined_count > curr.max_combined ||
-	    channels.other_count > curr.max_other)
-		return -EINVAL;
-
-	/* ensure the new Rx count fits within the configured Rx flow
-	 * indirection table settings */
-	if (netif_is_rxfh_configured(dev) &&
-	    !ethtool_get_max_rxfh_channel(dev, &max_rx_in_use) &&
-	    (channels.combined_count + channels.rx_count) <= max_rx_in_use)
-	    return -EINVAL;
-
-	/* Disabling channels, query zero-copy AF_XDP sockets */
-	from_channel = channels.combined_count +
-		min(channels.rx_count, channels.tx_count);
-	to_channel = curr.combined_count + max(curr.rx_count, curr.tx_count);
-	for (i = from_channel; i < to_channel; i++)
-		if (xdp_get_umem_from_qid(dev, i))
-			return -EINVAL;
-
-	ret = dev->ethtool_ops->set_channels(dev, &channels);
+	ret = __ethtool_set_channels(dev, &curr, &channels);
 	if (ret == 0)
 		ethtool_notify(dev, NULL, ETHNL_CMD_SET_PARAMS,
 			       ETH_PARAMS_IM_CHANNELS, NULL);
diff --git a/net/ethtool/params.c b/net/ethtool/params.c
index 49613c881fd7..bf9e2a4427cb 100644
--- a/net/ethtool/params.c
+++ b/net/ethtool/params.c
@@ -1,6 +1,7 @@
 /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 
 #include "netlink.h"
+#include "common.h"
 
 static const struct nla_policy get_params_policy[ETHA_PARAMS_MAX + 1] = {
 	[ETHA_PARAMS_UNSPEC]		= { .type = NLA_REJECT },
@@ -351,7 +352,7 @@ static const struct nla_policy set_params_policy[ETHA_PARAMS_MAX + 1] = {
 	[ETHA_PARAMS_COALESCE]		= { .type = NLA_NESTED },
 	[ETHA_PARAMS_RING]		= { .type = NLA_NESTED },
 	[ETHA_PARAMS_PAUSE]		= { .type = NLA_NESTED },
-	[ETHA_PARAMS_CHANNELS]		= { .type = NLA_REJECT },
+	[ETHA_PARAMS_CHANNELS]		= { .type = NLA_NESTED },
 };
 
 static const struct nla_policy coalesce_policy[ETHA_COALESCE_MAX + 1] = {
@@ -580,6 +581,57 @@ static int update_pause(struct genl_info *info, struct net_device *dev,
 	return (ret < 0) ? ret : 1;
 }
 
+static const struct nla_policy channels_policy[ETHA_CHANNELS_MAX + 1] = {
+	[ETHA_CHANNELS_UNSPEC]		= { .type = NLA_REJECT },
+	[ETHA_CHANNELS_MAX_RX]		= { .type = NLA_REJECT },
+	[ETHA_CHANNELS_MAX_TX]		= { .type = NLA_REJECT },
+	[ETHA_CHANNELS_MAX_OTHER]	= { .type = NLA_REJECT },
+	[ETHA_CHANNELS_MAX_COMBINED]	= { .type = NLA_REJECT },
+	[ETHA_CHANNELS_RX_COUNT]	= { .type = NLA_U32 },
+	[ETHA_CHANNELS_TX_COUNT]	= { .type = NLA_U32 },
+	[ETHA_CHANNELS_OTHER_COUNT]	= { .type = NLA_U32 },
+	[ETHA_CHANNELS_COMBINED_COUNT]	= { .type = NLA_U32 },
+};
+
+static int update_channels(struct genl_info *info, struct net_device *dev,
+			   struct nlattr *nest)
+{
+	struct ethtool_channels old = { .cmd = ETHTOOL_GCHANNELS };
+	struct ethtool_channels new = { .cmd = ETHTOOL_SCHANNELS };
+	struct nlattr *tb[ETHA_CHANNELS_MAX + 1];
+	bool mod = false;
+	int ret;
+
+	if (!nest)
+		return 0;
+	if (!dev->ethtool_ops->get_channels ||
+	    !dev->ethtool_ops->set_channels)
+		return -EOPNOTSUPP;
+	dev->ethtool_ops->get_channels(dev, &old);
+	new = old;
+	new.cmd = ETHTOOL_SCHANNELS;
+
+	ret = nla_parse_nested_strict(tb, ETHA_CHANNELS_MAX, nest,
+				      channels_policy, info->extack);
+	if (ret < 0)
+		return ret;
+
+	if (ethnl_update_u32(&new.rx_count, tb[ETHA_CHANNELS_RX_COUNT]))
+		mod = true;
+	if (ethnl_update_u32(&new.tx_count, tb[ETHA_CHANNELS_TX_COUNT]))
+		mod = true;
+	if (ethnl_update_u32(&new.other_count,tb[ETHA_CHANNELS_OTHER_COUNT]))
+		mod = true;
+	if (ethnl_update_u32(&new.combined_count,
+			     tb[ETHA_CHANNELS_COMBINED_COUNT]))
+		mod = true;
+	if (!mod)
+		return 0;
+
+	ret = __ethtool_set_channels(dev, &old, &new);
+	return (ret < 0) ? ret : 1;
+}
+
 int ethnl_set_params(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *tb[ETHA_PARAMS_MAX + 1];
@@ -614,6 +666,11 @@ int ethnl_set_params(struct sk_buff *skb, struct genl_info *info)
 		goto out_ops;
 	if (ret)
 		req_mask |= ETH_PARAMS_IM_PAUSE;
+	ret = update_channels(info, dev, tb[ETHA_PARAMS_CHANNELS]);
+	if (ret < 0)
+		goto out_ops;
+	if (ret)
+		req_mask |= ETH_PARAMS_IM_CHANNELS;
 
 	ret = 0;
 out_ops:
-- 
2.21.0

