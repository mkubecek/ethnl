From 906dd33240666fa1bf77be479626d38db02080a2 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 16 Feb 2019 16:19:21 +0100
Subject: [PATCH 25/44] ethtool: provide private flags in GET_SETTINGS request

Add information about device private flags (as provided by
ETHTOOL_GPFLAGS ioctl command) in GET_SETTINGS reply when
ETH_SETTINGS_IM_PRIVFLAGS flag is set in the request.

Send notification in the same format as reply when device private flags
are modified using ioctl interface (ETHTOOL_SPFLAGS command).

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  9 +-
 include/uapi/linux/ethtool_netlink.h         |  5 +-
 net/ethtool/ioctl.c                          |  3 +
 net/ethtool/settings.c                       | 99 ++++++++++++++++++++
 4 files changed, 114 insertions(+), 2 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index b2e7eee4046c..abbce979b885 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -277,6 +277,7 @@ Info mask bits meaning:
     ETH_SETTINGS_IM_WOL			struct ethtool_wolinfo
     ETH_SETTINGS_IM_DEBUG		debugging
     ETH_SETTINGS_IM_FEATURES		features
+    ETH_SETTINGS_IM_PRIVFLAGS		device private flags
 
 Response contents:
 
@@ -305,6 +306,7 @@ Response contents:
         ETHTOOL_A_FEATURES_WANTED	    (bitset)	    dev->wanted_features
         ETHTOOL_A_FEATURES_ACTIVE	    (bitset)	    dev->features
         ETHTOOL_A_FEATURES_NOCHANGE	    (bitset)	    NETIF_F_NEVER_CHANGE
+    ETHTOOL_A_SETTINGS_PRIV_FLAGS	(bitset)	device private flags
 
 Most of the attributes and their values have the same meaning as matching
 members of the corresponding ioctl structures. For ETHTOOL_A_LINKMODES_OURS,
@@ -327,6 +329,11 @@ itself. ETHTOOL_A_FEATURES_HW uses mask consisting of all features recognized
 by kernel (to provide all names when using verbose bitmap format), remaining
 three use mask equal to value (to save space).
 
+ETHTOOL_A_SETTINGS_PRIV_FLAGS is a bitset with values of device private flags.
+These flags are defined by driver, their number and names (as well as meaning)
+are device dependent. For compact bitset format, names can be retrieved as
+ETH_SS_PRIV_FLAGS string set.
+
 GET_SETTINGS request is allowed for unprivileged user but ETHTOOL_A_WOL_SOPASS
 is only provided by kernel in response to privileged (netns CAP_NET_ADMIN)
 requests.
@@ -439,7 +446,7 @@ ETHTOOL_GGSO			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SGSO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GFLAGS			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SFLAGS			ETHNL_CMD_SET_SETTINGS
-ETHTOOL_GPFLAGS			n/a
+ETHTOOL_GPFLAGS			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SPFLAGS			n/a
 ETHTOOL_GRXFH			n/a
 ETHTOOL_SRXFH			n/a
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 58193b4878e0..16e338135f91 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -200,6 +200,7 @@ enum {
 	ETHTOOL_A_SETTINGS_WOL,			/* nest - ETHTOOL_A_WOL_* */
 	ETHTOOL_A_SETTINGS_DEBUG,		/* nest - ETHTOOL_A_DEBUG_* */
 	ETHTOOL_A_SETTINGS_FEATURES,		/* nest - ETHTOOL_A_FEATURES_* */
+	ETHTOOL_A_SETTINGS_PRIV_FLAGS,		/* bitset */
 
 	__ETHTOOL_A_SETTINGS_CNT,
 	ETHTOOL_A_SETTINGS_MAX = (__ETHTOOL_A_SETTINGS_CNT - 1)
@@ -211,13 +212,15 @@ enum {
 #define ETH_SETTINGS_IM_WOL			(1U << 3)
 #define ETH_SETTINGS_IM_DEBUG			(1U << 4)
 #define ETH_SETTINGS_IM_FEATURES		(1U << 5)
+#define ETH_SETTINGS_IM_PRIVFLAGS		(1U << 6)
 
 #define ETH_SETTINGS_IM_ALL (ETH_SETTINGS_IM_LINKINFO | \
 			     ETH_SETTINGS_IM_LINKMODES | \
 			     ETH_SETTINGS_IM_LINKSTATE | \
 			     ETH_SETTINGS_IM_WOL | \
 			     ETH_SETTINGS_IM_DEBUG | \
-			     ETH_SETTINGS_IM_FEATURES)
+			     ETH_SETTINGS_IM_FEATURES | \
+			     ETH_SETTINGS_IM_PRIVFLAGS)
 
 enum {
 	ETHTOOL_A_LINKINFO_UNSPEC,
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index c5d3096bcb9b..e391652130d8 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -2546,6 +2546,9 @@ int dev_ethtool(struct net *net, struct ifreq *ifr)
 	case ETHTOOL_SPFLAGS:
 		rc = ethtool_set_value(dev, useraddr,
 				       dev->ethtool_ops->set_priv_flags);
+		if (rc == 0)
+			ethtool_notify(dev, NULL, ETHNL_CMD_SET_SETTINGS,
+				       ETH_SETTINGS_IM_PRIVFLAGS, NULL);
 		break;
 	case ETHTOOL_GRXFH:
 	case ETHTOOL_GRXRINGS:
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 823b879db067..923d319d1171 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -21,6 +21,9 @@ struct settings_data {
 		u32	active[ETHTOOL_DEV_FEATURE_WORDS];
 		u32	nochange[ETHTOOL_DEV_FEATURE_WORDS];
 	} features;
+	char				(*priv_flag_names)[ETH_GSTRING_LEN];
+	u32				priv_flags;
+	unsigned int			n_priv_flags;
 	bool				lpm_empty;
 };
 
@@ -132,6 +135,7 @@ static const struct nla_policy get_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_WOL]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_DEBUG]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_FEATURES]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_PRIV_FLAGS]	= { .type = NLA_REJECT },
 };
 
 static int parse_settings(struct common_req_info *req_info,
@@ -209,6 +213,58 @@ static int ethnl_get_features(struct net_device *dev,
 	return 0;
 }
 
+static int get_priv_flags_info(struct net_device *dev, unsigned int *count,
+			       void **names)
+{
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	int nflags;
+
+	if (!ops->get_priv_flags || !ops->get_sset_count || !ops->get_strings)
+		return -EOPNOTSUPP;
+	nflags = ops->get_sset_count(dev, ETH_SS_PRIV_FLAGS);
+	if (nflags < 0)
+		return nflags;
+
+	if (names) {
+		*names = kcalloc(nflags, ETH_GSTRING_LEN, GFP_KERNEL);
+		if (!*names)
+			return -ENOMEM;
+		ops->get_strings(dev, ETH_SS_PRIV_FLAGS, *names);
+	}
+
+	/* We can easily pass more than 32 private flags to userspace via
+	 * netlink but we cannot get more with ethtool_ops::get_priv_flags().
+	 * Note that we must not adjust nflags before allocating the space
+	 * for flag names as the buffer must be large enough for all flags.
+	 */
+	if (WARN_ONCE(nflags > 32,
+		      "device %s reports more than 32 private flags (%d)\n",
+		      netdev_name(dev), nflags))
+		nflags = 32;
+
+	*count = nflags;
+	return 0;
+}
+
+static int ethnl_get_priv_flags(struct genl_info *info,
+				struct settings_data *data)
+{
+	struct net_device *dev = data->repdata_base.dev;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	unsigned int nflags;
+	void *names;
+	int ret;
+
+	ret = get_priv_flags_info(dev, &nflags, &names);
+	if (ret < 0)
+		return ret;
+
+	data->priv_flags = ops->get_priv_flags(dev);
+	data->priv_flag_names = names;
+	data->n_priv_flags = nflags;
+	return 0;
+}
+
 static int prepare_settings(struct common_req_info *req_info,
 			    struct genl_info *info)
 {
@@ -258,6 +314,11 @@ static int prepare_settings(struct common_req_info *req_info,
 	}
 	if (req_mask & ETH_SETTINGS_IM_FEATURES)
 		ethnl_get_features(dev, data);
+	if (req_mask & ETH_SETTINGS_IM_PRIVFLAGS) {
+		ret = ethnl_get_priv_flags(info, data);
+		if (ret < 0)
+			req_mask &= ~ETH_SETTINGS_IM_PRIVFLAGS;
+	}
 	ethnl_after_ops(dev);
 
 	data->repdata_base.info_mask = req_mask;
@@ -389,6 +450,17 @@ static int settings_size(const struct common_req_info *req_info)
 			return ret;
 		len += ret;
 	}
+	if (info_mask & ETH_SETTINGS_IM_PRIVFLAGS) {
+		const unsigned int flags =
+			(compact ? ETHNL_BITSET_COMPACT : 0) |
+			ETHNL_BITSET_LEGACY_NAMES;
+
+		ret = ethnl_bitset32_size(data->n_priv_flags, &data->priv_flags,
+					  NULL, data->priv_flag_names, flags);
+		if (ret < 0)
+			return ret;
+		len += ret;
+	}
 
 	return len;
 }
@@ -562,6 +634,18 @@ static int fill_features(struct sk_buff *skb, const struct settings_data *data)
 	return 0;
 }
 
+static int fill_priv_flags(struct sk_buff *skb,
+			   const struct settings_data *data)
+{
+	const unsigned int bitset_flags =
+		(data->reqinfo_base.compact ? ETHNL_BITSET_COMPACT : 0) |
+		ETHNL_BITSET_LEGACY_NAMES;
+
+	return ethnl_put_bitset32(skb, ETHTOOL_A_SETTINGS_PRIV_FLAGS,
+				  data->n_priv_flags, &data->priv_flags, NULL,
+				  data->priv_flag_names, bitset_flags);
+}
+
 static int fill_settings(struct sk_buff *skb,
 			 const struct common_req_info *req_info)
 {
@@ -602,10 +686,23 @@ static int fill_settings(struct sk_buff *skb,
 		if (ret < 0)
 			return ret;
 	}
+	if (info_mask & ETH_SETTINGS_IM_PRIVFLAGS) {
+		ret = fill_priv_flags(skb, data);
+		if (ret < 0)
+			return ret;
+	}
 
 	return 0;
 }
 
+static void settings_cleanup(struct common_req_info *req_info)
+{
+	const struct settings_data *data =
+		container_of(req_info, struct settings_data, reqinfo_base);
+
+	kfree(data->priv_flag_names);
+}
+
 const struct get_request_ops settings_request_ops = {
 	.request_cmd		= ETHNL_CMD_GET_SETTINGS,
 	.reply_cmd		= ETHNL_CMD_SET_SETTINGS,
@@ -617,6 +714,7 @@ const struct get_request_ops settings_request_ops = {
 	.prepare_data		= prepare_settings,
 	.reply_size		= settings_size,
 	.fill_reply		= fill_settings,
+	.cleanup		= settings_cleanup,
 };
 
 /* SET_SETTINGS */
@@ -674,6 +772,7 @@ static const struct nla_policy set_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_FEATURES]		= { .type = NLA_NESTED },
+	[ETHTOOL_A_SETTINGS_PRIV_FLAGS]		= { .type = NLA_REJECT },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
-- 
2.21.0

