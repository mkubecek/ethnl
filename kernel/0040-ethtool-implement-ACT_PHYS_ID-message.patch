From e522c0b212bdcf3aab3ef3b9fab496c71ab53620 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sun, 2 Sep 2018 15:50:03 +0200
Subject: [PATCH 40/44] ethtool: implement ACT_PHYS_ID message

Request physical NIC identification (by blinking a LED), equivalent of
ETHTOOL_PHYS_ID.

Send one notification when blinking starts and one when it ends.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt | 24 ++++++-
 include/uapi/linux/ethtool_netlink.h         | 12 ++++
 net/ethtool/actions.c                        | 75 ++++++++++++++++++++
 net/ethtool/common.c                         | 65 +++++++++++++++++
 net/ethtool/common.h                         |  1 +
 net/ethtool/ioctl.c                          | 47 +-----------
 net/ethtool/netlink.c                        |  6 ++
 net/ethtool/netlink.h                        |  3 +
 8 files changed, 186 insertions(+), 47 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index a2ed44e993c5..b46534038476 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -570,6 +570,28 @@ Request contents:
 If successful, a notification in the same format is sent.
 
 
+ACT_PHYS_ID
+-----------
+
+Physical identification of a NIC (usually by blinking a LED. Equivalent of
+ETHTOOL_PHYS_ID.
+
+Request contents:
+
+    ETHA_PHYSID_DEV		(nested)	device identification
+    ETHA_PHYSID_LENGTH		(u32)		length in seconds
+
+If length is omitted, maximum length is used. Processing is synchronous, there
+is no reply until requested time expires (returns zero) or processing is
+interrupted by a signal (returns EINTR). Two notifications are sent: one when
+identification starts (with length actually used) and one when it stops (with
+length of zero).
+
+Processing of this message is exclusive. While identification is running, all
+other ACT_PHYS_ID requests for any device fail with EBUSY. The same holds for
+requests using ETHTOOL_PHYS_ID ioctl command.
+
+
 Request translation
 -------------------
 
@@ -605,7 +627,7 @@ ETHTOOL_GSG			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SSG			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_TEST			n/a
 ETHTOOL_GSTRINGS		ETHNL_CMD_GET_STRSET
-ETHTOOL_PHYS_ID			n/a
+ETHTOOL_PHYS_ID			ETHNL_CMD_ACT_PHYS_ID
 ETHTOOL_GSTATS			n/a
 ETHTOOL_GTSO			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_STSO			ETHNL_CMD_SET_SETTINGS
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 7df29675101e..17134284864b 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -23,6 +23,7 @@ enum {
 	ETHNL_CMD_GET_PARAMS,
 	ETHNL_CMD_SET_PARAMS,
 	ETHNL_CMD_ACT_NWAY_RST,
+	ETHNL_CMD_ACT_PHYS_ID,
 
 	__ETHNL_CMD_CNT,
 	ETHNL_CMD_MAX = (__ETHNL_CMD_CNT - 1)
@@ -418,6 +419,17 @@ enum {
 	ETHA_NWAYRST_MAX = (__ETHA_NWAYRST_CNT - 1)
 };
 
+/* ACT_PHYS_ID */
+
+enum {
+	ETHA_PHYSID_UNSPEC,
+	ETHA_PHYSID_DEV,			/* nest - ETHA_DEV_* */
+	ETHA_PHYSID_LENGTH,			/* u32 */
+
+	__ETHA_PHYSID_CNT,
+	ETHA_PHYSID_MAX = (__ETHA_PHYSID_CNT - 1)
+};
+
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
 #define ETHTOOL_GENL_VERSION 1
diff --git a/net/ethtool/actions.c b/net/ethtool/actions.c
index 7cfe0025403a..a131a92b7957 100644
--- a/net/ethtool/actions.c
+++ b/net/ethtool/actions.c
@@ -73,3 +73,78 @@ int ethnl_act_nway_rst(struct sk_buff *skb, struct genl_info *info)
 	dev_put(dev);
 	return ret;
 }
+
+/* ACT_PHYS_ID */
+
+static const struct nla_policy physid_policy[ETHA_PHYSID_MAX + 1] = {
+	[ETHA_PHYSID_UNSPEC]		= { .type = NLA_REJECT },
+	[ETHA_PHYSID_DEV]		= { .type = NLA_NESTED },
+	[ETHA_PHYSID_LENGTH]		= { .type = NLA_U32 },
+};
+
+void ethnl_physid_notify(struct net_device *dev,
+                          struct netlink_ext_ack *extack, unsigned int cmd,
+                          u32 req_mask, const void *data)
+{
+	u32 timeout = *(const u32 *)data;
+	struct sk_buff *skb;
+	void *msg_payload;
+	int msg_len;
+	int ret;
+
+	msg_len = dev_ident_size() + nla_total_size(sizeof(u32));
+	skb = genlmsg_new(msg_len, GFP_KERNEL);
+	if (!skb)
+		return;
+	msg_payload = genlmsg_put(skb, 0, ++ethnl_bcast_seq,
+				  &ethtool_genl_family, 0,
+				  ETHNL_CMD_ACT_PHYS_ID);
+	if (!msg_payload)
+		goto err_skb;
+
+	ret = ethnl_fill_dev(skb, dev, ETHA_PHYSID_DEV);
+	if (ret < 0)
+		goto err_skb;
+	if (nla_put_u32(skb, ETHA_PHYSID_LENGTH, timeout))
+		goto err_skb;
+
+	genlmsg_end(skb, msg_payload);
+	genlmsg_multicast(&ethtool_genl_family, skb, 0, ETHNL_MCGRP_MONITOR,
+			  GFP_KERNEL);
+	return;
+
+err_skb:
+	nlmsg_free(skb);
+}
+
+int ethnl_act_phys_id(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *tb[ETHA_PHYSID_MAX + 1];
+	unsigned long timeout = 0;
+	struct net_device *dev;
+	int ret;
+
+	ret = ethnlmsg_parse(info->nlhdr, tb, ETHA_PHYSID_MAX, physid_policy,
+			     info);
+	if (ret < 0)
+		return ret;
+	dev = ethnl_dev_get(info, tb[ETHA_PHYSID_DEV]);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+	if (tb[ETHA_PHYSID_LENGTH])
+		timeout = nla_get_u32(tb[ETHA_PHYSID_LENGTH]);
+
+	rtnl_lock();
+	ret = ethnl_before_ops(dev);
+	if (ret < 0)
+		goto out;
+	ret = __ethtool_phys_id(dev, timeout);
+	if (ret == 0 && signal_pending(current))
+		ret = -EINTR;
+	ethnl_after_ops(dev);
+
+out:
+	rtnl_unlock();
+	dev_put(dev);
+	return ret;
+}
diff --git a/net/ethtool/common.c b/net/ethtool/common.c
index 191198e7e671..d74fe8f2302d 100644
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@ -1,5 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
 
+#include <linux/ethtool_netlink.h>
 #include <linux/rtnetlink.h>
 #include <linux/phy.h>
 #include <linux/net_tstamp.h>
@@ -289,3 +290,67 @@ int __ethtool_set_channels(struct net_device *dev,
 
 	return dev->ethtool_ops->set_channels(dev, channels);
 }
+
+/* physical identification (by blinking a LED)
+ * caller must hold RTNL and a reference to dev
+ */
+int __ethtool_phys_id(struct net_device *dev, unsigned long timeout)
+{
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	u32 notify_timeout;
+	static bool busy;
+	int rc;
+
+	ASSERT_RTNL();
+	if (!ops->set_phys_id)
+		return -EOPNOTSUPP;
+	if (busy)
+		return -EBUSY;
+
+	rc = ops->set_phys_id(dev, ETHTOOL_ID_ACTIVE);
+	if (rc < 0)
+		return rc;
+
+	/* Drop the RTNL lock while waiting, but prevent reentry; device
+	 * removal is prevented by caller holding a reference
+	 */
+	busy = true;
+	notify_timeout = min_t(unsigned long, timeout, U32_MAX) ?: U32_MAX;
+	ethtool_notify(dev, NULL, ETHNL_CMD_ACT_PHYS_ID, 0, &notify_timeout);
+	rtnl_unlock();
+
+	if (rc == 0) {
+		/* Driver will handle this itself */
+		if (timeout > MAX_SCHEDULE_TIMEOUT / HZ)
+			timeout = MAX_SCHEDULE_TIMEOUT / HZ;
+		schedule_timeout_interruptible(
+			timeout ? (timeout * HZ) : MAX_SCHEDULE_TIMEOUT);
+	} else {
+		/* Driver expects to be called at twice the frequency in rc */
+		int n = rc * 2, i, interval = HZ / n;
+
+		/* Count down seconds */
+		do {
+			/* Count down iterations per second */
+			i = n;
+			do {
+				rtnl_lock();
+				rc = ops->set_phys_id(dev,
+				    (i & 1) ? ETHTOOL_ID_OFF : ETHTOOL_ID_ON);
+				rtnl_unlock();
+				if (rc)
+					break;
+				schedule_timeout_interruptible(interval);
+			} while (!signal_pending(current) && --i != 0);
+		} while (!signal_pending(current) &&
+			 (timeout == 0 || --timeout > 0));
+	}
+
+	rtnl_lock();
+	notify_timeout = 0;
+	ethtool_notify(dev, NULL, ETHNL_CMD_ACT_PHYS_ID, 0, &notify_timeout);
+	busy = false;
+
+	(void) ops->set_phys_id(dev, ETHTOOL_ID_INACTIVE);
+	return rc;
+}
diff --git a/net/ethtool/common.h b/net/ethtool/common.h
index 5b05f1417b9e..19c2c6da4700 100644
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@ -24,6 +24,7 @@ int __ethtool_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol);
 int __ethtool_set_channels(struct net_device *dev,
 			   const struct ethtool_channels *curr,
 			   struct ethtool_channels *channels);
+int __ethtool_phys_id(struct net_device *dev, unsigned long timeout);
 
 bool convert_legacy_settings_to_link_ksettings(
 	struct ethtool_link_ksettings *link_ksettings,
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index d34af84c1adf..8a7fa834c3d8 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -1644,60 +1644,15 @@ static int ethtool_get_strings(struct net_device *dev, void __user *useraddr)
 static int ethtool_phys_id(struct net_device *dev, void __user *useraddr)
 {
 	struct ethtool_value id;
-	static bool busy;
-	const struct ethtool_ops *ops = dev->ethtool_ops;
 	int rc;
 
-	if (!ops->set_phys_id)
-		return -EOPNOTSUPP;
-
-	if (busy)
-		return -EBUSY;
-
 	if (copy_from_user(&id, useraddr, sizeof(id)))
 		return -EFAULT;
 
-	rc = ops->set_phys_id(dev, ETHTOOL_ID_ACTIVE);
-	if (rc < 0)
-		return rc;
-
-	/* Drop the RTNL lock while waiting, but prevent reentry or
-	 * removal of the device.
-	 */
-	busy = true;
 	dev_hold(dev);
-	rtnl_unlock();
-
-	if (rc == 0) {
-		/* Driver will handle this itself */
-		schedule_timeout_interruptible(
-			id.data ? (id.data * HZ) : MAX_SCHEDULE_TIMEOUT);
-	} else {
-		/* Driver expects to be called at twice the frequency in rc */
-		int n = rc * 2, i, interval = HZ / n;
-
-		/* Count down seconds */
-		do {
-			/* Count down iterations per second */
-			i = n;
-			do {
-				rtnl_lock();
-				rc = ops->set_phys_id(dev,
-				    (i & 1) ? ETHTOOL_ID_OFF : ETHTOOL_ID_ON);
-				rtnl_unlock();
-				if (rc)
-					break;
-				schedule_timeout_interruptible(interval);
-			} while (!signal_pending(current) && --i != 0);
-		} while (!signal_pending(current) &&
-			 (id.data == 0 || --id.data != 0));
-	}
-
-	rtnl_lock();
+	rc = __ethtool_phys_id(dev, id.data);
 	dev_put(dev);
-	busy = false;
 
-	(void) ops->set_phys_id(dev, ETHTOOL_ID_INACTIVE);
 	return rc;
 }
 
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index 7345b9fad227..654979f1c6b6 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -563,6 +563,7 @@ ethnl_notify_handler_t ethnl_notify_handlers[] = {
 	[ETHNL_CMD_SET_SETTINGS]	= ethnl_std_notify,
 	[ETHNL_CMD_SET_PARAMS]		= ethnl_std_notify,
 	[ETHNL_CMD_ACT_NWAY_RST]	= ethnl_nwayrst_notify,
+	[ETHNL_CMD_ACT_PHYS_ID]		= ethnl_physid_notify,
 };
 
 void ethtool_notify(struct net_device *dev, struct netlink_ext_ack *extack,
@@ -699,6 +700,11 @@ static const struct genl_ops ethtool_genl_ops[] = {
 		.flags	= GENL_UNS_ADMIN_PERM,
 		.doit	= ethnl_act_nway_rst,
 	},
+	{
+		.cmd	= ETHNL_CMD_ACT_PHYS_ID,
+		.flags	= GENL_UNS_ADMIN_PERM,
+		.doit	= ethnl_act_phys_id,
+	},
 };
 
 static const struct genl_multicast_group ethtool_nl_mcgrps[] = {
diff --git a/net/ethtool/netlink.h b/net/ethtool/netlink.h
index b5b824f8c1ce..03a5560cf660 100644
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@ -295,11 +295,14 @@ extern const struct get_request_ops params_request_ops;
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info);
 int ethnl_set_params(struct sk_buff *skb, struct genl_info *info);
 int ethnl_act_nway_rst(struct sk_buff *skb, struct genl_info *info);
+int ethnl_act_phys_id(struct sk_buff *skb, struct genl_info *info);
 
 /* notify handlers */
 
 void ethnl_nwayrst_notify(struct net_device *dev,
 			  struct netlink_ext_ack *extack, unsigned int cmd,
 			  u32 req_mask, const void *data);
+void ethnl_physid_notify(struct net_device *dev, struct netlink_ext_ack *extack,
+			 unsigned int cmd, u32 req_mask, const void *data);
 
 #endif /* _NET_ETHTOOL_NETLINK_H */
-- 
2.21.0

