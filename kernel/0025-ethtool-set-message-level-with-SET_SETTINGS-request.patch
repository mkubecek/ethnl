From 51cd5e65ca163a96fbbc31cf841606fdef0ad8d0 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 8 Mar 2019 18:01:46 +0100
Subject: [PATCH 25/47] ethtool: set message level with SET_SETTINGS request

Allow setting device message level using ETHTOOL_A_SETTINGS_DEBUG nested
attribute.

Unlike in ioctl interface "message level" is called "message mask" (as it
is in fact used as a bit mask) and put inside a nested attribute to allow
future extensions.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  8 +++-
 net/ethtool/settings.c                       | 44 +++++++++++++++++++-
 2 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index 960a9b6fd4e8..67b3afe10099 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -341,6 +341,8 @@ to be passed with SET_SETTINGS request:
     ETHTOOL_A_SETTINGS_WOL		(nested)	wake on LAN settings
         ETHTOOL_A_WOL_MODES		    (bitfield32)    wake on LAN modes
         ETHTOOL_A_WOL_SOPASS		    (binary)	    SecureOn password
+    ETHTOOL_A_SETTINGS_DEBUG		(nested)	debugging
+        ETHTOOL_A_DEBUG_MSG_MASK	    (bitfield32)    message mask
 
 ETHTOOL_A_LINKMODES_OURS bit set allows setting advertised link modes. If
 autonegotiation is on (either set now or kept from before), advertised modes
@@ -356,7 +358,9 @@ the selector are set to 0 or 1 according to value. To allow the semantics of
 the ioctl interface where the whole bitmap is set rather than only modified,
 selectors may have also bits not supported by device set and an error is only
 issued if any of them is also set in the value (i.e. if userspace tries to
-enable mode not supported by device).
+enable mode not supported by device). ETHTOOL_A_SETTINGS_MSGLEVEL bitfield
+also allows bits not recognized by kernel in selector as long as the request
+does not attempt to enable them.
 
 
 Request translation
@@ -375,7 +379,7 @@ ETHTOOL_GREGS			n/a
 ETHTOOL_GWOL			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SWOL			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GMSGLVL			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SMSGLVL			n/a
+ETHTOOL_SMSGLVL			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_NWAY_RST		n/a
 ETHTOOL_GLINK			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_GEEPROM			n/a
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 0d8eee5c8b1c..60ed354a0fdb 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -541,6 +541,12 @@ static const struct nla_policy set_wol_policy[ETHTOOL_A_LINKINFO_MAX + 1] = {
 					    .len = SOPASS_MAX },
 };
 
+static const struct nla_policy set_debug_policy[ETHTOOL_A_DEBUG_MAX + 1] = {
+	[ETHTOOL_A_DEBUG_UNSPEC]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_DEBUG_MSG_MASK]	= { .type = NLA_BITFIELD32,
+					    .validation_data = &all_bits },
+};
+
 static const struct nla_policy set_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_UNSPEC]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_DEV]		= { .type = NLA_NESTED },
@@ -550,7 +556,7 @@ static const struct nla_policy set_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_MODES]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_LINK_STATE]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_NESTED },
-	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_NESTED },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
@@ -738,6 +744,35 @@ static int update_wol(struct genl_info *info, struct nlattr *nest,
 	return ret;
 }
 
+static int update_debug(struct genl_info *info, struct nlattr *nest,
+			struct net_device *dev)
+{
+	struct nlattr *tb[ETHTOOL_A_DEBUG_MAX + 1];
+	u32 msglevel;
+	int ret;
+
+	if (!nest)
+		return 0;
+	ret = nla_parse_nested(tb, ETHTOOL_A_DEBUG_MAX, nest,
+			       set_debug_policy, info->extack);
+	if (ret < 0)
+		return ret;
+
+	if (!dev->ethtool_ops->get_msglevel ||
+	    !dev->ethtool_ops->set_msglevel) {
+		GENL_SET_ERR_MSG(info, "device does not provide msglvl access");
+		return -EOPNOTSUPP;
+	}
+	ret = 0;
+	msglevel = dev->ethtool_ops->get_msglevel(dev);
+	if (ethnl_update_bitfield32(&msglevel, tb[ETHTOOL_A_DEBUG_MSG_MASK])) {
+		dev->ethtool_ops->set_msglevel(dev, msglevel);
+		ret = 1;
+	}
+
+	return ret;
+}
+
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *tb[ETHTOOL_A_SETTINGS_MAX + 1];
@@ -774,6 +809,13 @@ int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 		if (ret)
 			req_mask |= ETHTOOL_IM_SETTINGS_WOL;
 	}
+	if (tb[ETHTOOL_A_SETTINGS_DEBUG]) {
+		ret = update_debug(info, tb[ETHTOOL_A_SETTINGS_DEBUG], dev);
+		if (ret < 0)
+			goto out_ops;
+		if (ret)
+			req_mask |= ETHTOOL_IM_SETTINGS_DEBUG;
+	}
 	ret = 0;
 
 out_ops:
-- 
2.21.0

