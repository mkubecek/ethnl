From f169e5bb322e90b58597e6893fdac0987e2b4d9f Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 27 Jul 2018 15:42:51 +0200
Subject: [PATCH 13/19] ethtool: implement GET_SETTINGS request for features

With ETH_SETTINGS_IM_FEATURES info mask, ETHNL_CMD_GET_SETTINGS request
gets network device feature values. This is the same information as
provided via ETHTOOL_GFEATURES ioctl request.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  33 ++--
 include/uapi/linux/ethtool_netlink.h         |  15 +-
 net/ethtool/common.h                         |   2 +
 net/ethtool/ioctl.c                          |   2 -
 net/ethtool/settings.c                       | 156 +++++++++++++++++++
 5 files changed, 196 insertions(+), 12 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index 520222a7f0ff..b9d8770737e1 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -233,6 +233,7 @@ Info mask bits meaning:
     ETH_SETTINGS_IM_MSGLEVEL		msglevel
     ETH_SETTINGS_IM_WOLINFO		struct ethtool_wolinfo
     ETH_SETTINGS_IM_LINK		link state
+    ETH_SETTINGS_IM_FEATURES		features
 
 Response contents:
 
@@ -251,6 +252,11 @@ Response contents:
     ETHA_SETTINGS_LINK_MODES	(bitset)	device link modes
     ETHA_SETTINGS_PEER_MODES	(bitset)	link partner link modes
     ETHA_SETTINGS_LINK		(u8)		link state
+    ETHA_SETTINGS_FEATURES	(nested)	device features
+        ETHA_FEATURES_HW		(bitset)	dev->hw_features
+        ETHA_FEATURES_WANTED		(bitset)	dev->wanted_features
+        ETHA_FEATURES_ACTIVE		(bitset)	dev->features
+        ETHA_FEATURES_NOCHANGE		(bitset)	NETIF_F_NEVER_CHANGE
 
 Most of the attributes have the same meaning (including values) as
 corresponding members of ioctl structures. For ETHA_SETTINGS_MSGLVL, selector
@@ -260,6 +266,15 @@ advertised modes and mask represents supported modes. For
 ETHA_SETTINGS_PEER_MODES, both value and mask represent partner advertised
 link modes.
 
+Bitmaps contained in ETHA_SETTINGS_FEATURES have the same meaning as bitmaps
+used in ioctl interference but attribute names are different (they are based
+on corresponding members of struct net_device). Legacy "flags" are not
+provided, if userspace needs them (most likely only ethtool for backward
+compatibility), it can calculate their values from related feature bits
+itself. ETHA_FEATURES_HW uses mask consisting of all features recognized by
+kernel (to provide all names when using verbose bitmap format), remaining
+three use mask equal to value (to save space).
+
 GET_SETTINGS request is allowed for unprivileged user but ETHA_SETTINGS_SOPASS
 is only provided by kernel in response to privileged (netns CAP_NET_ADMIN)
 requests.
@@ -296,30 +311,30 @@ ETHTOOL_GRINGPARAM		n/a
 ETHTOOL_SRINGPARAM		n/a
 ETHTOOL_GPAUSEPARAM		n/a
 ETHTOOL_SPAUSEPARAM		n/a
-ETHTOOL_GRXCSUM			n/a
+ETHTOOL_GRXCSUM			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SRXCSUM			n/a
-ETHTOOL_GTXCSUM			n/a
+ETHTOOL_GTXCSUM			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_STXCSUM			n/a
-ETHTOOL_GSG			n/a
+ETHTOOL_GSG			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SSG			n/a
 ETHTOOL_TEST			n/a
 ETHTOOL_GSTRINGS		ETHNL_CMD_GET_STRSET
 ETHTOOL_PHYS_ID			n/a
 ETHTOOL_GSTATS			n/a
-ETHTOOL_GTSO			n/a
+ETHTOOL_GTSO			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_STSO			n/a
 ETHTOOL_GPERMADDR		ETHNL_CMD_GET_INFO
-ETHTOOL_GUFO			n/a
+ETHTOOL_GUFO			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SUFO			n/a
-ETHTOOL_GGSO			n/a
+ETHTOOL_GGSO			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SGSO			n/a
-ETHTOOL_GFLAGS			n/a
+ETHTOOL_GFLAGS			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SFLAGS			n/a
 ETHTOOL_GPFLAGS			n/a
 ETHTOOL_SPFLAGS			n/a
 ETHTOOL_GRXFH			n/a
 ETHTOOL_SRXFH			n/a
-ETHTOOL_GGRO			n/a
+ETHTOOL_GGRO			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SGRO			n/a
 ETHTOOL_GRXRINGS		n/a
 ETHTOOL_GRXCLSRLCNT		n/a
@@ -334,7 +349,7 @@ ETHTOOL_GRXNTUPLE		n/a
 ETHTOOL_GSSET_INFO		ETHNL_CMD_GET_STRSET
 ETHTOOL_GRXFHINDIR		n/a
 ETHTOOL_SRXFHINDIR		n/a
-ETHTOOL_GFEATURES		n/a
+ETHTOOL_GFEATURES		ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SFEATURES		n/a
 ETHTOOL_GCHANNELS		n/a
 ETHTOOL_SCHANNELS		n/a
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index c6a26b5497d2..be0548c25917 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -201,6 +201,7 @@ enum {
 	ETHA_SETTINGS_LINK_MODES,		/* bitset */
 	ETHA_SETTINGS_PEER_MODES,		/* bitset */
 	ETHA_SETTINGS_LINK,			/* u8 */
+	ETHA_SETTINGS_FEATURES,			/* nest - ETHA_FEATURES_* */
 
 	__ETHA_SETTINGS_CNT,
 	ETHA_SETTINGS_MAX = (__ETHA_SETTINGS_CNT - 1)
@@ -211,8 +212,20 @@ enum {
 #define ETH_SETTINGS_IM_MSGLEVEL		0x04
 #define ETH_SETTINGS_IM_WOLINFO			0x08
 #define ETH_SETTINGS_IM_LINK			0x10
+#define ETH_SETTINGS_IM_FEATURES		0x20
 
-#define ETH_SETTINGS_IM_ALL			0x1f
+#define ETH_SETTINGS_IM_ALL			0x3f
+
+enum {
+	ETHA_FEATURES_UNSPEC,
+	ETHA_FEATURES_HW,			/* bitset */
+	ETHA_FEATURES_WANTED,			/* bitset */
+	ETHA_FEATURES_ACTIVE,			/* bitset */
+	ETHA_FEATURES_NOCHANGE,			/* bitset */
+
+	__ETHA_FEATURES_CNT,
+	ETHA_FEATURES_MAX = (__ETHA_FEATURES_CNT - 1)
+};
 
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
diff --git a/net/ethtool/common.h b/net/ethtool/common.h
index c02bf6d3a7f0..1f6b8955438b 100644
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@ -6,6 +6,8 @@
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
 
+#define ETHTOOL_DEV_FEATURE_WORDS	((NETDEV_FEATURE_COUNT + 31) / 32)
+
 extern const char netdev_features_strings[NETDEV_FEATURE_COUNT][ETH_GSTRING_LEN];
 extern const char rss_hash_func_strings[ETH_RSS_HASH_FUNCS_COUNT][ETH_GSTRING_LEN];
 extern const char tunable_strings[__ETHTOOL_TUNABLE_COUNT][ETH_GSTRING_LEN];
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index b8f59f56e51f..550e2c904bed 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -54,8 +54,6 @@ EXPORT_SYMBOL(ethtool_op_get_ts_info);
 
 /* Handlers for each ethtool command */
 
-#define ETHTOOL_DEV_FEATURE_WORDS	((NETDEV_FEATURE_COUNT + 31) / 32)
-
 static int ethtool_get_features(struct net_device *dev, void __user *useraddr)
 {
 	struct ethtool_gfeatures cmd = {
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 943648444f14..455b55cd125d 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -4,6 +4,66 @@
 #include "common.h"
 #include <linux/rtnetlink.h>
 
+#define FEATURE_NAME_PTR(id) [id] = netdev_features_strings[id]
+static const char *feature_names[] = {
+	FEATURE_NAME_PTR(NETIF_F_SG_BIT),
+	FEATURE_NAME_PTR(NETIF_F_IP_CSUM_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_CSUM_BIT),
+	FEATURE_NAME_PTR(NETIF_F_IPV6_CSUM_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HIGHDMA_BIT),
+	FEATURE_NAME_PTR(NETIF_F_FRAGLIST_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_VLAN_CTAG_TX_BIT),
+
+	FEATURE_NAME_PTR(NETIF_F_HW_VLAN_CTAG_RX_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_VLAN_CTAG_FILTER_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_VLAN_STAG_TX_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_VLAN_STAG_RX_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_VLAN_STAG_FILTER_BIT),
+	FEATURE_NAME_PTR(NETIF_F_VLAN_CHALLENGED_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_BIT),
+	FEATURE_NAME_PTR(NETIF_F_LLTX_BIT),
+	FEATURE_NAME_PTR(NETIF_F_NETNS_LOCAL_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GRO_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GRO_HW_BIT),
+	FEATURE_NAME_PTR(NETIF_F_LRO_BIT),
+
+	FEATURE_NAME_PTR(NETIF_F_TSO_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_ROBUST_BIT),
+	FEATURE_NAME_PTR(NETIF_F_TSO_ECN_BIT),
+	FEATURE_NAME_PTR(NETIF_F_TSO_MANGLEID_BIT),
+	FEATURE_NAME_PTR(NETIF_F_TSO6_BIT),
+	FEATURE_NAME_PTR(NETIF_F_FSO_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_GRE_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_GRE_CSUM_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_IPXIP4_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_IPXIP6_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_UDP_TUNNEL_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_PARTIAL_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_SCTP_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_ESP_BIT),
+	FEATURE_NAME_PTR(NETIF_F_GSO_UDP_L4_BIT),
+
+	FEATURE_NAME_PTR(NETIF_F_FCOE_CRC_BIT),
+	FEATURE_NAME_PTR(NETIF_F_SCTP_CRC_BIT),
+	FEATURE_NAME_PTR(NETIF_F_FCOE_MTU_BIT),
+	FEATURE_NAME_PTR(NETIF_F_NTUPLE_BIT),
+	FEATURE_NAME_PTR(NETIF_F_RXHASH_BIT),
+	FEATURE_NAME_PTR(NETIF_F_RXCSUM_BIT),
+	FEATURE_NAME_PTR(NETIF_F_NOCACHE_COPY_BIT),
+	FEATURE_NAME_PTR(NETIF_F_LOOPBACK_BIT),
+	FEATURE_NAME_PTR(NETIF_F_RXFCS_BIT),
+	FEATURE_NAME_PTR(NETIF_F_RXALL_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_L2FW_DOFFLOAD_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_TC_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_ESP_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_ESP_TX_CSUM_BIT),
+	FEATURE_NAME_PTR(NETIF_F_RX_UDP_TUNNEL_PORT_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_TLS_RECORD_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_TLS_TX_BIT),
+	FEATURE_NAME_PTR(NETIF_F_HW_TLS_RX_BIT),
+};
+
 struct settings_data {
 	struct common_req_info		reqinfo_base;
 	bool				privileged;
@@ -16,6 +76,12 @@ struct settings_data {
 	int				link;
 	u32				msglevel;
 	bool				lpm_empty;
+	struct {
+		u32	hw[ETHTOOL_DEV_FEATURE_WORDS];
+		u32	wanted[ETHTOOL_DEV_FEATURE_WORDS];
+		u32	active[ETHTOOL_DEV_FEATURE_WORDS];
+		u32	nochange[ETHTOOL_DEV_FEATURE_WORDS];
+	} features;
 };
 
 /* We want to allow ~0 as selector for backward compatibility (to just set
@@ -46,6 +112,7 @@ static const struct nla_policy settings_policy[ETHA_SETTINGS_MAX + 1] = {
 	[ETHA_SETTINGS_LINK_MODES]	= { .type = NLA_NESTED },
 	[ETHA_SETTINGS_PEER_MODES]	= { .type = NLA_NESTED },
 	[ETHA_SETTINGS_LINK]		= { .type = NLA_U8 },
+	[ETHA_SETTINGS_FEATURES]	= { .type = NLA_NESTED },
 };
 
 static int parse_settings(struct common_req_info *req_info,
@@ -106,6 +173,24 @@ static int ethnl_get_wol(struct genl_info *info, struct net_device *dev,
 	return ret;
 }
 
+static void features_to_bitmap(u32 *dest, netdev_features_t src)
+{
+	unsigned int i;
+
+	for (i = 0; i < ETHTOOL_DEV_FEATURE_WORDS; i++)
+		dest[i] = (u32)(src >> (32 * i));
+}
+
+static int ethnl_get_features(struct net_device *dev,
+			      struct settings_data *data)
+{
+	features_to_bitmap(data->features.hw, dev->hw_features);
+	features_to_bitmap(data->features.wanted, dev->wanted_features);
+	features_to_bitmap(data->features.active, dev->features);
+	features_to_bitmap(data->features.nochange, NETIF_F_NEVER_CHANGE);
+	return 0;
+}
+
 static int prepare_settings(struct common_req_info *req_info,
 			    struct genl_info *info)
 {
@@ -150,6 +235,8 @@ static int prepare_settings(struct common_req_info *req_info,
 	}
 	if (req_mask & ETH_SETTINGS_IM_LINK)
 		data->link = __ethtool_get_link(dev);
+	if (req_mask & ETH_SETTINGS_IM_FEATURES)
+		ethnl_get_features(dev, data);
 	req_rtnl_unlock(req_info);
 
 	data->repdata_base.info_mask = req_mask;
@@ -212,6 +299,35 @@ static int settings_size(const struct common_req_info *req_info)
 	}
 	if (info_mask & ETH_SETTINGS_IM_LINK)
 		len += nla_total_size(sizeof(u32));
+	if (info_mask & ETH_SETTINGS_IM_FEATURES) {
+		ret = ethnl_bitset32_size(compact, NETDEV_FEATURE_COUNT,
+					  data->features.hw, NULL,
+					  feature_names);
+		if (ret < 0)
+			return ret;
+		len += ret;
+		ret = ethnl_bitset32_size(compact, NETDEV_FEATURE_COUNT,
+					  data->features.wanted,
+					  data->features.wanted,
+					  feature_names);
+		if (ret < 0)
+			return ret;
+		len += ret;
+		ret = ethnl_bitset32_size(compact, NETDEV_FEATURE_COUNT,
+					  data->features.active,
+					  data->features.active,
+					  feature_names);
+		if (ret < 0)
+			return ret;
+		len += ret;
+		ret = ethnl_bitset32_size(compact, NETDEV_FEATURE_COUNT,
+					  data->features.nochange,
+					  data->features.nochange,
+					  feature_names);
+		if (ret < 0)
+			return ret;
+		len += ret;
+	}
 
 	return len;
 }
@@ -280,6 +396,41 @@ static int fill_wolinfo(struct sk_buff *skb,
 	return 0;
 }
 
+static int fill_features(struct sk_buff *skb, const struct settings_data *data)
+{
+	bool compact = data->reqinfo_base.compact;
+	struct nlattr *feat_attr;
+	int ret;
+
+	feat_attr = ethnl_nest_start(skb, ETHA_SETTINGS_FEATURES);
+	if (!feat_attr)
+		return -EMSGSIZE;
+
+	ret = ethnl_put_bitset32(skb, ETHA_FEATURES_HW, compact,
+				 NETDEV_FEATURE_COUNT, data->features.hw, NULL,
+				 feature_names);
+	if (ret < 0)
+		return ret;
+	ret = ethnl_put_bitset32(skb, ETHA_FEATURES_WANTED, compact,
+				 NETDEV_FEATURE_COUNT, data->features.wanted,
+				 data->features.wanted, feature_names);
+	if (ret < 0)
+		return ret;
+	ret = ethnl_put_bitset32(skb, ETHA_FEATURES_ACTIVE, compact,
+				 NETDEV_FEATURE_COUNT, data->features.active,
+				 data->features.active, feature_names);
+	if (ret < 0)
+		return ret;
+	ret = ethnl_put_bitset32(skb, ETHA_FEATURES_NOCHANGE, compact,
+				 NETDEV_FEATURE_COUNT, data->features.nochange,
+				 data->features.nochange, feature_names);
+	if (ret < 0)
+		return ret;
+
+	nla_nest_end(skb, feat_attr);
+	return 0;
+}
+
 static int fill_settings(struct sk_buff *skb,
 			 const struct common_req_info *req_info)
 {
@@ -314,6 +465,11 @@ static int fill_settings(struct sk_buff *skb,
 		if (nla_put_u8(skb, ETHA_SETTINGS_LINK, data->link))
 			return -EMSGSIZE;
 	}
+	if (info_mask & ETH_SETTINGS_IM_FEATURES) {
+		ret = fill_features(skb, data);
+		if (ret < 0)
+			return ret;
+	}
 
 	return 0;
 }
-- 
2.18.0

