From 09ba399af84b9ec1f869af5dea1e0c054ca9ce5e Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sun, 29 Jul 2018 14:58:36 +0200
Subject: [PATCH 24/44] ethtool: set device features with SET_SETTINGS

Allow setting network device features using SET_SETTINGS request with
ETHTOOL_A_SETTINGS_FEATURES nested attribute.

Actual change is subject to netdev_change_features() sanity checks so that
it can differ from what was requested. Unlike with most other GET requests,
kernel can reply (if ETHTOOL_A_FEATURES_WANT_DIFF flag is used) with a
message in the same format but with different semantics: information about
difference between user request and actual result and difference between
old and new state of dev->features.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  32 ++--
 include/uapi/linux/ethtool_netlink.h         |   1 +
 net/ethtool/settings.c                       | 159 ++++++++++++++++++-
 3 files changed, 182 insertions(+), 10 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index d82aa5e24693..c0a4027adcb2 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -359,6 +359,9 @@ to be passed with SET_SETTINGS request:
         ETHTOOL_A_WOL_SOPASS		    (binary)	    SecureOn password
     ETHTOOL_A_SETTINGS_DEBUG		(nested)	debugging
         ETHTOOL_A_DEBUG_MSG_MASK	    (bitfield32)    message mask
+    ETHTOOL_A_SETTINGS_FEATURES		(nested)	device features
+        ETHTOOL_A_FEATURES_WANTED	    (bitset)	    wanted features
+        ETHTOOL_A_FEATURES_WANT_DIFF	    (flag)	    actual diff
 
 ETHTOOL_A_LINKMODES_OURS bit set allows setting advertised link modes. If
 autonegotiation is on (either set now or kept from before), advertised modes
@@ -378,6 +381,17 @@ enable mode not supported by device). ETHTOOL_A_SETTINGS_MSGLEVEL bitfield
 also allows bits not recognized by kernel in selector as long as the request
 does not attempt to enable them.
 
+When changing device features, only ETHTOOL_A_FEATURES_WANTED is passed. As
+usual, mask defines which bits are to be set and value their values. If the
+request has ETHTOOL_A_FEATURES_WANT_DIFF flag set, reply will contain
+a message in the same format as response to GET request, except only two
+bitsets are provided.  ETHTOOL_A_FEATURES_WANTED shows difference between
+requested features and actual result (dev->features after the operation); mask
+shows bits which differ and value their values from the original request (new
+values are negated). Value shows changes between old dev->features (before the
+operation) and new (after the operation); mask shows bits which have been
+changed and value their new values.
+
 
 Request translation
 -------------------
@@ -407,30 +421,30 @@ ETHTOOL_SRINGPARAM		n/a
 ETHTOOL_GPAUSEPARAM		n/a
 ETHTOOL_SPAUSEPARAM		n/a
 ETHTOOL_GRXCSUM			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SRXCSUM			n/a
+ETHTOOL_SRXCSUM			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GTXCSUM			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_STXCSUM			n/a
+ETHTOOL_STXCSUM			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GSG			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SSG			n/a
+ETHTOOL_SSG			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_TEST			n/a
 ETHTOOL_GSTRINGS		ETHNL_CMD_GET_STRSET
 ETHTOOL_PHYS_ID			n/a
 ETHTOOL_GSTATS			n/a
 ETHTOOL_GTSO			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_STSO			n/a
+ETHTOOL_STSO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GPERMADDR		rtnetlink RTM_GETLINK
 ETHTOOL_GUFO			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SUFO			n/a
+ETHTOOL_SUFO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GGSO			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SGSO			n/a
+ETHTOOL_SGSO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GFLAGS			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SFLAGS			n/a
+ETHTOOL_SFLAGS			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GPFLAGS			n/a
 ETHTOOL_SPFLAGS			n/a
 ETHTOOL_GRXFH			n/a
 ETHTOOL_SRXFH			n/a
 ETHTOOL_GGRO			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SGRO			n/a
+ETHTOOL_SGRO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GRXRINGS		n/a
 ETHTOOL_GRXCLSRLCNT		n/a
 ETHTOOL_GRXCLSRULE		n/a
@@ -445,7 +459,7 @@ ETHTOOL_GSSET_INFO		ETHNL_CMD_GET_STRSET
 ETHTOOL_GRXFHINDIR		n/a
 ETHTOOL_SRXFHINDIR		n/a
 ETHTOOL_GFEATURES		ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SFEATURES		n/a
+ETHTOOL_SFEATURES		ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GCHANNELS		n/a
 ETHTOOL_SCHANNELS		n/a
 ETHTOOL_SET_DUMP		n/a
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 0edd69c4dbb8..45e21b3c1686 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -274,6 +274,7 @@ enum {
 	ETHTOOL_A_FEATURES_WANTED,		/* bitset */
 	ETHTOOL_A_FEATURES_ACTIVE,		/* bitset */
 	ETHTOOL_A_FEATURES_NOCHANGE,		/* bitset */
+	ETHTOOL_A_FEATURES_WANT_DIFF,		/* flag */
 
 	__ETHTOOL_A_FEATURES_CNT,
 	ETHTOOL_A_FEATURES_MAX = (__ETHTOOL_A_FEATURES_CNT - 1)
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 0f0e47a96f9d..ae6463d50af5 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -655,6 +655,15 @@ static const struct nla_policy set_debug_policy[ETHTOOL_A_DEBUG_MAX + 1] = {
 					    .validation_data = &all_bits },
 };
 
+static const struct nla_policy set_features_policy[ETHTOOL_A_FEATURES_MAX + 1] = {
+	[ETHTOOL_A_FEATURES_UNSPEC]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_FEATURES_HW]			= { .type = NLA_REJECT },
+	[ETHTOOL_A_FEATURES_WANTED]		= { .type = NLA_NESTED },
+	[ETHTOOL_A_FEATURES_ACTIVE]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_FEATURES_NOCHANGE]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_FEATURES_WANT_DIFF]		= { .type = NLA_FLAG },
+};
+
 static const struct nla_policy set_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_UNSPEC]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_DEV]		= { .type = NLA_NESTED },
@@ -665,7 +674,7 @@ static const struct nla_policy set_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_STATE]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_NESTED },
-	[ETHTOOL_A_SETTINGS_FEATURES]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_FEATURES]		= { .type = NLA_NESTED },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
@@ -882,11 +891,148 @@ static int update_debug(struct genl_info *info, struct nlattr *nest,
 	return ret;
 }
 
+static void bitmap_from_features(unsigned long *bitmap, netdev_features_t val)
+{
+	const unsigned int words = BITS_TO_LONGS(NETDEV_FEATURE_COUNT);
+	unsigned int i;
+
+	bitmap_zero(bitmap, NETDEV_FEATURE_COUNT);
+	for (i = 0; i < words; i++)
+		bitmap[i] = (unsigned long)(val >> (i * BITS_PER_LONG));
+}
+
+static netdev_features_t features_from_bitmap(unsigned long *bitmap)
+{
+	const unsigned int words = BITS_TO_LONGS(NETDEV_FEATURE_COUNT);
+	netdev_features_t ret = 0;
+	unsigned int i;
+
+	for (i = 0; i < words; i++)
+		ret |= (netdev_features_t)(bitmap[i]) << (i * BITS_PER_LONG);
+	return ret;
+}
+
+static int update_features(struct genl_info *info, struct net_device *dev,
+			   const struct nlattr *nest, bool compact,
+			   bool *changed)
+{
+	const unsigned int bitset_flags =
+	       (compact ? ETHNL_BITSET_COMPACT : 0) |
+	       ETHNL_BITSET_LEGACY_NAMES;
+	struct nlattr *tb[ETHTOOL_A_FEATURES_MAX + 1];
+	DECLARE_BITMAP(old_active, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(req_wanted, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(req_mask, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(new_active, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(wanted_diff_mask, NETDEV_FEATURE_COUNT);
+	DECLARE_BITMAP(active_diff_mask, NETDEV_FEATURE_COUNT);
+	struct nlattr *feat_attr;
+	struct sk_buff *rskb;
+	void *reply_payload;
+	bool mod = false;
+	int reply_len;
+	int ret;
+
+	*changed = false;
+	ret = nla_parse_nested(tb, ETHTOOL_A_FEATURES_MAX, nest,
+			       set_features_policy, info->extack);
+	if (ret < 0)
+		return ret;
+	if (!tb[ETHTOOL_A_FEATURES_WANTED])
+		return -EINVAL;
+
+	bitmap_from_features(old_active, dev->features);
+	bitmap_copy(req_wanted, old_active, NETDEV_FEATURE_COUNT);
+	bitmap_zero(req_mask, NETDEV_FEATURE_COUNT);
+	mod = ethnl_update_bitset(req_wanted, req_mask, NETDEV_FEATURE_COUNT,
+				  tb[ETHTOOL_A_FEATURES_WANTED], &ret,
+				  netdev_features_strings, true, info);
+	if (ret < 0)
+		return ret;
+	if (features_from_bitmap(req_mask) & ~NETIF_F_ETHTOOL_BITS) {
+		GENL_SET_ERR_MSG(info,
+				 "attempt to change non-ethtool features");
+		return -EINVAL;
+	}
+	if (!mod)
+		return 0;
+
+	dev->wanted_features = features_from_bitmap(req_wanted);
+	__netdev_update_features(dev);
+	bitmap_from_features(new_active, dev->features);
+	*changed = !bitmap_equal(old_active, new_active, NETDEV_FEATURE_COUNT);
+	if (!tb[ETHTOOL_A_FEATURES_WANT_DIFF])
+		return 0;
+
+	bitmap_xor(wanted_diff_mask, req_wanted, new_active,
+		   NETDEV_FEATURE_COUNT);
+	bitmap_xor(active_diff_mask, old_active, new_active,
+		   NETDEV_FEATURE_COUNT);
+	bitmap_and(wanted_diff_mask, wanted_diff_mask, req_mask,
+		   NETDEV_FEATURE_COUNT);
+	bitmap_and(req_wanted, req_wanted, wanted_diff_mask,
+		   NETDEV_FEATURE_COUNT);
+	bitmap_and(new_active, new_active, active_diff_mask,
+		   NETDEV_FEATURE_COUNT);
+
+	rskb = NULL;
+	reply_len = 0;
+	ret = ethnl_bitset_size(NETDEV_FEATURE_COUNT, req_wanted,
+				wanted_diff_mask, netdev_features_strings,
+				bitset_flags);
+	if (ret < 0)
+		goto err;
+	reply_len += ret;
+	ret = ethnl_bitset_size(NETDEV_FEATURE_COUNT, new_active,
+				active_diff_mask, netdev_features_strings,
+				bitset_flags);
+	if (ret < 0)
+		goto err;
+	reply_len += ret;
+	reply_len = dev_ident_size() + nla_total_size(reply_len);
+	ret = -ENOMEM;
+	rskb = ethnl_reply_init(reply_len, dev, ETHNL_CMD_SET_SETTINGS,
+				ETHTOOL_A_SETTINGS_DEV, info, &reply_payload);
+	if (!rskb)
+		goto err;
+
+	ret = -EMSGSIZE;
+	feat_attr = nla_nest_start(rskb, ETHTOOL_A_SETTINGS_FEATURES);
+	if (!feat_attr)
+		goto err;
+	ret = ethnl_put_bitset(rskb, ETHTOOL_A_FEATURES_WANTED,
+			       NETDEV_FEATURE_COUNT, req_wanted,
+			       wanted_diff_mask, netdev_features_strings,
+			       bitset_flags);
+	if (ret < 0)
+		goto err;
+	ret = ethnl_put_bitset(rskb, ETHTOOL_A_FEATURES_ACTIVE,
+			       NETDEV_FEATURE_COUNT, new_active,
+			       active_diff_mask, netdev_features_strings,
+			       bitset_flags);
+	if (ret < 0)
+		goto err;
+	nla_nest_end(rskb, feat_attr);
+
+	genlmsg_end(rskb, reply_payload);
+	return genlmsg_reply(rskb, info);
+err:
+	WARN_ONCE(ret == -EMSGSIZE,
+		  "calculated message payload length (%d) not sufficient\n",
+		  reply_len);
+	if (rskb)
+		nlmsg_free(rskb);
+	if (ret < 0)
+		GENL_SET_ERR_MSG(info, "failed to send reply message");
+	return 0;
+}
+
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *tb[ETHTOOL_A_SETTINGS_MAX + 1];
 	struct net_device *dev;
 	u32 req_mask = 0;
+	bool mod;
 	int ret;
 
 	ret = nlmsg_parse(info->nlhdr, GENL_HDRLEN, tb,
@@ -925,6 +1071,17 @@ int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 		if (ret)
 			req_mask |= ETHTOOL_IM_SETTINGS_DEBUG;
 	}
+	if (tb[ETHTOOL_A_SETTINGS_FEATURES]) {
+		bool compact = tb[ETHTOOL_A_SETTINGS_COMPACT];
+
+		ret = update_features(info, dev,
+				      tb[ETHTOOL_A_SETTINGS_FEATURES], compact,
+				      &mod);
+		if (mod)
+			req_mask |= ETHTOOL_IM_SETTINGS_FEATURES;
+		if (ret < 0)
+			goto out_ops;
+	}
 	ret = 0;
 
 out_ops:
-- 
2.21.0

