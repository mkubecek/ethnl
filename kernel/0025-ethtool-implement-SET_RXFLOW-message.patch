From 35ec98c1b4e605cf5fd3cac884f8cd678d6ead82 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 15 Sep 2018 16:02:04 +0200
Subject: [PATCH 25/25] ethtool: implement SET_RXFLOW message

Request to set data updated by ETHTOOL_SRSSH and ETHTOOL_SRXFHINDIR ioctl
commands. This allows to set

  - set hash function
  - set hash key
  - set indirection table
  - create a new RSS context
  - delete an RSS context

for a device.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  43 +-
 include/uapi/linux/ethtool_netlink.h         |   2 +-
 net/ethtool/netlink.c                        |   5 +
 net/ethtool/netlink.h                        |   1 +
 net/ethtool/rxflow.c                         | 517 +++++++++++++++++++
 5 files changed, 564 insertions(+), 4 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index 89f0e3ed4c4b..07f9790e8643 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -129,7 +129,7 @@ List of message types
     ETHNL_CMD_SET_PARAMS
     ETHNL_CMD_ACT_NWAY_RST
     ETHNL_CMD_GET_RXFLOW
-    ETHNL_CMD_SET_RXFLOW		response only
+    ETHNL_CMD_SET_RXFLOW
 
 All constants use ETHNL_CMD_ prefix, usually followed by "GET", "SET" or "ACT"
 to indicate the type.
@@ -652,6 +652,43 @@ these weights correspond to. If ETHA_ITWGHT_VALUES is omitted, values from 0
 to number of weights minus one are used.
 
 
+SET_RXFLOW
+----------
+
+Request to update flow hashing options, corresponds to legacy commands
+ETHTOOL_SRSSH and ETHTOOL_SRXFHINDIR. Request contents:
+
+    ETHA_RXFLOW_DEV		(nested)	device identification
+    ETHA_RXFLOW_CTXOP		(u32)		context operation
+    ETHA_RXFLOW_CONTEXT		(u32)		RSS context
+    ETHA_RXFLOW_HASH_FN		(bitset)	hash function(s)
+    ETHA_RXFLOW_HASH_KEY	(binary)	hash key
+    ETHA_RXFLOW_INDIR_TBL	(nested)	indirection table description
+
+Values of ETH_RXFLOW_CTXOP:
+
+    ETH_RXFLOW_CTXOP_SET		set values for a context (default)
+    ETH_RXFLOW_CTXOP_NEW		add new RSS context
+    ETH_RXFLOW_CTXOP_DEL		delete a context
+
+If ETH_RXFLOW_CTXOP is omitted or equal to ETH_RXFLOW_CTXOP_SET, request
+updates values of an existing RSS context. If ETHA_RXFLOW_CONTEXT is omitted
+or zero, main context is updated. ETHA_RXFLOW_HASH_FN (bitset) specifies hash
+function(s) to use, ETHA_RXFLOW_HASH_KEY hash key (length must match) and
+ETHA_RXFLOW_INDIR_TBL requested indirection table in the way described above.
+
+ETH_RXFLOW_CTXOP equal to ETH_RXFLOW_CTXOP_NEW works in the same way except
+ETHA_RXFLOW_CONTEXT must not be present and a new RSS context is created (if
+supported by NIC driver). An ETHNL_CMD_SET_RXFLOW message is sent as a reply,
+containing only ETHA_RXFLOW_DEV, ETHA_RXFLOW_CTXOP (= ETH_RXFLOW_CTXOP_NEW)
+and ETHA_RXFLOW_CONTEXT (with new context id).
+
+ETHA_RXFLOW_CTXOP equal to ETH_RXFLOW_CTXOP_DEL requests context deletion
+(if supported by NIC driver). Request must have ETHA_RXFLOW_CONTEXT (which is
+not zero) and must not contain ETHA_RXFLOW_HASH_FN, ETHA_RXFLOW_HASH_KEY or
+ETHA_RXFLOW_INDIR_TBL.
+
+
 Request translation
 -------------------
 
@@ -716,7 +753,7 @@ ETHTOOL_SRXNTUPLE		n/a
 ETHTOOL_GRXNTUPLE		n/a
 ETHTOOL_GSSET_INFO		ETHNL_CMD_GET_STRSET
 ETHTOOL_GRXFHINDIR		ETHNL_CMD_GET_RXFLOW
-ETHTOOL_SRXFHINDIR		n/a
+ETHTOOL_SRXFHINDIR		ETHNL_CMD_SET_RXFLOW
 ETHTOOL_GFEATURES		ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SFEATURES		ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GCHANNELS		ETHNL_CMD_GET_PARAMS
@@ -730,7 +767,7 @@ ETHTOOL_GMODULEEEPROM		n/a
 ETHTOOL_GEEE			ETHNL_CMD_GET_PARAMS
 ETHTOOL_SEEE			ETHNL_CMD_SET_PARAMS
 ETHTOOL_GRSSH			ETHNL_CMD_GET_RXFLOW
-ETHTOOL_SRSSH			n/a
+ETHTOOL_SRSSH			ETHNL_CMD_SET_RXFLOW
 ETHTOOL_GTUNABLE		n/a
 ETHTOOL_STUNABLE		n/a
 ETHTOOL_GPHYSTATS		n/a
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index b3ae9a4502d4..2708ad48b15d 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -20,7 +20,7 @@ enum {
 	ETHNL_CMD_ACT_PHYS_ID,
 	ETHNL_CMD_ACT_RESET,
 	ETHNL_CMD_GET_RXFLOW,
-	ETHNL_CMD_SET_RXFLOW,		/* only for reply */
+	ETHNL_CMD_SET_RXFLOW,
 
 	__ETHNL_CMD_CNT,
 	ETHNL_CMD_MAX = (__ETHNL_CMD_CNT - 1)
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index 3b5983555af4..236bfcda9512 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -1069,6 +1069,11 @@ static const struct genl_ops ethtool_genl_ops[] = {
 		.dumpit	= ethnl_get_dumpit,
 		.done	= ethnl_get_done,
 	},
+	{
+		.cmd	= ETHNL_CMD_SET_RXFLOW,
+		.flags	= GENL_UNS_ADMIN_PERM,
+		.doit	= ethnl_set_rxflow,
+	},
 };
 
 static const struct genl_multicast_group ethtool_nl_mcgrps[] = {
diff --git a/net/ethtool/netlink.h b/net/ethtool/netlink.h
index 21fec8e03207..71104bebbdb7 100644
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@ -285,6 +285,7 @@ struct get_request_ops {
 
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info);
 int ethnl_set_params(struct sk_buff *skb, struct genl_info *info);
+int ethnl_set_rxflow(struct sk_buff *skb, struct genl_info *info);
 int ethnl_act_nway_rst(struct sk_buff *skb, struct genl_info *info);
 int ethnl_act_phys_id(struct sk_buff *skb, struct genl_info *info);
 int ethnl_act_reset(struct sk_buff *skb, struct genl_info *info);
diff --git a/net/ethtool/rxflow.c b/net/ethtool/rxflow.c
index 8a426a532ba1..6a8131283f7f 100644
--- a/net/ethtool/rxflow.c
+++ b/net/ethtool/rxflow.c
@@ -394,3 +394,520 @@ void ethnl_rxflow_notify(struct net_device *dev,
 err_data:
 	rxflow_cleanup(req_info);
 }
+
+/* SET_RXFLOW */
+
+static const struct nla_policy set_rxflow_policy[ETHA_RXFLOW_MAX + 1] = {
+	[ETHA_RXFLOW_UNSPEC]		= { .type = NLA_UNSPEC },
+	[ETHA_RXFLOW_DEV]		= { .type = NLA_NESTED },
+	[ETHA_RXFLOW_CTXOP]		= { .type = NLA_U32 },
+	[ETHA_RXFLOW_CONTEXT]		= { .type = NLA_U32 },
+	[ETHA_RXFLOW_HASH_FN]		= { .type = NLA_NESTED },
+	[ETHA_RXFLOW_HASH_KEY]		= { .type = NLA_BINARY },
+	[ETHA_RXFLOW_INDIR_TBL]		= { .type = NLA_NESTED },
+};
+
+static int set_rxflow_sanity_checks(struct nlattr *tb[], struct genl_info *info,
+				    u32 ctxop, u32 context)
+{
+	if (tb[ETHA_RXFLOW_NRINGS] || tb[ETHA_RXFLOW_INDTBL_SIZE]) {
+		ETHNL_SET_ERRMSG(info, "attempt to set a read only attribute");
+		return -EINVAL;
+	}
+
+	switch(ctxop) {
+	case ETH_RXFLOW_CTXOP_SET:
+		break;
+	case ETH_RXFLOW_CTXOP_NEW:
+		if (context) {
+			ETHNL_SET_ERRMSG(info,
+					 "cannot set context id for new context");
+			return -EINVAL;
+		}
+		break;
+	case ETH_RXFLOW_CTXOP_DEL:
+		if (!context) {
+			ETHNL_SET_ERRMSG(info,
+					 "cannot delete main context");
+			return -EINVAL;
+		}
+		if (tb[ETHA_RXFLOW_HASH_FN] || tb[ETHA_RXFLOW_HASH_KEY] ||
+		    tb[ETHA_RXFLOW_INDIR_TBL]) {
+			ETHNL_SET_ERRMSG(info,
+					 "data [passed when deleting context");
+			return -EINVAL;
+		}
+		break;
+	default:
+		ETHNL_SET_ERRMSG(info, "unknown context operation");
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int set_rxflow_prep_hashfn(struct net_device *dev,
+				  struct genl_info *info,
+				  const struct nlattr *attr, u8 *phashfn,
+				  u32 *info_mask)
+{
+	u32 hash_fn = 0;
+	bool mod;
+	int ret;
+
+	if (!attr) {
+		*phashfn = ETH_RSS_HASH_NO_CHANGE;
+		return 0;
+	}
+	mod = ethnl_update_bitset32(&hash_fn, NULL, ETH_RSS_HASH_FUNCS_COUNT,
+				    attr, &ret, rss_hash_func_strings, true,
+				    info);
+	if (ret < 0)
+		return ret;
+	if (hash_fn > U8_MAX) {
+		ETHNL_SET_ERRMSG(info,
+				 "only first 8 hash functions supported");
+		ret = -EINVAL;
+	} else {
+		*phashfn = mod ? (u8)hash_fn : ETH_RSS_HASH_NO_CHANGE;
+		*info_mask |= (mod ? ETH_RXFLOW_IM_HASHFN : 0);
+	}
+	return ret;
+}
+
+static int set_rxflow_prep_hkey(struct net_device *dev, struct genl_info *info,
+				const struct nlattr *attr, u8 **phkey,
+				u32 *info_mask)
+{
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	u32 hkey_size = 0;
+
+	*phkey = NULL;
+	if (!attr)
+		return 0;
+	if (ops->get_rxfh_key_size)
+		hkey_size = ops->get_rxfh_key_size(dev);
+	if (!hkey_size)
+		return -EOPNOTSUPP;
+	if (nla_len(attr) != hkey_size) {
+		ETHNL_SET_ERRMSG(info, "hash key size does not match");
+		return -EINVAL;
+	}
+
+	*phkey = nla_data(attr);
+	*info_mask |= ETH_RXFLOW_IM_HKEY;
+	return 0;
+}
+
+static const struct nla_policy indtbl_block_policy[ETHA_ITBLK_MAX + 1] = {
+	[ETHA_ITBLK_UNSPEC]	= { .type = NLA_UNSPEC },
+	[ETHA_ITBLK_START]	= { .type = NLA_U32 },
+	[ETHA_ITBLK_LEN]	= { .type = NLA_U32 },
+	[ETHA_ITBLK_DATA]	= { .type = NLA_BINARY },
+};
+
+static int apply_block(u32 *table, unsigned int size,
+		       const struct nlattr *block, unsigned int nrings,
+		       unsigned int entry_size, struct genl_info *info)
+{
+	struct nlattr *tb[ETHA_ITBLK_MAX + 1];
+	const u32 *src32;
+	const u16 *src16;
+	const u8 *src8;
+	unsigned int start, blen, i;
+	int ret;
+
+	ret = nla_parse_nested(tb, ETHA_ITBLK_MAX, block, indtbl_block_policy,
+			       info->extack);
+	if (ret < 0)
+		return ret;
+	if (tb[ETHA_ITBLK_DATA])
+		return -EINVAL;
+
+	start = tb[ETHA_ITBLK_START] ? nla_get_u32(tb[ETHA_ITBLK_START]) : 0;
+	if (start >= size)
+		return -EINVAL;
+	if (tb[ETHA_ITBLK_LEN]) {
+		blen = nla_get_u32(tb[ETHA_ITBLK_LEN]);
+		if (start + blen > size)
+			return -EINVAL;
+	} else {
+		blen = size - start;
+	}
+	if (nla_len(tb[ETHA_ITBLK_DATA]) < blen * entry_size)
+		return -EINVAL;
+
+	switch(entry_size) {
+	case 4:
+		src32 = nla_data(tb[ETHA_ITBLK_DATA]);
+		for (i = 0; i < blen; i++)
+			if (src32[i] >= nrings)
+				goto data_err;
+		memcpy(table + start, src32, blen * entry_size);
+		break;
+	case 2:
+		src16 = nla_data(tb[ETHA_ITBLK_DATA]);
+		for (i = 0; i < blen; i++) {
+			if (src16[i] >= nrings)
+				goto data_err;
+			table[start + i] = src16[i];
+		}
+		break;
+	case 1:
+		src8 = nla_data(tb[ETHA_ITBLK_DATA]);
+		for (i = 0; i < blen; i++) {
+			if (src8[i] >= nrings)
+				goto data_err;
+			table[start + i] = src8[i];
+		}
+		break;
+	}
+
+	return 0;
+data_err:
+	ETHNL_SET_ERRMSG(info, "indtbl entry exceeds max ring number");
+	return -EINVAL;
+}
+
+static const struct nla_policy indtbl_pattern_policy[ETHA_ITPAT_MAX + 1] = {
+	[ETHA_ITPAT_UNSPEC]	= { .type = NLA_UNSPEC },
+	[ETHA_ITPAT_START]	= { .type = NLA_U32 },
+	[ETHA_ITPAT_LEN]	= { .type = NLA_U32 },
+	[ETHA_ITPAT_MIN_RING]	= { .type = NLA_U32 },
+	[ETHA_ITPAT_MAX_RING]	= { .type = NLA_U32 },
+	[ETHA_ITPAT_OFFSET]	= { .type = NLA_U32 },
+};
+
+static int apply_pattern(u32 *table, unsigned int size,
+			 const struct nlattr *pattern, unsigned int n_rings,
+			 struct genl_info *info)
+{
+	struct nlattr *tb[ETHA_ITPAT_MAX + 1];
+	unsigned int max_ring = n_rings - 1;
+	unsigned int blen, mod, n, i;
+	unsigned int min_ring = 0;
+	unsigned int offset = 0;
+	unsigned int start = 0;
+	int ret;
+
+	ret = nla_parse_nested(tb, ETHA_ITPAT_MAX, pattern,
+			       indtbl_pattern_policy, info->extack);
+	if (ret < 0)
+		return ret;
+
+	if (tb[ETHA_ITPAT_START])
+		start = nla_get_u32(tb[ETHA_ITPAT_START]);
+	if (start >= size)
+		return -EINVAL;
+	if (tb[ETHA_ITPAT_LEN]) {
+		blen = nla_get_u32(tb[ETHA_ITPAT_LEN]);
+		if (start + blen > size)
+			return -EINVAL;
+	} else {
+		blen = size - start;
+	}
+	if (tb[ETHA_ITPAT_MIN_RING])
+		min_ring = nla_get_u32(tb[ETHA_ITPAT_MIN_RING]);
+	if (tb[ETHA_ITPAT_MAX_RING])
+		max_ring = nla_get_u32(tb[ETHA_ITPAT_MAX_RING]);
+	if (tb[ETHA_ITPAT_OFFSET])
+		offset = nla_get_u32(tb[ETHA_ITPAT_OFFSET]);
+	if (min_ring >= n_rings || max_ring < min_ring || max_ring >= n_rings)
+		return -EINVAL;
+	mod = max_ring - min_ring + 1;
+
+	for (i = 0; i < blen && i < mod; i++)
+		table[start + i] = min_ring + (start + i + offset) % mod;
+	n = blen / mod;
+	for (i = 0; i < n - 1; i++)
+		memcpy(table + start + i * mod, table + start,
+		       mod * sizeof(table[0]));
+	if (blen % mod)
+		memcpy(table + start + n * mod, table + start, blen % mod);
+
+	return 0;
+}
+
+static const struct nla_policy indtbl_weights_policy[ETHA_ITWGHT_MAX + 1] = {
+	[ETHA_ITWGHT_UNSPEC]	= { .type = NLA_UNSPEC },
+	[ETHA_ITWGHT_VALUES]	= { .type = NLA_BINARY },
+	[ETHA_ITWGHT_WEIGHTS]	= { .type = NLA_BINARY },
+};
+
+static int apply_weights(u32 *table, unsigned int size,
+			 const struct nlattr *attr, unsigned int n_rings,
+			 struct genl_info *info)
+{
+	struct nlattr *tb[ETHA_ITWGHT_MAX + 1];
+	const u32 *weights = NULL;
+	const u32 *values = NULL;
+	unsigned int sum = 0;
+	unsigned int count;
+	int ring, ret, i;
+	s64 balance;
+
+	ret = nla_parse_nested(tb, ETHA_ITWGHT_MAX, attr, indtbl_weights_policy,
+			       info->extack);
+	if (ret < 0)
+		return ret;
+	if (!tb[ETHA_ITWGHT_WEIGHTS] ||
+	    (nla_len(tb[ETHA_ITWGHT_WEIGHTS]) % sizeof(weights[0])))
+		return -EINVAL;
+	weights = nla_data(tb[ETHA_ITWGHT_WEIGHTS]);
+	count = nla_len(tb[ETHA_ITWGHT_WEIGHTS]) / sizeof(weights[0]);
+	if (!count)
+		return -EINVAL;
+	if (tb[ETHA_ITWGHT_VALUES]) {
+		values = nla_data(tb[ETHA_ITWGHT_VALUES]);
+		if (nla_len(tb[ETHA_ITWGHT_VALUES]) !=
+		    nla_len(tb[ETHA_ITWGHT_WEIGHTS]))
+			return -EINVAL;
+	}
+
+	sum = 0;
+	for (i = 0; i < count; i++) {
+		if (weights[i] > size - sum)
+			return -EINVAL;
+		sum += weights[i];
+	}
+	if (!sum)
+		return -EINVAL;
+
+	/* This is the same algorithm as in fill_indir_table() in ethtool.
+	 * Our balance is  i * sum - (*indir_size) * partial + sum - 1
+	 * there. Adding sum -1 compensates for absence of the rounding error
+	 * in ethtool code.
+	 */
+	balance = sum - 1;
+	ring = -1;
+	for (i = 0; i < size; i++) {
+		while (balance >= 0)
+			balance -= size * weights[++ring];
+		table[i] = values ? values[ring] : ring;
+		balance += sum;
+	}
+
+	return 0;
+}
+
+static int set_rxflow_prep_indtbl(struct net_device *dev,
+				  struct genl_info *info,
+				  const struct nlattr *attr, u32 **pindtbl,
+				  u32 *info_mask, bool *reset)
+{
+	struct ethtool_rxnfc rx_rings = { .cmd = ETHTOOL_GRXRINGS };
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	const struct nlattr *patch;
+	bool mod = false;
+	int ret, rem;
+	u32 size = 0;
+	u32 *table;
+	u32 nrings;
+
+	*reset = false;
+	*pindtbl = NULL;
+	if (!attr)
+		return 0;
+	if (!ops->get_rxnfc)
+		return -EOPNOTSUPP;
+	ret = ops->get_rxnfc(dev, &rx_rings, NULL);
+	if (ret < 0)
+		return ret;
+	nrings = rx_rings.data;
+	if (ops->get_rxfh_indir_size)
+		size = ops->get_rxfh_indir_size(dev);
+	if (!size)
+		return -EOPNOTSUPP;
+	table = kcalloc(size, sizeof(table[0]), GFP_KERNEL);
+	if (!table)
+		return -ENOMEM;
+	*pindtbl = 0;
+
+	nla_for_each_nested(patch, attr, rem) {
+		int ptype = nla_type(patch);
+
+		switch(ptype) {
+		case ETHA_INDTBL_BLOCK32:
+			ret = apply_block(table, size, patch, nrings, 4, info);
+			break;
+		case ETHA_INDTBL_BLOCK16:
+			ret = apply_block(table, size, patch, nrings, 2, info);
+			break;
+		case ETHA_INDTBL_BLOCK8:
+			ret = apply_block(table, size, patch, nrings, 1, info);
+			break;
+		case ETHA_INDTBL_PATTERN:
+			ret = apply_pattern(table, size, patch, nrings, info);
+			break;
+		case ETHA_INDTBL_WEIGHTS:
+			ret = apply_weights(table, size, patch, nrings, info);
+			break;
+		default:
+			ETHNL_SET_ERRMSG(info, "unknown indir table data type");
+			ret = -EINVAL;
+		}
+		if (ret < 0) {
+			kfree(table);
+			return ret;
+		}
+		mod = true;
+	}
+	if (!mod) {
+		unsigned int i;
+
+		for (i = 0; i < size; i++)
+			table[i] = i % rx_rings.data;
+		*reset = true;
+	}
+	*pindtbl = table;
+	*info_mask |= ETH_RXFLOW_IM_INDTBL;
+
+	return 0;
+}
+
+static int set_rxflow_del_context(struct net_device *dev, u32 context)
+{
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	int ret;
+
+	ret = ops->set_rxfh_context(dev, NULL, NULL, ETH_RSS_HASH_NO_CHANGE,
+				    &context, true);
+	if (ret == 0) {
+		struct ethtool_rxflow_notification_info ninfo = {
+			.ctx_op		= ETH_RXFLOW_CTXOP_DEL,
+			.context	= context,
+		};
+
+		ethnl_rxflow_notify(dev, NULL, ETHNL_CMD_SET_RXFLOW, 0, &ninfo);
+	}
+	return ret;
+}
+
+static int send_set_rxflow_reply(struct net_device *dev,
+				 struct genl_info *info, u32 context)
+{
+	struct sk_buff *skb;
+	void *reply_payload;
+	int reply_len;
+	int ret;
+
+	reply_len = dev_ident_size();
+	reply_len += 2 * nla_total_size(sizeof(u32));
+	skb = ethnl_reply_init(reply_len, dev, ETHNL_CMD_SET_RXFLOW,
+			       ETHA_RXFLOW_DEV, info, &reply_payload);
+	if (!skb)
+		return -ENOMEM;
+	ret = ethnl_fill_dev(skb, dev, ETHA_RXFLOW_DEV);
+	if (ret < 0)
+		goto err_skb;
+	ret = -EMSGSIZE;
+	if (nla_put_u32(skb, ETHA_RXFLOW_CTXOP, ETH_RXFLOW_CTXOP_NEW) ||
+	    nla_put_u32(skb, ETHA_RXFLOW_CONTEXT, context))
+		goto err_skb;
+
+	genlmsg_end(skb, reply_payload);
+	return genlmsg_reply(skb, info);
+
+err_skb:
+	WARN_ONCE(ret == -EMSGSIZE,
+		  "calculated message payload length (%d) not sufficient\n",
+		  reply_len);
+	if (skb)
+		nlmsg_free(skb);
+	return ret;
+}
+
+int ethnl_set_rxflow(struct sk_buff *skb, struct genl_info *info)
+{
+	unsigned int ctxop = ETH_RXFLOW_CTXOP_SET;
+	struct nlattr *tb[ETHA_RXFLOW_MAX + 1];
+	const struct ethtool_ops *ops;
+	struct net_device *dev;
+	u32 *indtbl = NULL;
+	bool reset_indtbl;
+	u32 info_mask = 0;
+	u32 context = 0;
+	u8 hash_fn;
+	u8 *hkey;
+	int ret;
+
+	ret = genlmsg_parse(info->nlhdr, &ethtool_genl_family, tb,
+			    ETHA_RXFLOW_MAX, set_rxflow_policy, info->extack);
+	if (ret < 0)
+		return ret;
+	if (tb[ETHA_RXFLOW_CONTEXT])
+		context = nla_get_u32(tb[ETHA_RXFLOW_CONTEXT]);
+	if (tb[ETHA_RXFLOW_CTXOP])
+		ctxop = nla_get_u32(tb[ETHA_RXFLOW_CTXOP]);
+	ret = set_rxflow_sanity_checks(tb, info, ctxop, context);
+	if (ret < 0)
+		return ret;
+
+	dev = ethnl_dev_get(info, tb[ETHA_RXFLOW_DEV]);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+	ops = dev->ethtool_ops;
+	ret = -EOPNOTSUPP;
+	if (context && (!ops->get_rxfh_context || !ops->set_rxfh_context))
+		goto out_dev;
+	if (!context && (!ops->get_rxfh || !ops->set_rxfh))
+		goto out_dev;
+
+	ret = ethnl_before_ops(dev, false);
+	if (ret < 0)
+		goto out_dev;
+	if (ctxop == ETH_RXFLOW_CTXOP_DEL) {
+		ret = set_rxflow_del_context(dev, context);
+		goto out_unlock;
+	}
+	if (ctxop == ETH_RXFLOW_CTXOP_NEW)
+		context = ETH_RXFH_CONTEXT_ALLOC;
+	ret = set_rxflow_prep_hashfn(dev, info, tb[ETHA_RXFLOW_HASH_FN],
+				     &hash_fn, &info_mask);
+	if (ret < 0)
+		goto out_unlock;
+	ret = set_rxflow_prep_hkey(dev, info, tb[ETHA_RXFLOW_HASH_KEY], &hkey,
+				   &info_mask);
+	if (ret < 0)
+		goto out_free;
+	ret = set_rxflow_prep_indtbl(dev, info, tb[ETHA_RXFLOW_INDIR_TBL],
+				     &indtbl, &info_mask, &reset_indtbl);
+	if (ret < 0)
+		goto out_free;
+	if (context)
+		ret = ops->set_rxfh_context(dev, indtbl, hkey, hash_fn,
+					    &context, false);
+	else
+		ret = ops->set_rxfh(dev, indtbl, hkey, hash_fn);
+	if (ret == 0 && !context && tb[ETHA_RXFLOW_INDIR_TBL]) {
+		/* indicate whether rxfh was set to default */
+		if (reset_indtbl)
+			dev->priv_flags |= IFF_RXFH_CONFIGURED;
+		else
+			dev->priv_flags &= ~IFF_RXFH_CONFIGURED;
+	}
+	if (ctxop == ETH_RXFLOW_CTXOP_NEW && ret == 0) {
+		ret = send_set_rxflow_reply(dev, info, context);
+		if (ret < 0) {
+			ETHNL_SET_ERRMSG(info, "failed to send reply message");
+			ret = 0;
+		}
+	}
+
+out_free:
+	kfree(indtbl);
+out_unlock:
+	if (ret == 0 && (info_mask || ctxop != ETH_RXFLOW_CTXOP_SET)) {
+		const struct ethtool_rxflow_notification_info ninfo = {
+			.ctx_op		= ctxop,
+			.context	= context,
+		};
+
+		ethtool_notify(dev, NULL, ETHNL_CMD_SET_RXFLOW, info_mask,
+			       &ninfo);
+	}
+	ethnl_after_ops(dev, false);
+out_dev:
+	dev_put(dev);
+	return ret;
+}
-- 
2.19.0

