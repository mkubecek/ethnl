From eab2dcecd8e69f7beb15d80af5ccfe60c7ca11fe Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 16 Feb 2019 15:19:02 +0100
Subject: [PATCH 24/47] ethtool: provide message level in GET_SETTINGS request

Add information about supported and enabled message levels to the
GET_SETTINGS reply when ETHTOOL_IM_SETTINGS_DEBUG flag is set in the
request.

Unlike in the ioctl interface, "message level" is called "message mask" as
it is in fact interpreted as a bit mask. It is put into a nested attribute
ETHTOOL_A_SETTINGS_DEBUG to allow future extensions (e.g. an actual
verbosity level).

Send notification in the same format as reply when message level is
modified using the ioctl interface (ETHTOOL_SMSGLVL command).

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  9 ++++-
 include/linux/netdevice.h                    |  2 +
 include/uapi/linux/ethtool_netlink.h         | 13 ++++++-
 net/ethtool/ioctl.c                          |  3 ++
 net/ethtool/settings.c                       | 40 ++++++++++++++++++++
 5 files changed, 65 insertions(+), 2 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index b9643ddbab5a..960a9b6fd4e8 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -275,6 +275,7 @@ Info mask bits meaning:
     ETHTOOL_IM_SETTINGS_LINKMODES	link modes and related
     ETHTOOL_IM_SETTINGS_LINKSTATE	link state
     ETHTOOL_IM_SETTINGS_WOL		struct ethtool_wolinfo
+    ETHTOOL_IM_SETTINGS_DEBUG		debugging
 
 Response contents:
 
@@ -296,6 +297,8 @@ Response contents:
     ETHTOOL_A_SETTINGS_WOL		(nested)	wake on LAN settings
         ETHTOOL_A_WOL_MODES		    (bitfield32)    wake on LAN modes
         ETHTOOL_A_WOL_SOPASS		    (binary)	    SecureOn password
+    ETHTOOL_A_SETTINGS_DEBUG		(nested)	debugging
+        ETHTOOL_A_DEBUG_MSG_MASK	    (bitfield32)    debug message mask
 
 Most of the attributes and their values have the same meaning as matching
 members of the corresponding ioctl structures. For ETHTOOL_A_LINKMODES_OURS,
@@ -305,6 +308,10 @@ ETHTOOL_A_LINKMODES_PEER in the reply is a bit list.
 For ETHTOOL_A_WOL_MODES, selector reports wake on LAN modes supported by the
 device and value enabled modes.
 
+ETHTOOL_A_DEBUG_MSG_MASK corresponds to message level (which is actually
+a bitfield) as reported by ETHTOOL_GMSGLVL. The selector reports all message
+types recognized by kernel and value types enabled for the device.
+
 GET_SETTINGS request is allowed for unprivileged user but ETHTOOL_A_WOL_SOPASS
 is only provided by kernel in response to privileged (netns CAP_NET_ADMIN)
 requests.
@@ -367,7 +374,7 @@ ETHTOOL_GDRVINFO		ETHNL_CMD_GET_INFO
 ETHTOOL_GREGS			n/a
 ETHTOOL_GWOL			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SWOL			ETHNL_CMD_SET_SETTINGS
-ETHTOOL_GMSGLVL			n/a
+ETHTOOL_GMSGLVL			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SMSGLVL			n/a
 ETHTOOL_NWAY_RST		n/a
 ETHTOOL_GLINK			ETHNL_CMD_GET_SETTINGS
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index c6d2595b99de..3ebbe567cb85 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -3860,6 +3860,8 @@ enum {
 	NETIF_MSG_PKTDATA	= 0x1000,
 	NETIF_MSG_HW		= 0x2000,
 	NETIF_MSG_WOL		= 0x4000,
+
+	NETIF_MSG_ALL		= 0x7fff,
 };
 
 #define netif_msg_drv(p)	((p)->msg_enable & NETIF_MSG_DRV)
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 24928733838f..5c336bce038c 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -198,6 +198,7 @@ enum {
 	ETHTOOL_A_SETTINGS_LINK_MODES,		/* nest - ETHTOOL_A_LINKMODES_* */
 	ETHTOOL_A_SETTINGS_LINK_STATE,		/* nest - ETHTOOL_A_LINKSTATE_* */
 	ETHTOOL_A_SETTINGS_WOL,			/* nest - ETHTOOL_A_WOL_* */
+	ETHTOOL_A_SETTINGS_DEBUG,		/* nest - ETHTOOL_A_DEBUG_* */
 
 	__ETHTOOL_A_SETTINGS_CNT,
 	ETHTOOL_A_SETTINGS_MAX = (__ETHTOOL_A_SETTINGS_CNT - 1)
@@ -207,11 +208,13 @@ enum {
 #define ETHTOOL_IM_SETTINGS_LINKMODES		(1U << 1)
 #define ETHTOOL_IM_SETTINGS_LINKSTATE		(1U << 2)
 #define ETHTOOL_IM_SETTINGS_WOL			(1U << 3)
+#define ETHTOOL_IM_SETTINGS_DEBUG		(1U << 4)
 
 #define ETHTOOL_IM_SETTINGS_ALL (ETHTOOL_IM_SETTINGS_LINKINFO | \
 				 ETHTOOL_IM_SETTINGS_LINKMODES | \
 				 ETHTOOL_IM_SETTINGS_LINKSTATE | \
-				 ETHTOOL_IM_SETTINGS_WOL)
+				 ETHTOOL_IM_SETTINGS_WOL | \
+				 ETHTOOL_IM_SETTINGS_DEBUG)
 
 enum {
 	ETHTOOL_A_LINKINFO_UNSPEC,
@@ -254,6 +257,14 @@ enum {
 	ETHTOOL_A_WOL_MAX = (__ETHTOOL_A_WOL_CNT - 1)
 };
 
+enum {
+	ETHTOOL_A_DEBUG_UNSPEC,
+	ETHTOOL_A_DEBUG_MSG_MASK,		/* bitfield32 */
+
+	__ETHTOOL_A_DEBUG_CNT,
+	ETHTOOL_A_DEBUG_MAX = (__ETHTOOL_A_DEBUG_CNT - 1)
+};
+
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
 #define ETHTOOL_GENL_VERSION 1
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index ec90ad52bb96..dfc9128e093a 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -2479,6 +2479,9 @@ int dev_ethtool(struct net *net, struct ifreq *ifr)
 	case ETHTOOL_SMSGLVL:
 		rc = ethtool_set_value_void(dev, useraddr,
 				       dev->ethtool_ops->set_msglevel);
+		if (rc >= 0)
+			ethtool_notify(dev, NULL, ETHNL_CMD_SET_SETTINGS,
+				       ETHTOOL_IM_SETTINGS_DEBUG, NULL);
 		break;
 	case ETHTOOL_GEEE:
 		rc = ethtool_get_eee(dev, useraddr);
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 28676a0f49cc..0d8eee5c8b1c 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -14,6 +14,7 @@ struct settings_data {
 	struct ethtool_wolinfo		wolinfo;
 	struct ethtool_link_settings	*lsettings;
 	int				link;
+	u32				msglevel;
 	bool				lpm_empty;
 };
 
@@ -123,6 +124,7 @@ static const struct nla_policy get_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_MODES]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_LINK_STATE]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_WOL]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_DEBUG]	= { .type = NLA_REJECT },
 };
 
 static int parse_settings(struct common_req_info *req_info,
@@ -188,6 +190,7 @@ static int prepare_settings(struct common_req_info *req_info,
 	struct settings_data *data =
 		container_of(req_info, struct settings_data, reqinfo_base);
 	struct net_device *dev = data->repdata_base.dev;
+	const struct ethtool_ops *eops = dev->ethtool_ops;
 	u32 req_mask = req_info->req_mask;
 	int ret;
 
@@ -223,6 +226,12 @@ static int prepare_settings(struct common_req_info *req_info,
 		if (ret < 0)
 			req_mask &= ~ETHTOOL_IM_SETTINGS_WOL;
 	}
+	if (req_mask & ETHTOOL_IM_SETTINGS_DEBUG) {
+		if (eops->get_msglevel)
+			data->msglevel = eops->get_msglevel(dev);
+		else
+			req_mask &= ~ETHTOOL_IM_SETTINGS_DEBUG;
+	}
 	ethnl_after_ops(dev);
 
 	data->repdata_base.info_mask = req_mask;
@@ -284,6 +293,11 @@ static int wol_size(void)
 			      nla_total_size(SOPASS_MAX));
 }
 
+static int debug_size(void)
+{
+	return nla_total_size(nla_total_size(sizeof(struct nla_bitfield32)));
+}
+
 /* To keep things simple, reserve space for some attributes which may not
  * be added to the message (e.g. ETHTOOL_A_SETTINGS_SOPASS); therefore the
  * length returned may be bigger than the actual length of the message sent.
@@ -309,6 +323,8 @@ static int settings_size(const struct common_req_info *req_info)
 		len += link_state_size(data->link);
 	if (info_mask & ETHTOOL_IM_SETTINGS_WOL)
 		len += wol_size();
+	if (info_mask & ETHTOOL_IM_SETTINGS_DEBUG)
+		len += debug_size();
 
 	return len;
 }
@@ -427,6 +443,24 @@ static int fill_wolinfo(struct sk_buff *skb,
 	return -EMSGSIZE;
 }
 
+static int fill_debug(struct sk_buff *skb, u32 msglevel)
+{
+	struct nlattr *nest;
+
+	nest = nla_nest_start(skb, ETHTOOL_A_SETTINGS_DEBUG);
+	if (!nest)
+		return -EMSGSIZE;
+	if (nla_put_bitfield32(skb, ETHTOOL_A_DEBUG_MSG_MASK, msglevel,
+			       NETIF_MSG_ALL))
+		goto err;
+	nla_nest_end(skb, nest);
+	return 0;
+
+err:
+	nla_nest_cancel(skb, nest);
+	return -EMSGSIZE;
+}
+
 static int fill_settings(struct sk_buff *skb,
 			 const struct common_req_info *req_info)
 {
@@ -457,6 +491,11 @@ static int fill_settings(struct sk_buff *skb,
 		if (ret < 0)
 			return ret;
 	}
+	if (info_mask & ETHTOOL_IM_SETTINGS_DEBUG) {
+		ret = fill_debug(skb, data->msglevel);
+		if (ret < 0)
+			return ret;
+	}
 
 	return 0;
 }
@@ -511,6 +550,7 @@ static const struct nla_policy set_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_MODES]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_LINK_STATE]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_NESTED },
+	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_REJECT },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
-- 
2.21.0

