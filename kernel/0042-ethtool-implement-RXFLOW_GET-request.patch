From 4351c91c9a7869098da3740e2cd291a2bafeb96c Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 10 Sep 2018 10:12:24 +0200
Subject: [PATCH 42/44] ethtool: implement RXFLOW_GET request

Request the information provided by ETHTOOL_GRSSH, ETHTOOL_GRXRINGS,
ETHTOOL_GRXFH and ETHTOOL_GRXFHINDIR ioctl commands. This allows to query

  - ring count
  - hash function
  - hash key
  - hash fields for flow types
  - indirection table

for a device and potentially also RSS context.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt | 121 ++++-
 include/uapi/linux/ethtool_netlink.h         | 108 +++++
 net/ethtool/Makefile                         |   2 +-
 net/ethtool/netlink.c                        |   8 +
 net/ethtool/netlink.h                        |   1 +
 net/ethtool/rxflow.c                         | 448 +++++++++++++++++++
 6 files changed, 684 insertions(+), 4 deletions(-)
 create mode 100644 net/ethtool/rxflow.c

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index ee4430a7d8cf..bd66ad2795cf 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -159,6 +159,7 @@ Userspace to kernel:
     ETHTOOL_MSG_NWAYRST_ACT		perform renegotiation
     ETHTOOL_MSG_PHYSID_ACT		perform physical identification
     ETHTOOL_MSG_RESET_ACT		perform device reset
+    ETHTOOL_MSG_RXFLOW_GET		get Rx flow parameters
 
 Kernel to userspace:
 
@@ -173,6 +174,7 @@ Kernel to userspace:
     ETHTOOL_MSG_PHYSID_NTF		physical identification notification
     ETHTOOL_MSG_RESET_NTF		device reset notification
     ETHTOOL_MSG_RESET_ACT_REPLY		additional reply for RESET_ACT
+    ETHTOOL_MSG_RXFLOW_GET_REPLY	Rx flow parameters
 
 "GET" requests are sent by userspace applications to retrieve device
 information. They usually do not contain any message specific attributes.
@@ -645,6 +647,119 @@ _were_ actually reset (this is different from ioctl interface). The same
 message is also broadcasted as a notification.
 
 
+RXFLOW_GET
+----------
+
+Request for receive flow hashing options provided by legacy commands
+ETHTOOL_GRSSH and ETHTOOL_GRXFHINDIR. Request contents:
+
+    ETHTOOL_A_RXFLOW_HEADER		(nested)	request header
+    ETHTOOL_A_RXFLOW_CONTEXT		(u32)		context id
+
+Info mask bits:
+
+    ETHTOOL_IM_RXFLOW_HASHFN		hash function
+    ETHTOOL_IM_RXFLOW_HKEY		hash key
+    ETHTOOL_IM_RXFLOW_INDTBL		indirection table
+
+If ETHTOOL_A_RXFLOW_CONTEXT is omitted or zero, data for main context are
+returned.  Context id of ETH_RXFH_CONTEXT_ALLOC (0xffffffff) is not allowed
+for compatibility reasons. Note that most NICs do not support multiple
+contexts.
+
+Reply contents:
+
+    ETHTOOL_A_RXFLOW_HEADER		(nested)	reply header
+    ETHTOOL_A_RXFLOW_CONTEXT		(u32)		context id (only if not main)
+    ETHTOOL_A_RXFLOW_NRINGS		(u32)		number of Rx rings
+    ETHTOOL_A_RXFLOW_HASH_FN		(bitset)	hash function(s)
+    ETHTOOL_A_RXFLOW_HASH_KEY		(binary)	hash key
+    ETHTOOL_A_RXFLOW_HASH_OPTS		(nested)	flow hash options
+        ETHTOOL_A_RXHASHOPTS_OPT	    (nested)	    hash fields for a flow type
+	    ETHTOOL_A_RXHASHOPT_FLOWTYPE	(u32)		flow type
+	    ETHTOOL_A_RXHASHOPT_FIELDS		(bitfield32)	fields used for hash
+	    ETHTOOL_A_RXHASHOPT_DISCARD		(flag)		discard all packets
+    ETHTOOL_A_RXFLOW_INDTBL_SIZE	(u32)		indirection table size
+    ETHTOOL_A_RXFLOW_INDIR_TBL		(nested)	indirection table
+
+ETHTOOL_A_RXFLOW_NRINGS is always present in the reply (regardless of request
+info mask). For ETHTOOL_A_RXFLOW_HASH_FN, mask contains all values supported
+by kernel, value has the bit for active hash function set.
+
+ETHTOOL_A_RXFLOW_HASH_OPTS contains a series of ETHTOOL_A_RXHASHOPTS_OPT
+attributes.  Each describes header fields used to calculate the hash for flow
+type determined by ETHTOOL_A_RXHASHOPT_FLOWTYPE (*_V{4,6}_FLOW constants).
+Flag ETHTOOL_A_RXHASHOPT_DISCARD means that all packets of this type are
+dropped, othewise ETHTOOL_A_RXHASHOPT_FIELDS lists fields used for hash
+(selector has bits for all recognized fields set).
+
+ETHTOOL_A_RXFLOW_INDIR_TBL is a nested attribute consisting of a series of
+"patches" of these types:
+
+    ETHTOOL_A_INDTBL_BLOCK32		block of 32-bit values
+    ETHTOOL_A_INDTBL_BLOCK16		block of 16-bit values
+    ETHTOOL_A_INDTBL_BLOCK8		block of 8-bit values
+    ETHTOOL_A_INDTBL_PATTERN		block cycling over an interval
+    ETHTOOL_A_INDTBL_WEIGHTS		divide table according to weights
+
+Currently kernel only uses one patch for the whole table which is
+ETHTOOL_A_INDTBL_BLOCK32, ETHTOOL_A_INDTBL_BLOCK16 or ETHTOOL_A_INDTBL_BLOCK8,
+depending on the number of rings (smallest usable size is used). Userspace
+applications should not rely on this, though, as the behaviour may change in
+the future.
+
+Code interpreting indirection table starts with table filled with zeros and
+then applies patches in the order in which they appear in the message.
+
+ETHTOOL_A_INDTBL_BLOCK32 is a patch which overwrites a contiguous block in the
+table. Allowed attributes are
+
+    ETHTOOL_A_ITBLK_START		(u32)		starting offset of the block
+    ETHTOOL_A_ITBLK_LEN			(u32)		block length
+    ETHTOOL_A_ITBLK_DATA		(binary)	values to fill into the block
+
+If ETHTOOL_A_ITBLK_START is omitted, 0 is used. If ETHTOOL_A_ITBLK_LEN is
+omitted, the block is assumed to span to the end of the table.
+ETHTOOL_A_ITBLK_DATA consists of an array of unsigned 32-bit values which are
+copied into the table starting at the offset determined by
+ETHTOOL_A_ITBLK_START (or zero). If the array is longer than block length, it
+is truncated. If the array is shorted, its copies are repeated to fill the
+whole block.
+
+ETHTOOL_A_INDTBL_BLOCK16 and ETHTOOL_A_INDTBL_BLOCK8 are interpreted in the
+same way except ETHTOOL_A_ITBLK_DATA consists of an array of u16 and u8
+values, respectively.
+
+ETHTOOL_A_INDTBL_PATTERN is a patch which overwrites a contiguous block by
+numbers cycling over an interval. Allowed attributes are
+
+    ETHTOOL_A_ITPAT_START		(u32)		starting offset of the block
+    ETHTOOL_A_ITPAT_LEN			(u32)		block length
+    ETHTOOL_A_ITPAT_MIN_RING		(u32)		minimum ring number to use
+    ETHTOOL_A_ITPAT_MAX_RING		(u32)		maximum ring number to use
+    ETHTOOL_A_ITPAT_OFFSET		(u32)		offset to shift values by
+
+ETHTOOL_A_ITPAT_START and ETHTOOL_A_ITPAT_END have the same meaning and
+defaults as ETHTOOL_A_ITBLK_* above. The block is filled by repeating values
+from ETHTOOL_A_ITPAT_MIN_RING (defaults to 0) to ETHTOOL_A_ITPAT_MAX_RING
+(defaults to maximum ring number). By default, the starting value is
+ETHTOOL_A_ITPAT_MIN_RING; if ETHTOOL_A_ITPAT_OFFSET is used, its value is
+added (modulo interval length).
+
+ETHTOOL_A_INDTBL_WEIGHTS divides the whole table according to specified
+weights (the exact result is supposed to be the same as traditional code for
+"weight" option of "ethtool -X" produces). Allowed values are
+
+    ETHTOOL_A_ITWGHT_VALUES		(binary)	values to use
+    ETHTOOL_A_ITWGHT_WEIGHTS		(binary)	weights to divide by
+
+ETHTOOL_A_ITWGHT_WEIGHTS is an array of u32 weights. The sum of all weights
+must be strictly positive and must not exceed table size. If
+ETHTOOL_A_ITWGHT_VALUES is present, it must be an u32 array of equal size with
+values (ring numbers) these weights correspond to. If ETHTOOL_A_ITWGHT_VALUES
+is omitted, values from 0 to number of weights minus one are used.
+
+
 Request translation
 -------------------
 
@@ -693,7 +808,7 @@ ETHTOOL_GFLAGS			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SFLAGS			ETHTOOL_MSG_SETTINGS_SET
 ETHTOOL_GPFLAGS			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SPFLAGS			ETHTOOL_MSG_SETTINGS_SET
-ETHTOOL_GRXFH			n/a
+ETHTOOL_GRXFH			ETHTOOL_MSG_RXFLOW_GET
 ETHTOOL_SRXFH			n/a
 ETHTOOL_GGRO			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SGRO			ETHTOOL_MSG_SETTINGS_SET
@@ -708,7 +823,7 @@ ETHTOOL_RESET			ETHTOOL_MSG_RESET_ACT
 ETHTOOL_SRXNTUPLE		n/a
 ETHTOOL_GRXNTUPLE		n/a
 ETHTOOL_GSSET_INFO		ETHTOOL_MSG_STRSET_GET
-ETHTOOL_GRXFHINDIR		n/a
+ETHTOOL_GRXFHINDIR		ETHTOOL_MSG_RXFLOW_GET
 ETHTOOL_SRXFHINDIR		n/a
 ETHTOOL_GFEATURES		ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SFEATURES		ETHTOOL_MSG_SETTINGS_SET
@@ -722,7 +837,7 @@ ETHTOOL_GMODULEINFO		n/a
 ETHTOOL_GMODULEEEPROM		n/a
 ETHTOOL_GEEE			ETHTOOL_MSG_PARAMS_GET
 ETHTOOL_SEEE			ETHTOOL_MSG_PARAMS_SET
-ETHTOOL_GRSSH			n/a
+ETHTOOL_GRSSH			ETHTOOL_MSG_RXFLOW_GET
 ETHTOOL_SRSSH			n/a
 ETHTOOL_GTUNABLE		n/a
 ETHTOOL_STUNABLE		n/a
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index bc91f951a6b7..45af68bcb71a 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -23,6 +23,7 @@ enum {
 	ETHTOOL_MSG_NWAYRST_ACT,
 	ETHTOOL_MSG_PHYSID_ACT,
 	ETHTOOL_MSG_RESET_ACT,
+	ETHTOOL_MSG_RXFLOW_GET,
 
 	/* add new constants above here */
 	__ETHTOOL_MSG_USER_CNT,
@@ -43,6 +44,7 @@ enum {
 	ETHTOOL_MSG_PHYSID_NTF,
 	ETHTOOL_MSG_RESET_NTF,
 	ETHTOOL_MSG_RESET_ACT_REPLY,
+	ETHTOOL_MSG_RXFLOW_GET_REPLY,
 
 	/* add new constants above here */
 	__ETHTOOL_MSG_KERNEL_CNT,
@@ -485,6 +487,112 @@ enum {
 
 #define ETHTOOL_RF_RESET_ALL 0
 
+/* RXFLOW */
+
+enum {
+	ETHTOOL_A_RXFLOW_UNSPEC,
+	ETHTOOL_A_RXFLOW_HEADER,		/* nest - _A_HEADER_* */
+	ETHTOOL_A_RXFLOW_CTXOP,			/* u32 - ETHTOOL_RXFLOW_CTXOP_* */
+	ETHTOOL_A_RXFLOW_CONTEXT,		/* u32 */
+	ETHTOOL_A_RXFLOW_NRINGS,		/* u32 */
+	ETHTOOL_A_RXFLOW_HASH_FN,		/* bitset */
+	ETHTOOL_A_RXFLOW_HASH_KEY,		/* binary */
+	ETHTOOL_A_RXFLOW_HASH_OPTS,		/* nest - _A_RXHASHOPTS_* */
+	ETHTOOL_A_RXFLOW_INDTBL_SIZE,		/* u32 */
+	ETHTOOL_A_RXFLOW_INDIR_TBL,		/* nest - _A_INDTBL_* */
+
+	/* add new constants above here */
+	__ETHTOOL_A_RXFLOW_CNT,
+	ETHTOOL_A_RXFLOW_MAX = (__ETHTOOL_A_RXFLOW_CNT - 1)
+};
+
+#define ETHTOOL_IM_RXFLOW_INFO			(1U << 0)
+#define ETHTOOL_IM_RXFLOW_HASHFN		(1U << 1)
+#define ETHTOOL_IM_RXFLOW_HKEY			(1U << 2)
+#define ETHTOOL_IM_RXFLOW_HASHOPTS		(1U << 3)
+#define ETHTOOL_IM_RXFLOW_INDTBL		(1U << 4)
+
+#define ETHTOOL_IM_RXFLOW_ALL (ETHTOOL_IM_RXFLOW_INFO | \
+			       ETHTOOL_IM_RXFLOW_HASHFN | \
+			       ETHTOOL_IM_RXFLOW_HKEY | \
+			       ETHTOOL_IM_RXFLOW_HASHOPTS | \
+			       ETHTOOL_IM_RXFLOW_INDTBL)
+
+#define ETHTOOL_RF_RXFLOW_ALL 0
+
+enum {
+	ETHTOOL_RXFLOW_CTXOP_SET,		/* set context data */
+	ETHTOOL_RXFLOW_CTXOP_NEW,		/* create new context */
+	ETHTOOL_RXFLOW_CTXOP_DEL,		/* delete existing context */
+};
+
+enum {
+	ETHTOOL_A_RXHASHOPTS_UNSPEC,
+	ETHTOOL_A_RXHASHOPTS_OPT,		/* nest - ETH_RXHASHOPT_* */
+
+	/* add new constants above here */
+	__ETHTOOL_A_RXHASHOPTS_CNT,
+	ETHTOOL_A_RXHASHOPTS_MAX = (__ETHTOOL_A_RXHASHOPTS_CNT - 1)
+};
+
+enum {
+	ETHTOOL_A_RXHASHOPT_UNSPEC,
+	ETHTOOL_A_RXHASHOPT_FLOWTYPE,		/* u32 */
+	ETHTOOL_A_RXHASHOPT_FIELDS,		/* bitfield32 */
+	ETHTOOL_A_RXHASHOPT_DISCARD,		/* flag */
+
+	/* add new constants above here */
+	__ETHTOOL_A_RXHASHOPT_CNT,
+	ETHTOOL_A_RXHASHOPT_MAX = (__ETHTOOL_A_RXHASHOPT_CNT - 1)
+};
+
+enum {
+	ETHTOOL_A_INDTBL_UNSPEC,
+	ETHTOOL_A_INDTBL_BLOCK32,		/* nest - ETH_ITBLK_* */
+	ETHTOOL_A_INDTBL_BLOCK16,		/* nest - ETH_ITBLK_* */
+	ETHTOOL_A_INDTBL_BLOCK8, 		/* nest - ETH_ITBLK_* */
+	ETHTOOL_A_INDTBL_PATTERN,		/* nest - ETH_ITPAT_* */
+	ETHTOOL_A_INDTBL_WEIGHTS,		/* nest - ETH_ITWGHT_* */
+
+	/* add new constants above here */
+	__ETHTOOL_A_INDTBL_CNT,
+	ETHTOOL_A_INDTBL_MAX = (__ETHTOOL_A_INDTBL_CNT - 1)
+};
+
+enum {
+	ETHTOOL_A_ITBLK_UNSPEC,
+	ETHTOOL_A_ITBLK_START,			/* u32 */
+	ETHTOOL_A_ITBLK_LEN,			/* u32 */
+	ETHTOOL_A_ITBLK_DATA,			/* binary */
+
+	/* add new constants above here */
+	__ETHTOOL_A_ITBLK_CNT,
+	ETHTOOL_A_ITBLK_MAX = (__ETHTOOL_A_ITBLK_CNT - 1)
+};
+
+enum {
+	ETHTOOL_A_ITPAT_UNSPEC,
+	ETHTOOL_A_ITPAT_START,			/* u32 */
+	ETHTOOL_A_ITPAT_LEN,			/* u32 */
+	ETHTOOL_A_ITPAT_MIN_RING,		/* u32 */
+	ETHTOOL_A_ITPAT_MAX_RING,		/* u32 */
+	ETHTOOL_A_ITPAT_OFFSET,			/* u32 */
+
+	/* add new constants above here */
+	__ETHTOOL_A_ITPAT_CNT,
+	ETHTOOL_A_ITPAT_MAX = (__ETHTOOL_A_ITPAT_CNT - 1)
+};
+
+enum {
+	ETHTOOL_A_ITWGHT_UNSPEC,
+	ETHTOOL_A_ITWGHT_VALUES,		/* binary */
+	ETHTOOL_A_ITWGHT_WEIGHTS,		/* binary */
+
+	/* add new constants above here */
+	__ETHTOOL_A_ITWGHT_CNT,
+	ETHTOOL_A_ITWGHT_MAX = (__ETHTOOL_A_ITWGHT_CNT - 1)
+};
+
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
 #define ETHTOOL_GENL_VERSION 1
diff --git a/net/ethtool/Makefile b/net/ethtool/Makefile
index ca21edc7995f..632ab622e863 100644
--- a/net/ethtool/Makefile
+++ b/net/ethtool/Makefile
@@ -5,4 +5,4 @@ obj-y				+= ioctl.o common.o
 obj-$(CONFIG_ETHTOOL_NETLINK)	+= ethtool_nl.o
 
 ethtool_nl-y	:= netlink.o bitset.o strset.o settings.o info.o params.o \
-		   actions.o
+		   actions.o rxflow.o
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index c9decca333a2..f4dcad5f8c12 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -278,6 +278,7 @@ const struct get_request_ops *get_requests[__ETHTOOL_MSG_USER_CNT] = {
 	[ETHTOOL_MSG_SETTINGS_GET]	= &settings_request_ops,
 	[ETHTOOL_MSG_INFO_GET]		= &info_request_ops,
 	[ETHTOOL_MSG_PARAMS_GET]	= &params_request_ops,
+	[ETHTOOL_MSG_RXFLOW_GET]	= &rxflow_request_ops,
 };
 
 /**
@@ -770,6 +771,13 @@ static const struct genl_ops ethtool_genl_ops[] = {
 		.flags	= GENL_ADMIN_PERM,
 		.doit	= ethnl_act_reset,
 	},
+	{
+		.cmd	= ETHTOOL_MSG_RXFLOW_GET,
+		.doit	= ethnl_get_doit,
+		.start	= ethnl_get_start,
+		.dumpit	= ethnl_get_dumpit,
+		.done	= ethnl_get_done,
+	},
 };
 
 static const struct genl_multicast_group ethtool_nl_mcgrps[] = {
diff --git a/net/ethtool/netlink.h b/net/ethtool/netlink.h
index 9fdd30eeb1b1..b596d34bbc46 100644
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@ -310,6 +310,7 @@ extern const struct get_request_ops strset_request_ops;
 extern const struct get_request_ops settings_request_ops;
 extern const struct get_request_ops info_request_ops;
 extern const struct get_request_ops params_request_ops;
+extern const struct get_request_ops rxflow_request_ops;
 
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info);
 int ethnl_set_params(struct sk_buff *skb, struct genl_info *info);
diff --git a/net/ethtool/rxflow.c b/net/ethtool/rxflow.c
new file mode 100644
index 000000000000..66bea4ac8d57
--- /dev/null
+++ b/net/ethtool/rxflow.c
@@ -0,0 +1,448 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+
+#include "netlink.h"
+#include "common.h"
+#include "bitset.h"
+
+#define RXFLOW_ALL_HASHFNS \
+       ((1 << (ETH_RSS_HASH_FUNCS_COUNT - 1)) | \
+	((1 << (ETH_RSS_HASH_FUNCS_COUNT - 1)) - 1))
+#define FLOW_TYPE_COUNT (ETHER_FLOW + 1)
+#define HASHOPT_FLOW_TYPES \
+	(BIT(TCP_V4_FLOW) | \
+	 BIT(UDP_V4_FLOW) | \
+	 BIT(SCTP_V4_FLOW) | \
+	 BIT(AH_ESP_V4_FLOW) | \
+	 BIT(TCP_V6_FLOW) | \
+	 BIT(UDP_V6_FLOW) | \
+	 BIT(SCTP_V6_FLOW) | \
+	 BIT(AH_ESP_V6_FLOW) | \
+	 BIT(AH_V4_FLOW) | \
+	 BIT(ESP_V4_FLOW) | \
+	 BIT(AH_V6_FLOW) | \
+	 BIT(ESP_V6_FLOW) | \
+	 BIT(IPV4_FLOW) | \
+	 BIT(IPV6_FLOW))
+#define RXH_ALL 0xfe
+#define RXH_COUNT 8
+
+static const struct nla_policy rxflow_get_policy[ETHTOOL_A_RXFLOW_MAX + 1] = {
+	[ETHTOOL_A_RXFLOW_UNSPEC]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_RXFLOW_HEADER]	= { .type = NLA_NESTED },
+	[ETHTOOL_A_RXFLOW_CTXOP]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_RXFLOW_CONTEXT]	= { .type = NLA_U32 },
+	[ETHTOOL_A_RXFLOW_NRINGS]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_RXFLOW_HASH_FN]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_RXFLOW_HASH_KEY]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_RXFLOW_HASH_OPTS]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_RXFLOW_INDTBL_SIZE]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_RXFLOW_INDIR_TBL]	= { .type = NLA_REJECT },
+};
+
+struct rxflow_data {
+	struct ethnl_req_info		reqinfo_base;
+	u32				req_context;
+	u32				req_flow_type;
+
+	/* everything below here will be reset for each device in dumps */
+	struct ethnl_reply_data		repdata_base;
+	unsigned int			entry_size;
+	u32				indtbl_size;
+	u32				hkey_size;
+	u32				n_rings;
+	u32				*indir_tbl;
+	u8				*hkey;
+	u32				hash_fn;
+	u32				hash_fields[FLOW_TYPE_COUNT];
+};
+
+static int rxflow_parse(struct ethnl_req_info *req_info, struct nlattr **tb,
+			struct netlink_ext_ack *extack)
+{
+	struct rxflow_data *data;
+
+	data = container_of(req_info, struct rxflow_data, reqinfo_base);
+	if (tb[ETHTOOL_A_RXFLOW_CONTEXT])
+		data->req_context = nla_get_u32(tb[ETHTOOL_A_RXFLOW_CONTEXT]);
+
+	return 0;
+}
+
+static int rxflow_alloc_hkey(struct rxflow_data *data)
+{
+	if (!data->hkey_size)
+		return -EOPNOTSUPP;
+	data->hkey = kzalloc(data->hkey_size, GFP_KERNEL);
+	return data->hkey ? 0 : -ENOMEM;
+}
+
+static int rxflow_get_hash_opts(struct net_device *dev,
+				struct rxflow_data *data)
+{
+	struct ethtool_rxnfc cmd = {
+		.cmd		= ETHTOOL_GRXFH,
+		.rss_context	= data->req_context,
+	};
+	u32 req_flow_type = data->req_flow_type;
+	u32 *fields = data->hash_fields;
+	unsigned int idx;
+	int ret;
+
+	for (idx = 0; idx < FLOW_TYPE_COUNT; idx++) {
+		if ((req_flow_type && idx != req_flow_type) ||
+		    !(HASHOPT_FLOW_TYPES & (1 << idx)))
+			continue;
+		cmd.flow_type = (data->req_context ? FLOW_RSS : 0) | idx;
+		ret = dev->ethtool_ops->get_rxnfc(dev, &cmd, NULL);
+		if (ret < 0)
+			continue;
+		WARN_ONCE(cmd.data >> 32,
+			  "%s: ethtool_ops->get_rxnfc() returned more than 32 flags\n",
+			  netdev_name(dev));
+		fields[idx] = (u32)cmd.data;
+	}
+
+	return 0;
+}
+
+static int rxflow_alloc_indtbl(struct rxflow_data *data)
+{
+	u32 max_ring;
+
+	if (!data->indtbl_size)
+		return -EOPNOTSUPP;
+
+	max_ring = data->n_rings - 1;
+	data->entry_size = (max_ring >> 16) ? 4 : ((max_ring >> 8) ? 2 : 1);
+	data->indir_tbl = kcalloc(data->indtbl_size, sizeof(u32), GFP_KERNEL);
+	return data->indir_tbl ? 0 : -ENOMEM;
+}
+
+static int rxflow_prepare(struct ethnl_req_info *req_info,
+			  struct genl_info *info)
+{
+	struct rxflow_data *data =
+		container_of(req_info, struct rxflow_data, reqinfo_base);
+	struct ethtool_rxnfc rx_rings = { .cmd = ETHTOOL_GRXRINGS };
+	struct net_device *dev = data->repdata_base.dev;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	u32 req_mask = req_info->req_mask;
+	u8 hash_fn = 0;
+	int ret;
+
+	if (!ops->get_rxnfc)
+		return -EOPNOTSUPP;
+	if (data->req_context && !ops->get_rxfh_context)
+		return -EOPNOTSUPP;
+	if (!data->req_context && !ops->get_rxfh)
+		return -EOPNOTSUPP;
+
+	ret = ethnl_before_ops(dev);
+	if (ret < 0)
+		return ret;
+
+	if (req_mask & ETHTOOL_IM_RXFLOW_INDTBL)
+		req_info->req_mask = (req_mask |= ETHTOOL_IM_RXFLOW_INFO);
+	ret = dev->ethtool_ops->get_rxnfc(dev, &rx_rings, NULL);
+	if (ret < 0)
+		return ret;
+	data->n_rings = rx_rings.data;
+	if (ops->get_rxfh_indir_size)
+		data->indtbl_size = ops->get_rxfh_indir_size(dev);
+	if (ops->get_rxfh_key_size)
+		data->hkey_size = ops->get_rxfh_key_size(dev);
+
+	if (req_mask & ETHTOOL_IM_RXFLOW_HKEY) {
+		ret = rxflow_alloc_hkey(data);
+		if (ret < 0)
+			req_mask &= ~ETHTOOL_IM_RXFLOW_HKEY;
+	}
+	if (req_mask & ETHTOOL_IM_RXFLOW_HASHOPTS) {
+		ret = rxflow_get_hash_opts(dev, data);
+		if (ret < 0)
+			req_mask &= ~ETHTOOL_IM_RXFLOW_HASHOPTS;
+	}
+	if (req_mask & ETHTOOL_IM_RXFLOW_INDTBL) {
+		ret = rxflow_alloc_indtbl(data);
+		if (ret < 0)
+			req_mask &= ~ETHTOOL_IM_RXFLOW_INDTBL;
+	}
+	if (data->req_context)
+		ret = ops->get_rxfh_context(dev, data->indir_tbl, data->hkey,
+					    &hash_fn, data->req_context);
+	else
+		ret = ops->get_rxfh(dev, data->indir_tbl, data->hkey, &hash_fn);
+	if (ret == 0)
+		data->hash_fn = hash_fn;
+	ethnl_after_ops(dev);
+
+	data->repdata_base.info_mask = req_mask;
+	if (ret == 0 && (req_info->req_mask & ~req_mask) && info)
+		GENL_SET_ERR_MSG(info,
+				 "not all requested data could be retrieved");
+	return ret;
+}
+
+static int rxflow_hashopts_size(const u32 *fields)
+{
+	unsigned int i;
+	int len = 0;
+
+	for (i = 0; i < FLOW_TYPE_COUNT; i++) {
+		unsigned int i_len;
+
+		if (!fields[i])
+			continue;
+		i_len = (fields[i] & RXH_DISCARD) ?
+			0 : sizeof(struct nla_bitfield32);
+		len += nla_total_size(nla_total_size(sizeof(u32)) +
+				      nla_total_size(i_len));
+	}
+
+	return nla_total_size(len);
+}
+
+static int rxflow_indtbl_size(const struct rxflow_data *data)
+{
+	unsigned int len;
+
+	/* block data */
+	len = nla_total_size(data->indtbl_size * data->entry_size);
+	/* block nest */
+	len =  nla_total_size(2 *  nla_total_size(sizeof(u32)) + len);
+	/* ETHTOOL_A_RXFLOW_INDTBL_SIZE */
+	len += nla_total_size(sizeof(u32));
+
+	return len;
+}
+
+static int rxflow_size(const struct ethnl_req_info *req_info)
+{
+	const struct rxflow_data *data =
+		container_of(req_info, struct rxflow_data, reqinfo_base);
+	u32 info_mask = data->repdata_base.info_mask;
+	const u32 all_hashfn = RXFLOW_ALL_HASHFNS;
+	int len = 0;
+	int ret;
+
+	len += ethnl_reply_header_size();
+	if (data->req_context)
+		len += nla_total_size(sizeof(u32));
+	if (info_mask & ETHTOOL_IM_RXFLOW_INFO)
+		len += nla_total_size(sizeof(u32));
+	if (info_mask & ETHTOOL_IM_RXFLOW_HASHFN) {
+		unsigned int flags = ETHNL_BITSET_LEGACY_NAMES;
+
+		if (data->reqinfo_base.global_flags & ETHTOOL_RF_COMPACT)
+			flags |= ETHNL_BITSET_COMPACT;
+
+		ret = ethnl_bitset32_size(ETH_RSS_HASH_FUNCS_COUNT,
+					  &data->hash_fn, &all_hashfn,
+					  rss_hash_func_strings, flags);
+		if (ret < 0)
+			return ret;
+		len += ret;
+	}
+	if (info_mask & ETHTOOL_IM_RXFLOW_HKEY)
+		len += nla_total_size(data->hkey_size);
+	if (info_mask & ETHTOOL_IM_RXFLOW_HASHOPTS)
+		len += rxflow_hashopts_size(data->hash_fields);
+	if (info_mask & ETHTOOL_IM_RXFLOW_INDTBL)
+		len += rxflow_indtbl_size(data);
+
+	return len;
+}
+
+static int rxflow_fill_hashfn(struct sk_buff *skb,
+			      const struct rxflow_data *data)
+{
+	unsigned int flags = ETHNL_BITSET_LEGACY_NAMES;
+	const u32 all_hashfn = RXFLOW_ALL_HASHFNS;
+	int ret;
+
+	if (data->reqinfo_base.global_flags & ETHTOOL_RF_COMPACT)
+		flags |= ETHNL_BITSET_COMPACT;
+
+	ret = ethnl_put_bitset32(skb, ETHTOOL_A_RXFLOW_HASH_FN,
+				 ETH_RSS_HASH_FUNCS_COUNT, &data->hash_fn,
+				 &all_hashfn, rss_hash_func_strings, flags);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int rxflow_fill_hashopts(struct sk_buff *skb, const u32 *fields)
+{
+	struct nlattr *attr_opts;
+	struct nlattr *attr_opt;
+	unsigned int i;
+
+	attr_opts = nla_nest_start(skb, ETHTOOL_A_RXFLOW_HASH_OPTS);
+	if (!attr_opts)
+		return -EMSGSIZE;
+
+	for (i = 0; i < FLOW_TYPE_COUNT; i++) {
+		if (!fields[i])
+			continue;
+
+		attr_opt = nla_nest_start(skb, ETHTOOL_A_RXHASHOPTS_OPT);
+		if (!attr_opt)
+			goto nla_put_failure;
+
+		if (nla_put_u32(skb, ETHTOOL_A_RXHASHOPT_FLOWTYPE, i))
+		       goto nla_put_failure;
+		if (fields[i] & RXH_DISCARD) {
+			if (nla_put_flag(skb, ETHTOOL_A_RXHASHOPT_DISCARD))
+				goto nla_put_failure;
+		} else {
+			if (nla_put_bitfield32(skb, ETHTOOL_A_RXHASHOPT_FIELDS,
+					       fields[i], RXH_ALL))
+				goto nla_put_failure;
+		}
+
+		nla_nest_end(skb, attr_opt);
+	}
+
+	nla_nest_end(skb, attr_opts);
+	return 0;
+
+nla_put_failure:
+	nla_nest_cancel(skb, attr_opts);
+	return -EMSGSIZE;
+}
+
+static int rxflow_fill_indtbl(struct sk_buff *skb,
+			      const struct rxflow_data *data)
+{
+	struct nlattr *tbl, *block, *attr;
+	u16 block_attrtype;
+	unsigned int i;
+
+	if (nla_put_u32(skb, ETHTOOL_A_RXFLOW_INDTBL_SIZE, data->indtbl_size))
+		return -EMSGSIZE;
+	tbl = nla_nest_start(skb, ETHTOOL_A_RXFLOW_INDIR_TBL);
+	if (!tbl)
+		return -EMSGSIZE;
+
+	switch(data->entry_size) {
+	case 4:
+		block_attrtype = ETHTOOL_A_INDTBL_BLOCK32;
+		break;
+	case 2:
+		block_attrtype = ETHTOOL_A_INDTBL_BLOCK16;
+		break;
+	case 1:
+		block_attrtype = ETHTOOL_A_INDTBL_BLOCK8;
+		break;
+	default:
+		WARN_ONCE(1, "invalid indir_tbl entry size %u\n",
+			  data->entry_size);
+		return -EFAULT;
+	}
+
+	block = nla_nest_start(skb, block_attrtype);
+	if (!block)
+		goto nla_put_failure;
+
+	if (nla_put_u32(skb, ETHTOOL_A_ITBLK_START, 0) ||
+	    nla_put_u32(skb, ETHTOOL_A_ITBLK_LEN, data->indtbl_size))
+		goto nla_put_failure;
+	switch(data->entry_size) {
+	case 4:
+		if (nla_put(skb, ETHTOOL_A_ITBLK_DATA,
+			    data->indtbl_size * sizeof(u32),
+			    data->indir_tbl))
+			goto nla_put_failure;
+		break;
+	case 2:
+		attr = nla_reserve(skb, ETHTOOL_A_ITBLK_DATA,
+				   data->indtbl_size * data->entry_size);
+		if (!attr)
+			goto nla_put_failure;
+		for (i = 0; i < data->indtbl_size; i++)
+			((u16 *)nla_data(attr))[i] = data->indir_tbl[i];
+		break;
+	case 1:
+		attr = nla_reserve(skb, ETHTOOL_A_ITBLK_DATA,
+				   data->indtbl_size * data->entry_size);
+		if (!attr)
+			goto nla_put_failure;
+		for (i = 0; i < data->indtbl_size; i++)
+			((u8 *)nla_data(attr))[i] = data->indir_tbl[i];
+		break;
+	}
+
+	nla_nest_end(skb, block);
+	nla_nest_end(skb, tbl);
+	return 0;
+
+nla_put_failure:
+	nla_nest_cancel(skb, tbl);
+	return -EMSGSIZE;
+}
+
+static int rxflow_fill(struct sk_buff *skb,
+		       const struct ethnl_req_info *req_info)
+{
+	const struct rxflow_data *data =
+		container_of(req_info, struct rxflow_data, reqinfo_base);
+	u32 info_mask = data->repdata_base.info_mask;
+	int ret;
+
+	if (data->req_context &&
+	    nla_put_u32(skb, ETHTOOL_A_RXFLOW_CONTEXT, data->req_context))
+		return -EMSGSIZE;
+	if ((info_mask & ETHTOOL_IM_RXFLOW_INFO) &&
+	    nla_put_u32(skb, ETHTOOL_A_RXFLOW_NRINGS, data->n_rings))
+		return -EMSGSIZE;
+	if (info_mask & ETHTOOL_IM_RXFLOW_HASHFN) {
+		ret = rxflow_fill_hashfn(skb, data);
+		if (ret < 0)
+			return ret;
+	}
+	if (info_mask & ETHTOOL_IM_RXFLOW_HKEY) {
+		if (nla_put(skb, ETHTOOL_A_RXFLOW_HASH_KEY, data->hkey_size,
+			    data->hkey))
+			return -EMSGSIZE;
+	}
+	if (info_mask & ETHTOOL_IM_RXFLOW_HASHOPTS) {
+		ret = rxflow_fill_hashopts(skb, data->hash_fields);
+		if (ret < 0)
+			return ret;
+	}
+	if (info_mask & ETHTOOL_IM_RXFLOW_INDTBL) {
+		ret = rxflow_fill_indtbl(skb, data);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void rxflow_cleanup(struct ethnl_req_info *req_info)
+{
+	struct rxflow_data *data =
+		container_of(req_info, struct rxflow_data, reqinfo_base);
+
+	kfree(data->indir_tbl);
+	kfree(data->hkey);
+}
+
+const struct get_request_ops rxflow_request_ops = {
+	.request_cmd		= ETHTOOL_MSG_RXFLOW_GET,
+	.reply_cmd		= ETHTOOL_MSG_RXFLOW_GET_REPLY,
+	.hdr_attr		= ETHTOOL_A_RXFLOW_HEADER,
+	.max_attr		= ETHTOOL_A_RXFLOW_MAX,
+	.data_size		= sizeof(struct rxflow_data),
+	.repdata_offset		= offsetof(struct rxflow_data, repdata_base),
+	.request_policy		= rxflow_get_policy,
+	.default_infomask	= ETHTOOL_IM_RXFLOW_ALL,
+	.all_reqflags		= ETHTOOL_RF_RXFLOW_ALL,
+
+	.parse_request		= rxflow_parse,
+	.prepare_data		= rxflow_prepare,
+	.reply_size		= rxflow_size,
+	.fill_reply		= rxflow_fill,
+	.cleanup		= rxflow_cleanup,
+};
-- 
2.22.0

