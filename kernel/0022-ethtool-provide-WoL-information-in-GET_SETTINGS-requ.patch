From 2703bde10befef624ca37e429a9f141e2a4ae35c Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 16 Feb 2019 15:08:55 +0100
Subject: [PATCH 22/47] ethtool: provide WoL information in GET_SETTINGS
 request

Add information about supported and enabled wake on LAN modes into the
GET_SETTINGS reply when ETHTOOL_IM_SETTINGS_WOL flag is set in the request.

The GET_SETTINGS request can be still sent by unprivileged users but in
such case the SecureOn password (if any) is not included in the reply.

Send notification in the same format as reply SET_SETTINGS message when
wake on LAN settings are modified using ioctl interface (ETHTOOL_SWOL
command).

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt | 13 +++-
 include/uapi/linux/ethtool_netlink.h         | 14 ++++-
 net/ethtool/common.c                         | 10 ++++
 net/ethtool/common.h                         |  1 +
 net/ethtool/ioctl.c                          | 10 ++--
 net/ethtool/settings.c                       | 63 ++++++++++++++++++++
 6 files changed, 105 insertions(+), 6 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index 3a2ce429b9c1..5f5556f5dc29 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -274,6 +274,7 @@ Info mask bits meaning:
     ETHTOOL_IM_SETTINGS_LINKINFO	link settings
     ETHTOOL_IM_SETTINGS_LINKMODES	link modes and related
     ETHTOOL_IM_SETTINGS_LINKSTATE	link state
+    ETHTOOL_IM_SETTINGS_WOL		struct ethtool_wolinfo
 
 Response contents:
 
@@ -292,12 +293,22 @@ Response contents:
         ETHTOOL_A_LINKMODES_DUPLEX	    (u8)	    duplex mode
     ETHTOOL_A_SETTINGS_LINK_STATE	(nested)	link state
         ETHTOOL_A_LINKSTATE_LINK	    (u8)	    link on/off/unknown
+    ETHTOOL_A_SETTINGS_WOL		(nested)	wake on LAN settings
+        ETHTOOL_A_WOL_MODES		    (bitfield32)    wake on LAN modes
+        ETHTOOL_A_WOL_SOPASS		    (binary)	    SecureOn password
 
 Most of the attributes and their values have the same meaning as matching
 members of the corresponding ioctl structures. For ETHTOOL_A_LINKMODES_OURS,
 value represents advertised modes and mask represents supported modes.
 ETHTOOL_A_LINKMODES_PEER in the reply is a bit list.
 
+For ETHTOOL_A_WOL_MODES, selector reports wake on LAN modes supported by the
+device and value enabled modes.
+
+GET_SETTINGS request is allowed for unprivileged user but ETHTOOL_A_WOL_SOPASS
+is only provided by kernel in response to privileged (netns CAP_NET_ADMIN)
+requests.
+
 GET_SETTINGS requests allow dumps and messages in the same format as response
 to them are broadcasted as notifications on change of these settings using
 netlink or ioctl ethtool interface.
@@ -344,7 +355,7 @@ ETHTOOL_GSET			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SSET			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GDRVINFO		ETHNL_CMD_GET_INFO
 ETHTOOL_GREGS			n/a
-ETHTOOL_GWOL			n/a
+ETHTOOL_GWOL			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SWOL			n/a
 ETHTOOL_GMSGLVL			n/a
 ETHTOOL_SMSGLVL			n/a
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 9093b6f3db19..24928733838f 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -197,6 +197,7 @@ enum {
 	ETHTOOL_A_SETTINGS_LINK_INFO,		/* nest - ETHTOOL_A_LINKINFO_* */
 	ETHTOOL_A_SETTINGS_LINK_MODES,		/* nest - ETHTOOL_A_LINKMODES_* */
 	ETHTOOL_A_SETTINGS_LINK_STATE,		/* nest - ETHTOOL_A_LINKSTATE_* */
+	ETHTOOL_A_SETTINGS_WOL,			/* nest - ETHTOOL_A_WOL_* */
 
 	__ETHTOOL_A_SETTINGS_CNT,
 	ETHTOOL_A_SETTINGS_MAX = (__ETHTOOL_A_SETTINGS_CNT - 1)
@@ -205,10 +206,12 @@ enum {
 #define ETHTOOL_IM_SETTINGS_LINKINFO		(1U << 0)
 #define ETHTOOL_IM_SETTINGS_LINKMODES		(1U << 1)
 #define ETHTOOL_IM_SETTINGS_LINKSTATE		(1U << 2)
+#define ETHTOOL_IM_SETTINGS_WOL			(1U << 3)
 
 #define ETHTOOL_IM_SETTINGS_ALL (ETHTOOL_IM_SETTINGS_LINKINFO | \
 				 ETHTOOL_IM_SETTINGS_LINKMODES | \
-				 ETHTOOL_IM_SETTINGS_LINKSTATE)
+				 ETHTOOL_IM_SETTINGS_LINKSTATE | \
+				 ETHTOOL_IM_SETTINGS_WOL)
 
 enum {
 	ETHTOOL_A_LINKINFO_UNSPEC,
@@ -242,6 +245,15 @@ enum {
 	ETHTOOL_A_LINKSTATE_MAX = (__ETHTOOL_A_LINKSTATE_CNT - 1)
 };
 
+enum {
+	ETHTOOL_A_WOL_UNSPEC,
+	ETHTOOL_A_WOL_MODES,			/* bitfield32 */
+	ETHTOOL_A_WOL_SOPASS,			/* binary */
+
+	__ETHTOOL_A_WOL_CNT,
+	ETHTOOL_A_WOL_MAX = (__ETHTOOL_A_WOL_CNT - 1)
+};
+
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
 #define ETHTOOL_GENL_VERSION 1
diff --git a/net/ethtool/common.c b/net/ethtool/common.c
index 47a5548c118c..1ef13ec78c45 100644
--- a/net/ethtool/common.c
+++ b/net/ethtool/common.c
@@ -214,3 +214,13 @@ int __ethtool_get_link(struct net_device *dev)
 
 	return netif_running(dev) && dev->ethtool_ops->get_link(dev);
 }
+
+int __ethtool_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	if (!dev->ethtool_ops->get_wol)
+		return -EOPNOTSUPP;
+
+	dev->ethtool_ops->get_wol(dev, wol);
+
+	return 0;
+}
diff --git a/net/ethtool/common.h b/net/ethtool/common.h
index a5ddd7f5cfce..bbe3e51f7308 100644
--- a/net/ethtool/common.h
+++ b/net/ethtool/common.h
@@ -18,6 +18,7 @@ phy_tunable_strings[__ETHTOOL_PHY_TUNABLE_COUNT][ETH_GSTRING_LEN];
 int __ethtool_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info);
 int __ethtool_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info);
 int __ethtool_get_link(struct net_device *dev);
+int __ethtool_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol);
 
 bool convert_legacy_settings_to_link_ksettings(
 	struct ethtool_link_ksettings *link_ksettings,
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 66581fd97d30..ec90ad52bb96 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -1242,11 +1242,11 @@ static int ethtool_reset(struct net_device *dev, char __user *useraddr)
 static int ethtool_get_wol(struct net_device *dev, char __user *useraddr)
 {
 	struct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };
+	int rc;
 
-	if (!dev->ethtool_ops->get_wol)
-		return -EOPNOTSUPP;
-
-	dev->ethtool_ops->get_wol(dev, &wol);
+	rc = __ethtool_get_wol(dev, &wol);
+	if (rc < 0)
+		return rc;
 
 	if (copy_to_user(useraddr, &wol, sizeof(wol)))
 		return -EFAULT;
@@ -1269,6 +1269,8 @@ static int ethtool_set_wol(struct net_device *dev, char __user *useraddr)
 		return ret;
 
 	dev->wol_enabled = !!wol.wolopts;
+	ethtool_notify(dev, NULL, ETHNL_CMD_SET_SETTINGS,
+		       ETHTOOL_IM_SETTINGS_WOL, NULL);
 
 	return 0;
 }
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index b790f4c18a06..87807f270448 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -6,10 +6,12 @@
 
 struct settings_data {
 	struct common_req_info		reqinfo_base;
+	bool				privileged;
 
 	/* everything below here will be reset for each device in dumps */
 	struct common_reply_data	repdata_base;
 	struct ethtool_link_ksettings	ksettings;
+	struct ethtool_wolinfo		wolinfo;
 	struct ethtool_link_settings	*lsettings;
 	int				link;
 	bool				lpm_empty;
@@ -114,15 +116,20 @@ static const struct nla_policy get_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_INFO]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_LINK_MODES]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_LINK_STATE]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_WOL]	= { .type = NLA_REJECT },
 };
 
 static int parse_settings(struct common_req_info *req_info,
 			  struct sk_buff *skb, struct genl_info *info,
 			  const struct nlmsghdr *nlhdr)
 {
+	struct settings_data *data =
+		container_of(req_info, struct settings_data, reqinfo_base);
 	struct nlattr *tb[ETHTOOL_A_SETTINGS_MAX + 1];
 	int ret;
 
+	data->privileged = ethnl_is_privileged(skb);
+
 	ret = nlmsg_parse(nlhdr, GENL_HDRLEN, tb, ETHTOOL_A_SETTINGS_MAX,
 			  get_settings_policy, info ? info->extack : NULL);
 	if (ret < 0)
@@ -159,6 +166,16 @@ static int ethnl_get_link_ksettings(struct genl_info *info,
 	return ret;
 }
 
+static int ethnl_get_wol(struct genl_info *info, struct net_device *dev,
+			 struct ethtool_wolinfo *wolinfo)
+{
+	int ret = __ethtool_get_wol(dev, wolinfo);
+
+	if (ret < 0 && info)
+		GENL_SET_ERR_MSG(info, "failed to retrieve wol info");
+	return ret;
+}
+
 static int prepare_settings(struct common_req_info *req_info,
 			    struct genl_info *info)
 {
@@ -195,6 +212,11 @@ static int prepare_settings(struct common_req_info *req_info,
 	}
 	if (req_mask & ETHTOOL_IM_SETTINGS_LINKSTATE)
 		data->link = __ethtool_get_link(dev);
+	if (req_mask & ETHTOOL_IM_SETTINGS_WOL) {
+		ret = ethnl_get_wol(info, dev, &data->wolinfo);
+		if (ret < 0)
+			req_mask &= ~ETHTOOL_IM_SETTINGS_WOL;
+	}
 	ethnl_after_ops(dev);
 
 	data->repdata_base.info_mask = req_mask;
@@ -250,6 +272,12 @@ static int link_state_size(int link)
 	return nla_total_size(nla_total_size(sizeof(u8)));
 }
 
+static int wol_size(void)
+{
+	return nla_total_size(nla_total_size(sizeof(struct nla_bitfield32)) +
+			      nla_total_size(SOPASS_MAX));
+}
+
 /* To keep things simple, reserve space for some attributes which may not
  * be added to the message (e.g. ETHTOOL_A_SETTINGS_SOPASS); therefore the
  * length returned may be bigger than the actual length of the message sent.
@@ -273,6 +301,8 @@ static int settings_size(const struct common_req_info *req_info)
 	}
 	if (info_mask & ETHTOOL_IM_SETTINGS_LINKSTATE)
 		len += link_state_size(data->link);
+	if (info_mask & ETHTOOL_IM_SETTINGS_WOL)
+		len += wol_size();
 
 	return len;
 }
@@ -364,6 +394,33 @@ static int fill_link_state(struct sk_buff *skb, int link)
 	return -EMSGSIZE;
 }
 
+static int fill_wolinfo(struct sk_buff *skb,
+			const struct ethtool_wolinfo *wolinfo, bool privileged)
+{
+	struct nlattr *nest;
+
+	nest = nla_nest_start(skb, ETHTOOL_A_SETTINGS_WOL);
+	if (!nest)
+		return -EMSGSIZE;
+	if (nla_put_bitfield32(skb, ETHTOOL_A_WOL_MODES, wolinfo->wolopts,
+			       wolinfo->supported))
+		goto err;
+	/* ioctl() restricts read access to wolinfo but the actual
+	 * reason is to hide sopass from unprivileged users; netlink
+	 * can show wol modes without sopass
+	 */
+	if (privileged &&
+	    nla_put(skb, ETHTOOL_A_WOL_SOPASS, sizeof(wolinfo->sopass),
+		    wolinfo->sopass))
+		goto err;
+	nla_nest_end(skb, nest);
+	return 0;
+
+err:
+	nla_nest_cancel(skb, nest);
+	return -EMSGSIZE;
+}
+
 static int fill_settings(struct sk_buff *skb,
 			 const struct common_req_info *req_info)
 {
@@ -389,6 +446,11 @@ static int fill_settings(struct sk_buff *skb,
 		if (ret < 0)
 			return ret;
 	}
+	if (info_mask & ETHTOOL_IM_SETTINGS_WOL) {
+		ret = fill_wolinfo(skb, &data->wolinfo, data->privileged);
+		if (ret < 0)
+			return ret;
+	}
 
 	return 0;
 }
@@ -434,6 +496,7 @@ static const struct nla_policy set_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_INFO]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_LINK_MODES]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_LINK_STATE]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_REJECT },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
-- 
2.21.0

