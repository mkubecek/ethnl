From 42dd4f086583df0f8405afaaa3a945c41805b701 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 7 Sep 2018 13:23:31 +0200
Subject: [PATCH 24/33] ethtool: implement SET_SETTINGS for private flags

ETHNL_CMD_SET_SETTINGS gets support for setting device private flags.
Notification is sent when private flags are modified, both via netlink and
via ioctl.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  3 +-
 net/ethtool/settings.c                       | 42 ++++++++++++++++++++
 2 files changed, 44 insertions(+), 1 deletion(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index 829a879b00fd..18554717681b 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -373,6 +373,7 @@ to be passed with SET_SETTINGS request:
     ETHA_SETTINGS_FEATURES	(nested)	device features
         ETHA_FEATURES_WANTED		(bitset)	wanted features
         ETHA_FEATURES_WANT_DIFF		(flag)		actual diff
+    ETHA_SETTINGS_PRIV_FLAGS	(bitset)	device private flags
 
 For both bitfield32 types, value and selector work the usual way, i.e. bits
 set in selector are set to corresponding bits from value and the rest is
@@ -446,7 +447,7 @@ ETHTOOL_SGSO			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GFLAGS			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SFLAGS			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GPFLAGS			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SPFLAGS			n/a
+ETHTOOL_SPFLAGS			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GRXFH			n/a
 ETHTOOL_SRXFH			n/a
 ETHTOOL_GGRO			ETHNL_CMD_GET_SETTINGS
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 6a3b27978ee7..0601c59eb262 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -824,6 +824,7 @@ static const struct nla_policy set_settings_policy[ETHA_SETTINGS_MAX + 1] = {
 	[ETHA_SETTINGS_WOL]		= { .type = NLA_NESTED },
 	[ETHA_SETTINGS_LINK]		= { .type = NLA_REJECT },
 	[ETHA_SETTINGS_FEATURES]	= { .type = NLA_NESTED },
+	[ETHA_SETTINGS_PRIV_FLAGS]	= { .type = NLA_NESTED },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
@@ -1127,6 +1128,39 @@ static int update_features(struct genl_info *info, struct net_device *dev,
 	return 0;
 }
 
+static int update_priv_flags(struct genl_info *info, struct net_device *dev,
+			     const struct nlattr *bitset, bool *changed)
+{
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	unsigned int nflags;
+	void *names = NULL;
+	bool compact;
+	u32 flags;
+	int ret;
+
+	if (!ops->get_priv_flags || !ops->set_priv_flags)
+		return -EOPNOTSUPP;
+	ret = ethnl_bitset_is_compact(bitset, &compact);
+	if (ret < 0)
+		return ret;
+	ret = get_priv_flags_info(dev, &nflags, compact ? NULL : &names);
+	if (ret < 0)
+		return ret;
+	flags = ops->get_priv_flags(dev);
+
+	*changed = ethnl_update_bitset32(&flags, NULL, nflags, bitset, &ret,
+					 names, true, info);
+	if (ret < 0)
+		goto out_free;
+	if (*changed)
+		ret = ops->set_priv_flags(dev, flags);
+
+out_free:
+	if (!compact)
+		kfree(names);
+	return ret;
+}
+
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *tb[ETHA_SETTINGS_MAX + 1];
@@ -1190,6 +1224,14 @@ int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 		if (ret < 0)
 			goto out_ops;
 	}
+	if (tb[ETHA_SETTINGS_PRIV_FLAGS]) {
+		ret = update_priv_flags(info, dev, tb[ETHA_SETTINGS_PRIV_FLAGS],
+					&mod);
+		if (mod)
+			req_mask |= ETH_SETTINGS_IM_PRIVFLAGS;
+		if (ret < 0)
+			goto out_ops;
+	}
 	ret = 0;
 
 out_ops:
-- 
2.20.1

