From a6c86bdb1eeec976caed345f88328b4bd6eb7754 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Tue, 4 Sep 2018 07:36:33 +0200
Subject: [PATCH 41/44] ethtool: implement ETHTOOL_MSG_RESET_ACT message

Request reset of a NIC or its part(s), equivalent of ETHTOOL_RESET.

If successful and at least one component was reset, send a notification.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  29 ++-
 include/uapi/linux/ethtool.h                 |   3 +
 include/uapi/linux/ethtool_netlink.h         |  20 ++
 net/ethtool/actions.c                        | 246 +++++++++++++++++++
 net/ethtool/ioctl.c                          |   6 +
 net/ethtool/netlink.c                        |   6 +
 net/ethtool/netlink.h                        |   4 +
 net/ethtool/strset.c                         |   6 +
 8 files changed, 319 insertions(+), 1 deletion(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index a1bd046677d9..ee4430a7d8cf 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -158,6 +158,7 @@ Userspace to kernel:
     ETHTOOL_MSG_PARAMS_SET		set device parameters
     ETHTOOL_MSG_NWAYRST_ACT		perform renegotiation
     ETHTOOL_MSG_PHYSID_ACT		perform physical identification
+    ETHTOOL_MSG_RESET_ACT		perform device reset
 
 Kernel to userspace:
 
@@ -170,6 +171,8 @@ Kernel to userspace:
     ETHTOOL_MSG_PARAMS_NTF		device parameters notification
     ETHTOOL_MSG_NWAYRST_NTF		renegotiation notification
     ETHTOOL_MSG_PHYSID_NTF		physical identification notification
+    ETHTOOL_MSG_RESET_NTF		device reset notification
+    ETHTOOL_MSG_RESET_ACT_REPLY		additional reply for RESET_ACT
 
 "GET" requests are sent by userspace applications to retrieve device
 information. They usually do not contain any message specific attributes.
@@ -618,6 +621,30 @@ other PHYSID_ACT requests for any device fail with EBUSY. The same holds for
 requests using ETHTOOL_PHYS_ID ioctl command.
 
 
+RESET_ACT
+---------
+
+Reset whole device or selected components (equivalent of ETHTOOL_RESET).
+
+Request contents:
+
+    ETHTOOL_A_RESET_HEADER		(nested)	request header
+    ETHTOOL_A_RESET_ALL			(flag)		reset all compontents
+    ETHTOOL_A_RESET_ALL_DEDICATED	(flag)		reset all dedicated components
+    ETHTOOL_A_RESET_DEDICATED		(bitset)	dedicated components to reset
+    ETHTOOL_A_RESET_SHARED		(bitset)	shared components to reset
+
+Masks for both bitsets are ignored. When ETHTOOL_A_RESET_ALL_DEDICATED flag is
+present, it overrides ETHTOOL_A_RESET_DEDICATED. When ETHTOOL_A_RESET_ALL flag
+is present, it overrides both ETHTOOL_A_RESET_DEDICATED and
+ETHTOOL_A_RESET_SHARED.
+
+If the request is successful and ETHTOOL_RF_REPLY flag was set in request
+header, a message in the same format is returned, indicating which components
+_were_ actually reset (this is different from ioctl interface). The same
+message is also broadcasted as a notification.
+
+
 Request translation
 -------------------
 
@@ -677,7 +704,7 @@ ETHTOOL_GRXCLSRLALL		n/a
 ETHTOOL_SRXCLSRLDEL		n/a
 ETHTOOL_SRXCLSRLINS		n/a
 ETHTOOL_FLASHDEV		n/a
-ETHTOOL_RESET			n/a
+ETHTOOL_RESET			ETHTOOL_MSG_RESET_ACT
 ETHTOOL_SRXNTUPLE		n/a
 ETHTOOL_GRXNTUPLE		n/a
 ETHTOOL_GSSET_INFO		ETHTOOL_MSG_STRSET_GET
diff --git a/include/uapi/linux/ethtool.h b/include/uapi/linux/ethtool.h
index 3ba1508742d4..b9a7861fffd1 100644
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@ -575,6 +575,7 @@ struct ethtool_pauseparam {
  * @ETH_SS_TSTAMP_SOF: timestamping flag names
  * @ETH_SS_TSTAMP_TX_TYPE: timestamping Tx type names
  * @ETH_SS_TSTAMP_RX_FILTER: timestamping Rx filter names
+ * @ETH_SS_RESET_FLAGS: components for device reset
  */
 enum ethtool_stringset {
 	ETH_SS_TEST		= 0,
@@ -590,6 +591,7 @@ enum ethtool_stringset {
 	ETH_SS_TSTAMP_SOF,
 	ETH_SS_TSTAMP_TX_TYPE,
 	ETH_SS_TSTAMP_RX_FILTER,
+	ETH_SS_RESET_FLAGS,
 
 	ETH_SS_COUNT
 };
@@ -1756,6 +1758,7 @@ enum ethtool_reset_flags {
 	ETH_RESET_ALL		= 0xffffffff,	/* All components used by this
 						 * interface, even if shared */
 };
+#define ETH_RESET_NFLAGS 9
 #define ETH_RESET_SHARED_SHIFT	16
 
 
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index c6b3aee4dbb9..bc91f951a6b7 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -22,6 +22,7 @@ enum {
 	ETHTOOL_MSG_PARAMS_SET,
 	ETHTOOL_MSG_NWAYRST_ACT,
 	ETHTOOL_MSG_PHYSID_ACT,
+	ETHTOOL_MSG_RESET_ACT,
 
 	/* add new constants above here */
 	__ETHTOOL_MSG_USER_CNT,
@@ -40,6 +41,8 @@ enum {
 	ETHTOOL_MSG_PARAMS_NTF,
 	ETHTOOL_MSG_NWAYRST_NTF,
 	ETHTOOL_MSG_PHYSID_NTF,
+	ETHTOOL_MSG_RESET_NTF,
+	ETHTOOL_MSG_RESET_ACT_REPLY,
 
 	/* add new constants above here */
 	__ETHTOOL_MSG_KERNEL_CNT,
@@ -465,6 +468,23 @@ enum {
 
 #define ETHTOOL_RF_PHYSID_ALL 0
 
+/* RESET */
+
+enum {
+	ETHTOOL_A_RESET_UNSPEC,
+	ETHTOOL_A_RESET_HEADER,			/* nest - _A_HEADER_* */
+	ETHTOOL_A_RESET_ALL,			/* flag */
+	ETHTOOL_A_RESET_ALL_DEDICATED,		/* flag */
+	ETHTOOL_A_RESET_DEDICATED,		/* bitset */
+	ETHTOOL_A_RESET_SHARED,			/* bitset */
+
+	/* add new constants above here */
+	__ETHTOOL_A_RESET_CNT,
+	ETHTOOL_A_RESET_MAX = (__ETHTOOL_A_RESET_CNT - 1)
+};
+
+#define ETHTOOL_RF_RESET_ALL 0
+
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
 #define ETHTOOL_GENL_VERSION 1
diff --git a/net/ethtool/actions.c b/net/ethtool/actions.c
index 24c1d0d63ba2..aeb8a83baa9f 100644
--- a/net/ethtool/actions.c
+++ b/net/ethtool/actions.c
@@ -2,6 +2,7 @@
 
 #include "netlink.h"
 #include "common.h"
+#include "bitset.h"
 
 /* ACT_NWAY_RST */
 
@@ -171,3 +172,248 @@ int ethnl_act_phys_id(struct sk_buff *skb, struct genl_info *info)
 	dev_put(dev);
 	return ret;
 }
+
+/* ACT_RESET */
+
+const char *const reset_flag_names[] = {
+	"mgmt",
+	"irq",
+	"dma",
+	"filter",
+	"offload",
+	"mac",
+	"phy",
+	"ram",
+	"ap"
+};
+
+static const struct nla_policy reset_policy[ETHTOOL_A_RESET_MAX + 1] = {
+	[ETHTOOL_A_RESET_UNSPEC]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_RESET_HEADER]	= { .type = NLA_NESTED },
+	[ETHTOOL_A_RESET_ALL]		= { .type = NLA_FLAG },
+	[ETHTOOL_A_RESET_ALL_DEDICATED]	= { .type = NLA_FLAG },
+	[ETHTOOL_A_RESET_DEDICATED]	= { .type = NLA_NESTED },
+	[ETHTOOL_A_RESET_SHARED]	= { .type = NLA_NESTED },
+};
+
+static const struct nla_policy reset_hdr_policy[ETHTOOL_A_HEADER_MAX + 1] = {
+	[ETHTOOL_A_HEADER_UNSPEC]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_HEADER_DEV_INDEX]	= { .type = NLA_U32 },
+	[ETHTOOL_A_HEADER_DEV_NAME]	= { .type = NLA_NUL_STRING,
+					    .len = IFNAMSIZ - 1 },
+	[ETHTOOL_A_HEADER_INFOMASK]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_HEADER_GFLAGS]	= { .type = NLA_U32 },
+	[ETHTOOL_A_HEADER_RFLAGS]	= { .type = NLA_REJECT },
+};
+
+static int reset_size(u32 flags, u32 orig_flags, bool compact)
+{
+	const unsigned int bitset_flags = compact ? ETHNL_BITSET_COMPACT : 0;
+	int len = ethnl_reply_header_size();
+	u32 bitmap, bitmask;
+	int ret;
+
+	BUILD_BUG_ON(ETH_RESET_NFLAGS > 16);
+
+	if (flags == ETH_RESET_ALL)
+		return len + nla_total_size(0);
+	bitmap = flags >> 16;
+	bitmask = orig_flags >> 16;
+	ret = ethnl_bitset32_size(ETH_RESET_NFLAGS, &bitmap, &bitmask,
+				  reset_flag_names, bitset_flags);
+	if (ret < 0)
+		return ret;
+	len += ret;
+
+	if ((flags & ETH_RESET_DEDICATED) == ETH_RESET_DEDICATED) {
+		len += nla_total_size(0);
+	} else {
+		bitmap = flags & ETH_RESET_DEDICATED;
+		bitmask = orig_flags & ETH_RESET_DEDICATED;
+		ret = ethnl_bitset32_size(ETH_RESET_NFLAGS, &bitmap, &bitmask,
+					  reset_flag_names, bitset_flags);
+		if (ret < 0)
+			return ret;
+		len += ret;
+	}
+
+	return len;
+}
+
+static int reset_fill(struct sk_buff *skb, u32 flags, u32 orig_flags,
+		      bool compact)
+{
+	const unsigned int bitset_flags = compact ? ETHNL_BITSET_COMPACT : 0;
+	u32 bitmap, bitmask;
+	int ret;
+
+	if (flags == ETH_RESET_ALL)
+		return nla_put_flag(skb, ETHTOOL_A_RESET_ALL) ? -EMSGSIZE : 0;
+
+	if ((flags & ETH_RESET_DEDICATED) == ETH_RESET_DEDICATED) {
+		if (nla_put_flag(skb, ETHTOOL_A_RESET_ALL_DEDICATED))
+			return -EMSGSIZE;
+	} else {
+		bitmap = flags & ETH_RESET_DEDICATED;
+		bitmask = orig_flags & ETH_RESET_DEDICATED;
+		ret = ethnl_put_bitset32(skb, ETHTOOL_A_RESET_DEDICATED,
+					 ETH_RESET_NFLAGS, &bitmap, &bitmask,
+					 reset_flag_names, bitset_flags);
+		if (ret < 0)
+			return ret;
+	}
+
+	bitmap = flags >> ETH_RESET_SHARED_SHIFT;
+	bitmask = orig_flags >> ETH_RESET_SHARED_SHIFT;
+	return ethnl_put_bitset32(skb, ETHTOOL_A_RESET_SHARED, ETH_RESET_NFLAGS,
+				  &bitmap, &bitmask, reset_flag_names,
+				  bitset_flags);
+}
+
+void ethnl_reset_notify(struct net_device *dev,
+                          struct netlink_ext_ack *extack, unsigned int cmd,
+                          u32 req_mask, const void *data)
+{
+	u32 flags = *(const u32 *)data;
+	struct sk_buff *skb;
+	void *msg_payload;
+	int msg_len;
+	int ret;
+
+	msg_len = reset_size(flags, flags, true);
+	if (msg_len < 0)
+		return;
+	skb = genlmsg_new(msg_len, GFP_KERNEL);
+	if (!skb)
+		return;
+
+	msg_payload = ethnl_bcastmsg_put(skb, cmd);
+	if (!msg_payload)
+		goto nla_put_failure;
+	ret = ethnl_fill_reply_header(skb, dev, ETHTOOL_A_RESET_HEADER);
+	if (ret < 0)
+		goto nla_put_failure;
+	ret = reset_fill(skb, flags, flags, true);
+	if (ret < 0)
+		goto nla_put_failure;
+
+	genlmsg_end(skb, msg_payload);
+	ethnl_multicast(skb, dev);
+	return;
+
+nla_put_failure:
+	nlmsg_free(skb);
+}
+
+static int reset_parse(struct nlattr **tb, u32 *val, struct genl_info *info)
+{
+	u32 flags;
+	int ret;
+
+	if (tb[ETHTOOL_A_RESET_ALL]) {
+		*val = ETH_RESET_ALL;
+		return 0;
+	}
+
+	*val = 0;
+	flags = 0;
+	ethnl_update_bitset32(&flags, NULL, ETH_RESET_NFLAGS,
+			      tb[ETHTOOL_A_RESET_SHARED], &ret,
+			      reset_flag_names, false, info);
+	if (ret < 0)
+		return ret;
+	*val |= (flags << ETH_RESET_SHARED_SHIFT);
+
+	if (tb[ETHTOOL_A_RESET_ALL_DEDICATED])
+		*val |= ETH_RESET_DEDICATED;
+	else {
+		flags = 0;
+		ethnl_update_bitset32(&flags, NULL, ETH_RESET_NFLAGS,
+				      tb[ETHTOOL_A_RESET_DEDICATED], &ret,
+				      reset_flag_names, false, info);
+		if (ret < 0)
+			return ret;
+		*val |= flags;
+	}
+
+	return 0;
+}
+
+int ethnl_act_reset(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *tb[ETHTOOL_A_RESET_MAX + 1];
+	struct ethnl_req_info req_info = {};
+	struct sk_buff *rskb = NULL;
+	struct net_device *dev;
+	u32 orig_flags, flags;
+	void *reply_payload;
+	int reply_ret = 0;
+	int reply_len;
+	bool compact;
+	int ret;
+
+	ret = nlmsg_parse(info->nlhdr, GENL_HDRLEN, tb, ETHTOOL_A_RESET_MAX,
+			  reset_policy, info->extack);
+	if (ret < 0)
+		return ret;
+	ret = ethnl_parse_header(&req_info, tb[ETHTOOL_A_RESET_HEADER],
+				 genl_info_net(info), info->extack,
+				 reset_hdr_policy, true);
+	if (ret < 0)
+		return ret;
+	dev = req_info.dev;
+	compact = req_info.global_flags & ETHTOOL_RF_COMPACT;
+	ret = reset_parse(tb, &flags, info);
+	if (ret < 0)
+		goto out_dev;
+
+	orig_flags = flags;
+	rtnl_lock();
+	ret = ethnl_before_ops(dev);
+	if (ret < 0)
+		goto out_rtnl;
+	ret = dev->ethtool_ops->reset(dev, &flags);
+	ethnl_after_ops(dev);
+	if (ret < 0)
+		goto out_rtnl;
+
+	flags = orig_flags & ~flags;
+	if (flags)
+		ethnl_reset_notify(dev, NULL, ETHTOOL_MSG_RESET_NTF, 0, &flags);
+	if (!(req_info.global_flags & ETHTOOL_RF_REPLY))
+		goto out_rtnl;
+
+	/* compose reply message */
+	reply_len = reset_size(flags, orig_flags, compact);
+	reply_ret = -EFAULT;
+	if (reply_len < 0)
+		goto out;
+	reply_ret = -ENOMEM;
+	rskb = ethnl_reply_init(reply_len, dev, ETHTOOL_MSG_RESET_ACT_REPLY,
+				ETHTOOL_A_RESET_HEADER, info, &reply_payload);
+	if (!rskb)
+		goto err_rskb;
+	reply_ret = reset_fill(rskb, flags, orig_flags, compact);
+	if (reply_ret < 0)
+		goto err_rskb;
+	rtnl_unlock();
+	dev_put(dev);
+	genlmsg_end(rskb, reply_payload);
+	reply_ret = genlmsg_reply(rskb, info);
+	goto out;
+
+err_rskb:
+	WARN_ONCE(ret == -EMSGSIZE,
+		  "calculated message payload length (%d) not sufficient\n",
+		  reply_len);
+	if (rskb)
+		nlmsg_free(rskb);
+out_rtnl:
+	rtnl_unlock();
+out_dev:
+	dev_put(dev);
+out:
+	if (reply_ret < 0)
+		GENL_SET_ERR_MSG(info, "failed to send reply message");
+	return ret;
+}
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 4c4682ef5e08..aa96aae96e34 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -1190,6 +1190,7 @@ static int ethtool_get_regs(struct net_device *dev, char __user *useraddr)
 static int ethtool_reset(struct net_device *dev, char __user *useraddr)
 {
 	struct ethtool_value reset;
+	u32 reset_flags;
 	int ret;
 
 	if (!dev->ethtool_ops->reset)
@@ -1198,9 +1199,14 @@ static int ethtool_reset(struct net_device *dev, char __user *useraddr)
 	if (copy_from_user(&reset, useraddr, sizeof(reset)))
 		return -EFAULT;
 
+	reset_flags = reset.data;
 	ret = dev->ethtool_ops->reset(dev, &reset.data);
 	if (ret)
 		return ret;
+	reset_flags &= ~reset.data;
+	if (reset_flags)
+		ethtool_notify(dev, NULL, ETHTOOL_MSG_RESET_NTF, 0,
+			       &reset_flags);
 
 	if (copy_to_user(useraddr, &reset, sizeof(reset)))
 		return -EFAULT;
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index 220ba1f581a8..c9decca333a2 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -671,6 +671,7 @@ static const ethnl_notify_handler_t ethnl_notify_handlers[] = {
 	[ETHTOOL_MSG_PARAMS_NTF]	= ethnl_std_notify,
 	[ETHTOOL_MSG_NWAYRST_NTF]	= ethnl_nwayrst_notify,
 	[ETHTOOL_MSG_PHYSID_NTF]	= ethnl_physid_notify,
+	[ETHTOOL_MSG_RESET_NTF]		= ethnl_reset_notify,
 };
 
 void ethtool_notify(struct net_device *dev, struct netlink_ext_ack *extack,
@@ -764,6 +765,11 @@ static const struct genl_ops ethtool_genl_ops[] = {
 		.flags	= GENL_UNS_ADMIN_PERM,
 		.doit	= ethnl_act_phys_id,
 	},
+	{
+		.cmd	= ETHTOOL_MSG_RESET_ACT,
+		.flags	= GENL_ADMIN_PERM,
+		.doit	= ethnl_act_reset,
+	},
 };
 
 static const struct genl_multicast_group ethtool_nl_mcgrps[] = {
diff --git a/net/ethtool/netlink.h b/net/ethtool/netlink.h
index 44c592e84e95..9fdd30eeb1b1 100644
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@ -20,6 +20,7 @@ extern const char *const tstamp_tx_type_labels[];
 extern const char *const tstamp_rx_filter_labels[];
 
 extern const char *const link_mode_names[];
+extern const char *const reset_flag_names[];
 
 int ethnl_parse_header(struct ethnl_req_info *req_info,
 		       const struct nlattr *nest, struct net *net,
@@ -314,6 +315,7 @@ int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info);
 int ethnl_set_params(struct sk_buff *skb, struct genl_info *info);
 int ethnl_act_nway_rst(struct sk_buff *skb, struct genl_info *info);
 int ethnl_act_phys_id(struct sk_buff *skb, struct genl_info *info);
+int ethnl_act_reset(struct sk_buff *skb, struct genl_info *info);
 
 /* notify handlers */
 
@@ -322,5 +324,7 @@ void ethnl_nwayrst_notify(struct net_device *dev,
 			  u32 req_mask, const void *data);
 void ethnl_physid_notify(struct net_device *dev, struct netlink_ext_ack *extack,
 			 unsigned int cmd, u32 req_mask, const void *data);
+void ethnl_reset_notify(struct net_device *dev, struct netlink_ext_ack *extack,
+			unsigned int cmd, u32 req_mask, const void *data);
 
 #endif /* _NET_ETHTOOL_NETLINK_H */
diff --git a/net/ethtool/strset.c b/net/ethtool/strset.c
index b8b823646317..785354e03e15 100644
--- a/net/ethtool/strset.c
+++ b/net/ethtool/strset.c
@@ -91,6 +91,12 @@ static const struct strset_info info_template[] = {
 		.count		= __HWTSTAMP_FILTER_COUNT,
 		.data		= { .simple = tstamp_rx_filter_labels },
 	},
+	[ETH_SS_RESET_FLAGS] = {
+		.type		= ETH_SS_TYPE_SIMPLE,
+		.per_dev	= false,
+		.count		= ETH_RESET_NFLAGS,
+		.data		= { .simple = reset_flag_names },
+	},
 };
 
 struct strset_data {
-- 
2.22.0

