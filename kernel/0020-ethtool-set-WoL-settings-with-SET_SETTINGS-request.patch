From a9d18e7e0104783b07538d0484516854d7fe3057 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 8 Mar 2019 17:50:30 +0100
Subject: [PATCH 20/44] ethtool: set WoL settings with SET_SETTINGS request

Allow enabling and disabling wake on LAN modes using SET_SETTINGS
request.

ETHTOOL_A_SETTINGS_WOL nested attribute is used to set or modify enabled WoL
modes and SecureOn(tm) password.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt | 12 +++-
 net/ethtool/settings.c                       | 60 +++++++++++++++++++-
 2 files changed, 70 insertions(+), 2 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index 5f5556f5dc29..b9643ddbab5a 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -331,6 +331,9 @@ to be passed with SET_SETTINGS request:
         ETHTOOL_A_LINKMODES_OURS	    (bitset)	    advertised link modes
         ETHTOOL_A_LINKMODES_SPEED	    (u32)	    link speed (Mb/s)
         ETHTOOL_A_LINKMODES_DUPLEX	    (u8)	    duplex mode
+    ETHTOOL_A_SETTINGS_WOL		(nested)	wake on LAN settings
+        ETHTOOL_A_WOL_MODES		    (bitfield32)    wake on LAN modes
+        ETHTOOL_A_WOL_SOPASS		    (binary)	    SecureOn password
 
 ETHTOOL_A_LINKMODES_OURS bit set allows setting advertised link modes. If
 autonegotiation is on (either set now or kept from before), advertised modes
@@ -341,6 +344,13 @@ autoselection is done on ethtool side with ioctl interface, netlink interface
 is supposed to allow requesting changes without knowing what exactly kernel
 supports.
 
+ETHTOOL_A_WOL_MODES bitfield is interpreted in the usual way, i.e. bits set in
+the selector are set to 0 or 1 according to value. To allow the semantics of
+the ioctl interface where the whole bitmap is set rather than only modified,
+selectors may have also bits not supported by device set and an error is only
+issued if any of them is also set in the value (i.e. if userspace tries to
+enable mode not supported by device).
+
 
 Request translation
 -------------------
@@ -356,7 +366,7 @@ ETHTOOL_SSET			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GDRVINFO		ETHNL_CMD_GET_INFO
 ETHTOOL_GREGS			n/a
 ETHTOOL_GWOL			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SWOL			n/a
+ETHTOOL_SWOL			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GMSGLVL			n/a
 ETHTOOL_SMSGLVL			n/a
 ETHTOOL_NWAY_RST		n/a
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 538e0bf4f21e..0de1d23d9a9d 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -110,6 +110,12 @@ static const struct link_mode_info link_mode_params[] = {
 	__DEFINE_LINK_MODE_PARAMS(1000, T1, Full),
 };
 
+/* We want to allow ~0 as selector for backward compatibility (to just set
+ * given set of modes, whatever kernel supports) so that we allow all bits
+ * on validation and do our own sanity check later.
+ */
+static u32 all_bits = ~(u32)0;
+
 static const struct nla_policy settings_get_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_UNSPEC]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_DEV]	= { .type = NLA_NESTED },
@@ -498,6 +504,14 @@ static const struct nla_policy linkmodes_set_policy[ETHTOOL_A_LINKMODES_MAX + 1]
 	[ETHTOOL_A_LINKMODES_DUPLEX]		= { .type = NLA_U8 },
 };
 
+static const struct nla_policy wol_set_policy[ETHTOOL_A_LINKINFO_MAX + 1] = {
+	[ETHTOOL_A_WOL_UNSPEC]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_WOL_MODES]		= { .type = NLA_BITFIELD32,
+					    .validation_data = &all_bits },
+	[ETHTOOL_A_WOL_SOPASS]		= { .type = NLA_BINARY,
+					    .len = SOPASS_MAX },
+};
+
 static const struct nla_policy settings_set_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_UNSPEC]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_DEV]		= { .type = NLA_NESTED },
@@ -506,7 +520,7 @@ static const struct nla_policy settings_set_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_INFO]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_LINK_MODES]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_LINK_STATE]		= { .type = NLA_REJECT },
-	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_NESTED },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
@@ -662,6 +676,42 @@ static int ethnl_update_ksettings(struct genl_info *info, struct nlattr **tb,
 	return 0;
 }
 
+static int settings_update_wol(struct genl_info *info, struct nlattr *nest,
+			       struct net_device *dev)
+{
+	struct nlattr *tb[ETHTOOL_A_WOL_MAX + 1];
+	struct ethtool_wolinfo wolinfo = {};
+	int ret;
+
+	if (!nest)
+		return 0;
+	ret = nla_parse_nested(tb, ETHTOOL_A_WOL_MAX, nest, wol_set_policy,
+			       info->extack);
+	if (ret < 0)
+		return ret;
+
+	ret = ethnl_get_wol(info, dev, &wolinfo);
+	if (ret < 0)
+		return ret;
+
+	ret = 0;
+	if (ethnl_update_bitfield32(&wolinfo.wolopts, tb[ETHTOOL_A_WOL_MODES]))
+		ret = 1;
+	if (ethnl_update_binary(wolinfo.sopass, SOPASS_MAX,
+				tb[ETHTOOL_A_WOL_SOPASS]))
+		ret = 1;
+	if (ret) {
+		int ret2 = dev->ethtool_ops->set_wol(dev, &wolinfo);
+
+		if (ret2 < 0) {
+			GENL_SET_ERR_MSG(info, "wol info update failed");
+			return ret2;
+		}
+	}
+
+	return ret;
+}
+
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *tb[ETHTOOL_A_SETTINGS_MAX + 1];
@@ -691,6 +741,14 @@ int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 		if (ret < 0)
 			goto out_ops;
 	}
+	if (tb[ETHTOOL_A_SETTINGS_WOL]) {
+		ret = settings_update_wol(info, tb[ETHTOOL_A_SETTINGS_WOL],
+					  dev);
+		if (ret < 0)
+			goto out_ops;
+		if (ret)
+			req_mask |= ETHTOOL_IM_SETTINGS_WOL;
+	}
 	ret = 0;
 
 out_ops:
-- 
2.21.0

