From 96963e77bda95cfba994e9541dcd84c71720cc65 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 8 Mar 2019 18:01:46 +0100
Subject: [PATCH 22/44] ethtool: set message level with SET_SETTINGS request

Allow setting device message level using ETHTOOL_A_SETTINGS_DEBUG nested
attribute.

Unlike in ioctl interface "message level" is called "message mask" (as it
is in fact used as a bit mask) and put inside a nested attribute to allow
future extensions.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  8 +++-
 net/ethtool/settings.c                       | 44 +++++++++++++++++++-
 2 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index aa698a6a0157..8925e940d86a 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -341,6 +341,8 @@ to be passed with SET_SETTINGS request:
     ETHTOOL_A_SETTINGS_WOL		(nested)	wake on LAN settings
         ETHTOOL_A_WOL_MODES		    (bitfield32)    wake on LAN modes
         ETHTOOL_A_WOL_SOPASS		    (binary)	    SecureOn password
+    ETHTOOL_A_SETTINGS_DEBUG		(nested)	debugging
+        ETHTOOL_A_DEBUG_MSG_MASK	    (bitfield32)    message mask
 
 ETHTOOL_A_LINKMODES_OURS bit set allows setting advertised link modes. If
 autonegotiation is on (either set now or kept from before), advertised modes
@@ -356,7 +358,9 @@ the selector are set to 0 or 1 according to value. To allow the semantics of
 the ioctl interface where the whole bitmap is set rather than only modified,
 selectors may have also bits not supported by device set and an error is only
 issued if any of them is also set in the value (i.e. if userspace tries to
-enable mode not supported by device).
+enable mode not supported by device). ETHTOOL_A_SETTINGS_MSGLEVEL bitfield
+also allows bits not recognized by kernel in selector as long as the request
+does not attempt to enable them.
 
 
 Request translation
@@ -375,7 +379,7 @@ ETHTOOL_GREGS			n/a
 ETHTOOL_GWOL			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_SWOL			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_GMSGLVL			ETHNL_CMD_GET_SETTINGS
-ETHTOOL_SMSGLVL			n/a
+ETHTOOL_SMSGLVL			ETHNL_CMD_SET_SETTINGS
 ETHTOOL_NWAY_RST		n/a
 ETHTOOL_GLINK			ETHNL_CMD_GET_SETTINGS
 ETHTOOL_GEEPROM			n/a
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 26150e7714f2..ebf6a40e037e 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -540,6 +540,12 @@ static const struct nla_policy set_wol_policy[ETHTOOL_A_LINKINFO_MAX + 1] = {
 					    .len = SOPASS_MAX },
 };
 
+static const struct nla_policy set_debug_policy[ETHTOOL_A_DEBUG_MAX + 1] = {
+	[ETHTOOL_A_DEBUG_UNSPEC]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_DEBUG_MSG_MASK]	= { .type = NLA_BITFIELD32,
+					    .validation_data = &all_bits },
+};
+
 static const struct nla_policy set_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_UNSPEC]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_DEV]		= { .type = NLA_NESTED },
@@ -549,7 +555,7 @@ static const struct nla_policy set_settings_policy[ETHTOOL_A_SETTINGS_MAX + 1] =
 	[ETHTOOL_A_SETTINGS_LINK_MODES]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_LINK_STATE]		= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_NESTED },
-	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_NESTED },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
@@ -737,6 +743,35 @@ static int update_wol(struct genl_info *info, struct nlattr *nest,
 	return ret;
 }
 
+static int update_debug(struct genl_info *info, struct nlattr *nest,
+			struct net_device *dev)
+{
+	struct nlattr *tb[ETHTOOL_A_DEBUG_MAX + 1];
+	u32 msglevel;
+	int ret;
+
+	if (!nest)
+		return 0;
+	ret = nla_parse_nested(tb, ETHTOOL_A_DEBUG_MAX, nest,
+			       set_debug_policy, info->extack);
+	if (ret < 0)
+		return ret;
+
+	if (!dev->ethtool_ops->get_msglevel ||
+	    !dev->ethtool_ops->set_msglevel) {
+		GENL_SET_ERR_MSG(info, "device does not provide msglvl access");
+		return -EOPNOTSUPP;
+	}
+	ret = 0;
+	msglevel = dev->ethtool_ops->get_msglevel(dev);
+	if (ethnl_update_bitfield32(&msglevel, tb[ETHTOOL_A_DEBUG_MSG_MASK])) {
+		dev->ethtool_ops->set_msglevel(dev, msglevel);
+		ret = 1;
+	}
+
+	return ret;
+}
+
 int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 {
 	struct nlattr *tb[ETHTOOL_A_SETTINGS_MAX + 1];
@@ -773,6 +808,13 @@ int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info)
 		if (ret)
 			req_mask |= ETH_SETTINGS_IM_WOL;
 	}
+	if (tb[ETHTOOL_A_SETTINGS_DEBUG]) {
+		ret = update_debug(info, tb[ETHTOOL_A_SETTINGS_DEBUG], dev);
+		if (ret < 0)
+			goto out_ops;
+		if (ret)
+			req_mask |= ETH_SETTINGS_IM_DEBUG;
+	}
 	ret = 0;
 
 out_ops:
-- 
2.21.0

