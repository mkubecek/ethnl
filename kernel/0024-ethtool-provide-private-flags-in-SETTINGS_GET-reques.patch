From 00f48f314a221a4952edda6dce396abf0f6846db Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 16 Feb 2019 16:19:21 +0100
Subject: [PATCH 24/45] ethtool: provide private flags in SETTINGS_GET request

Add information about device private flags (as provided by
ETHTOOL_GPFLAGS ioctl command) in SETTINGS_GET reply when
ETHTOOL_IM_SETTINGS_PRIVFLAGS flag is set in the request.

Send notification in the same format as reply when device private flags
are modified using ioctl interface (ETHTOOL_SPFLAGS command).

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |   9 +-
 include/uapi/linux/ethtool_netlink.h         |   5 +-
 net/ethtool/ioctl.c                          |   3 +
 net/ethtool/settings.c                       | 101 +++++++++++++++++++
 4 files changed, 116 insertions(+), 2 deletions(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index b0c3fd67ce45..856ebf919b2a 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -256,6 +256,7 @@ Info mask bits meaning:
     ETHTOOL_IM_SETTINGS_WOL		struct ethtool_wolinfo
     ETHTOOL_IM_SETTINGS_DEBUG		debugging
     ETHTOOL_IM_SETTINGS_FEATURES	features
+    ETHTOOL_IM_SETTINGS_PRIVFLAGS	device private flags
 
 Response contents:
 
@@ -284,6 +285,7 @@ Response contents:
         ETHTOOL_A_FEATURES_WANTED	    (bitset)	    dev->wanted_features
         ETHTOOL_A_FEATURES_ACTIVE	    (bitset)	    dev->features
         ETHTOOL_A_FEATURES_NOCHANGE	    (bitset)	    NETIF_F_NEVER_CHANGE
+    ETHTOOL_A_SETTINGS_PRIV_FLAGS	(bitset)	device private flags
 
 Most of the attributes and their values have the same meaning as matching
 members of the corresponding ioctl structures. For ETHTOOL_A_LINKMODES_OURS,
@@ -306,6 +308,11 @@ itself. ETHTOOL_A_FEATURES_HW uses mask consisting of all features recognized
 by kernel (to provide all names when using verbose bitmap format), remaining
 three use mask equal to value (to save space).
 
+ETHTOOL_A_SETTINGS_PRIV_FLAGS is a bitset with values of device private flags.
+These flags are defined by driver, their number and names (as well as meaning)
+are device dependent. For compact bitset format, names can be retrieved as
+ETH_SS_PRIV_FLAGS string set.
+
 SETTINGS_GET request is allowed for unprivileged user but ETHTOOL_A_WOL_SOPASS
 is only provided by kernel in response to privileged (netns CAP_NET_ADMIN)
 requests.
@@ -421,7 +428,7 @@ ETHTOOL_GGSO			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SGSO			ETHTOOL_MSG_SETTINGS_SET
 ETHTOOL_GFLAGS			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SFLAGS			ETHTOOL_MSG_SETTINGS_SET
-ETHTOOL_GPFLAGS			n/a
+ETHTOOL_GPFLAGS			ETHTOOL_MSG_SETTINGS_GET
 ETHTOOL_SPFLAGS			n/a
 ETHTOOL_GRXFH			n/a
 ETHTOOL_SRXFH			n/a
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 36a8ed329255..0313a6356a95 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -163,6 +163,7 @@ enum {
 	ETHTOOL_A_SETTINGS_WOL,			/* nest - _A_WOL_* */
 	ETHTOOL_A_SETTINGS_DEBUG,		/* nest - _A_DEBUG_* */
 	ETHTOOL_A_SETTINGS_FEATURES,		/* nest - _A_FEATURES_* */
+	ETHTOOL_A_SETTINGS_PRIV_FLAGS,		/* bitset */
 
 	/* add new constants above here */
 	__ETHTOOL_A_SETTINGS_CNT,
@@ -175,13 +176,15 @@ enum {
 #define ETHTOOL_IM_SETTINGS_WOL			(1U << 3)
 #define ETHTOOL_IM_SETTINGS_DEBUG		(1U << 4)
 #define ETHTOOL_IM_SETTINGS_FEATURES		(1U << 5)
+#define ETHTOOL_IM_SETTINGS_PRIVFLAGS		(1U << 6)
 
 #define ETHTOOL_IM_SETTINGS_ALL (ETHTOOL_IM_SETTINGS_LINKINFO | \
 				 ETHTOOL_IM_SETTINGS_LINKMODES | \
 				 ETHTOOL_IM_SETTINGS_LINKSTATE | \
 				 ETHTOOL_IM_SETTINGS_WOL | \
 				 ETHTOOL_IM_SETTINGS_DEBUG | \
-				 ETHTOOL_IM_SETTINGS_FEATURES)
+				 ETHTOOL_IM_SETTINGS_FEATURES | \
+				 ETHTOOL_IM_SETTINGS_PRIVFLAGS)
 
 #define ETHTOOL_RFLAG_SETTINGS_ALL 0
 
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 16482a266eec..5c2e810bc886 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -2603,6 +2603,9 @@ int dev_ethtool(struct net *net, struct ifreq *ifr)
 	case ETHTOOL_SPFLAGS:
 		rc = ethtool_set_value(dev, useraddr,
 				       dev->ethtool_ops->set_priv_flags);
+		if (rc == 0)
+			ethtool_notify(dev, NULL, ETHTOOL_MSG_SETTINGS_NTF,
+				       ETHTOOL_IM_SETTINGS_PRIVFLAGS, NULL);
 		break;
 	case ETHTOOL_GRXFH:
 	case ETHTOOL_GRXRINGS:
diff --git a/net/ethtool/settings.c b/net/ethtool/settings.c
index 4cdc540310b2..71e285cf1dc7 100644
--- a/net/ethtool/settings.c
+++ b/net/ethtool/settings.c
@@ -21,6 +21,9 @@ struct settings_data {
 		u32	active[ETHTOOL_DEV_FEATURE_WORDS];
 		u32	nochange[ETHTOOL_DEV_FEATURE_WORDS];
 	} features;
+	char				(*priv_flag_names)[ETH_GSTRING_LEN];
+	u32				priv_flags;
+	unsigned int			n_priv_flags;
 	bool				lpm_empty;
 };
 
@@ -133,6 +136,7 @@ settings_get_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_WOL]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_DEBUG]	= { .type = NLA_REJECT },
 	[ETHTOOL_A_SETTINGS_FEATURES]	= { .type = NLA_REJECT },
+	[ETHTOOL_A_SETTINGS_PRIV_FLAGS]	= { .type = NLA_REJECT },
 };
 
 static int ethnl_get_link_ksettings(struct genl_info *info,
@@ -181,6 +185,58 @@ static int ethnl_get_features(struct net_device *dev,
 	return 0;
 }
 
+static int ethnl_get_priv_flags_info(struct net_device *dev,
+				     unsigned int *count, void **names)
+{
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	int nflags;
+
+	if (!ops->get_priv_flags || !ops->get_sset_count || !ops->get_strings)
+		return -EOPNOTSUPP;
+	nflags = ops->get_sset_count(dev, ETH_SS_PRIV_FLAGS);
+	if (nflags < 0)
+		return nflags;
+
+	if (names) {
+		*names = kcalloc(nflags, ETH_GSTRING_LEN, GFP_KERNEL);
+		if (!*names)
+			return -ENOMEM;
+		ops->get_strings(dev, ETH_SS_PRIV_FLAGS, *names);
+	}
+
+	/* We can easily pass more than 32 private flags to userspace via
+	 * netlink but we cannot get more with ethtool_ops::get_priv_flags().
+	 * Note that we must not adjust nflags before allocating the space
+	 * for flag names as the buffer must be large enough for all flags.
+	 */
+	if (WARN_ONCE(nflags > 32,
+		      "device %s reports more than 32 private flags (%d)\n",
+		      netdev_name(dev), nflags))
+		nflags = 32;
+
+	*count = nflags;
+	return 0;
+}
+
+static int ethnl_get_priv_flags(struct genl_info *info,
+				struct settings_data *data)
+{
+	struct net_device *dev = data->repdata_base.dev;
+	const struct ethtool_ops *ops = dev->ethtool_ops;
+	unsigned int nflags;
+	void *names;
+	int ret;
+
+	ret = ethnl_get_priv_flags_info(dev, &nflags, &names);
+	if (ret < 0)
+		return ret;
+
+	data->priv_flags = ops->get_priv_flags(dev);
+	data->priv_flag_names = names;
+	data->n_priv_flags = nflags;
+	return 0;
+}
+
 /* prepare_data() handler */
 static int settings_prepare(struct ethnl_req_info *req_info,
 			    struct genl_info *info)
@@ -232,6 +288,11 @@ static int settings_prepare(struct ethnl_req_info *req_info,
 	}
 	if (req_mask & ETHTOOL_IM_SETTINGS_FEATURES)
 		ethnl_get_features(dev, data);
+	if (req_mask & ETHTOOL_IM_SETTINGS_PRIVFLAGS) {
+		ret = ethnl_get_priv_flags(info, data);
+		if (ret < 0)
+			req_mask &= ~ETHTOOL_IM_SETTINGS_PRIVFLAGS;
+	}
 	ethnl_after_ops(dev);
 
 	data->repdata_base.info_mask = req_mask;
@@ -372,6 +433,17 @@ static int settings_size(const struct ethnl_req_info *req_info)
 			return ret;
 		len += ret;
 	}
+	if (info_mask & ETHTOOL_IM_SETTINGS_PRIVFLAGS) {
+		unsigned int flags = compact ? ETHNL_BITSET_COMPACT : 0;
+		u32 all_flags = ~(u32)0 >> (32 - data->n_priv_flags);
+
+		ret = ethnl_bitset32_size(&data->priv_flags, &all_flags,
+					  data->n_priv_flags,
+					  data->priv_flag_names, flags);
+		if (ret < 0)
+			return ret;
+		len += ret;
+	}
 
 	return len;
 }
@@ -551,6 +623,20 @@ static int settings_fill_features(struct sk_buff *skb,
 	return 0;
 }
 
+static int settings_fill_priv_flags(struct sk_buff *skb,
+				    const struct settings_data *data)
+{
+	u32 all_flags = ~(u32)0 >> (32 - data->n_priv_flags);
+	unsigned int bitset_flags = 0;
+
+	if (data->reqinfo_base.global_flags & ETHTOOL_GFLAG_COMPACT_BITSETS)
+		bitset_flags |= ETHNL_BITSET_COMPACT;
+	return ethnl_put_bitset32(skb, ETHTOOL_A_SETTINGS_PRIV_FLAGS,
+				  &data->priv_flags, &all_flags,
+				  data->n_priv_flags, data->priv_flag_names,
+				  bitset_flags);
+}
+
 /* fill_reply() handler */
 static int settings_fill(struct sk_buff *skb,
 			 const struct ethnl_req_info *req_info)
@@ -593,10 +679,23 @@ static int settings_fill(struct sk_buff *skb,
 		if (ret < 0)
 			return ret;
 	}
+	if (info_mask & ETHTOOL_IM_SETTINGS_PRIVFLAGS) {
+		ret = settings_fill_priv_flags(skb, data);
+		if (ret < 0)
+			return ret;
+	}
 
 	return 0;
 }
 
+static void settings_cleanup(struct ethnl_req_info *req_info)
+{
+	const struct settings_data *data =
+		container_of(req_info, struct settings_data, reqinfo_base);
+
+	kfree(data->priv_flag_names);
+}
+
 const struct get_request_ops settings_request_ops = {
 	.request_cmd		= ETHTOOL_MSG_SETTINGS_GET,
 	.reply_cmd		= ETHTOOL_MSG_SETTINGS_GET_REPLY,
@@ -611,6 +710,7 @@ const struct get_request_ops settings_request_ops = {
 	.prepare_data		= settings_prepare,
 	.reply_size		= settings_size,
 	.fill_reply		= settings_fill,
+	.cleanup		= settings_cleanup,
 };
 
 /* SET_SETTINGS */
@@ -678,6 +778,7 @@ settings_set_policy[ETHTOOL_A_SETTINGS_MAX + 1] = {
 	[ETHTOOL_A_SETTINGS_WOL]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_DEBUG]		= { .type = NLA_NESTED },
 	[ETHTOOL_A_SETTINGS_FEATURES]		= { .type = NLA_NESTED },
+	[ETHTOOL_A_SETTINGS_PRIV_FLAGS]		= { .type = NLA_REJECT },
 };
 
 static int ethnl_set_link_ksettings(struct genl_info *info,
-- 
2.22.0

