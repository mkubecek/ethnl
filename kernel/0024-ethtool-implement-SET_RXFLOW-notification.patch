From 0ac4b2658a2a0c2de196ac1b3cd15ccd78d758c3 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 15 Sep 2018 22:05:29 +0200
Subject: [PATCH 24/25] ethtool: implement SET_RXFLOW notification

SET_RXFLOW notification message uses the same format as response to
GET_RXFLOW request except for ETHA_RXFLOW_CTXOP attribute which may be
set to

  - ETH_RXFLOW_CTXOP_NEW when new context is allocated;
    ETHA_RXFLOW_CONTEXT then contains id of the newly allocated context
  - ETH_RXFLOW_CTXOP_DEL when a context is deleted; ETHA_RXFLOW_CONTEXT
    then contains id of the deleted context and other attributes (except
    ETHA_RXFLOW_DEV) are omitted

The notification is also sent if related data is modified using the ioctl
interface (ETHTOOL_SRSSH, ETHTOOL_SRXFH or ETHTOOL_SRXFHINDIR command).

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/linux/ethtool_netlink.h |  6 +++
 net/ethtool/ioctl.c             | 32 ++++++++++++++-
 net/ethtool/netlink.c           |  1 +
 net/ethtool/netlink.h           |  2 +
 net/ethtool/rxflow.c            | 71 +++++++++++++++++++++++++++++++++
 5 files changed, 111 insertions(+), 1 deletion(-)

diff --git a/include/linux/ethtool_netlink.h b/include/linux/ethtool_netlink.h
index e770e6e9acca..288e90f4dbb9 100644
--- a/include/linux/ethtool_netlink.h
+++ b/include/linux/ethtool_netlink.h
@@ -14,4 +14,10 @@ enum ethtool_multicast_groups {
 	ETHNL_MCGRP_MONITOR,
 };
 
+struct ethtool_rxflow_notification_info {
+	u32	ctx_op;
+	u32	context;
+	u32	flow_type;
+};
+
 #endif /* _LINUX_ETHTOOL_NETLINK_H_ */
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 1eab710df872..0eb0f6cdc20b 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -714,6 +714,7 @@ static noinline_for_stack int ethtool_get_sset_info(struct net_device *dev,
 static noinline_for_stack int ethtool_set_rxnfc(struct net_device *dev,
 						u32 cmd, void __user *useraddr)
 {
+	struct ethtool_rxflow_notification_info notify_info = {};
 	struct ethtool_rxnfc info;
 	size_t info_size = sizeof(info);
 	int rc;
@@ -732,10 +733,16 @@ static noinline_for_stack int ethtool_set_rxnfc(struct net_device *dev,
 	if (copy_from_user(&info, useraddr, info_size))
 		return -EFAULT;
 
+	if ((cmd != ETHTOOL_SRXFH) && (info.flow_type & FLOW_RSS))
+		notify_info.context = info.rss_context;
+	notify_info.flow_type = info.flow_type;
 	rc = dev->ethtool_ops->set_rxnfc(dev, &info);
 	if (rc)
 		return rc;
 
+	if (cmd == ETHTOOL_SRXFH)
+		ethtool_notify(dev, NULL, ETHNL_CMD_SET_RXFLOW,
+			       ETH_RXFLOW_IM_HASHOPTS, &notify_info);
 	if (cmd == ETHTOOL_SRXCLSRLINS &&
 	    copy_to_user(useraddr, &info, info_size))
 		return -EFAULT;
@@ -940,6 +947,8 @@ static noinline_for_stack int ethtool_set_rxfh_indir(struct net_device *dev,
 	ret = ops->set_rxfh(dev, indir, NULL, ETH_RSS_HASH_NO_CHANGE);
 	if (ret)
 		goto out;
+	ethtool_notify(dev, NULL, ETHNL_CMD_SET_RXFLOW, ETH_RXFLOW_IM_INDTBL,
+		       NULL);
 
 	/* indicate whether rxfh was set to default */
 	if (user_size == 0)
@@ -1035,6 +1044,9 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 					       void __user *useraddr)
 {
 	int ret;
+	struct ethtool_rxflow_notification_info notify_info = {
+		.ctx_op		= ETH_RXFLOW_CTXOP_SET,
+	};
 	const struct ethtool_ops *ops = dev->ethtool_ops;
 	struct ethtool_rxnfc rx_rings;
 	struct ethtool_rxfh rxfh;
@@ -1044,6 +1056,7 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 	u8 *rss_config;
 	u32 rss_cfg_offset = offsetof(struct ethtool_rxfh, rss_config[0]);
 	bool delete = false;
+	u32 notify_mask = 0;
 
 	if (!ops->get_rxnfc || !ops->set_rxfh)
 		return -EOPNOTSUPP;
@@ -1074,8 +1087,18 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 	     rxfh.key_size == 0 && rxfh.hfunc == ETH_RSS_HASH_NO_CHANGE))
 		return -EINVAL;
 
-	if (rxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE)
+	if (rxfh.hfunc != ETH_RSS_HASH_NO_CHANGE)
+		notify_mask |= ETH_RXFLOW_IM_HASHFN;
+	if (rxfh.key_size)
+		notify_mask |= ETH_RXFLOW_IM_HKEY;
+	if (rxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE) {
 		indir_bytes = dev_indir_size * sizeof(indir[0]);
+		notify_mask |= ETH_RXFLOW_IM_INDTBL;
+	}
+	if (rxfh.rss_context == ETH_RXFH_CONTEXT_ALLOC)
+		notify_info.ctx_op = ETH_RXFLOW_CTXOP_NEW;
+	else
+		notify_info.context = rxfh.rss_context;
 
 	rss_config = kzalloc(indir_bytes + rxfh.key_size, GFP_USER);
 	if (!rss_config)
@@ -1105,6 +1128,7 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 			for (i = 0; i < dev_indir_size; i++)
 				indir[i] = ethtool_rxfh_indir_default(i, rx_rings.data);
 		} else {
+			notify_info.ctx_op = ETH_RXFLOW_CTXOP_DEL;
 			delete = true;
 		}
 	}
@@ -1126,6 +1150,12 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 		ret = ops->set_rxfh(dev, indir, hkey, rxfh.hfunc);
 	if (ret)
 		goto out;
+	if (notify_mask) {
+		if (notify_info.ctx_op == ETH_RXFLOW_CTXOP_NEW)
+			notify_info.context = rxfh.rss_context;
+		ethtool_notify(dev, NULL, ETHNL_CMD_SET_RXFLOW, notify_mask,
+			       &notify_info);
+	}
 
 	if (copy_to_user(useraddr + offsetof(struct ethtool_rxfh, rss_context),
 			 &rxfh.rss_context, sizeof(rxfh.rss_context)))
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index 89073a2fcdf5..45c6c47446c8 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -483,6 +483,7 @@ ethnl_notify_handler_t ethnl_notify_handlers[] = {
 	[ETHNL_CMD_ACT_NWAY_RST]	= ethnl_nwayrst_notify,
 	[ETHNL_CMD_ACT_PHYS_ID]		= ethnl_physid_notify,
 	[ETHNL_CMD_ACT_RESET]		= ethnl_reset_notify,
+	[ETHNL_CMD_SET_RXFLOW]		= ethnl_rxflow_notify,
 };
 
 void ethtool_notify(struct net_device *dev, struct netlink_ext_ack *extack,
diff --git a/net/ethtool/netlink.h b/net/ethtool/netlink.h
index 998f89c54366..6eeedb305f5f 100644
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@ -277,5 +277,7 @@ void ethnl_physid_notify(struct net_device *dev, struct netlink_ext_ack *extack,
 			 unsigned int cmd, u32 req_mask, const void *data);
 void ethnl_reset_notify(struct net_device *dev, struct netlink_ext_ack *extack,
 			unsigned int cmd, u32 req_mask, const void *data);
+void ethnl_rxflow_notify(struct net_device *dev, struct netlink_ext_ack *extack,
+			 unsigned int cmd, u32 req_mask, const void *data);
 
 #endif /* _NET_ETHTOOL_NETLINK_H */
diff --git a/net/ethtool/rxflow.c b/net/ethtool/rxflow.c
index 49e229658602..c060619d9808 100644
--- a/net/ethtool/rxflow.c
+++ b/net/ethtool/rxflow.c
@@ -461,3 +461,74 @@ const struct get_request_ops rxflow_request_ops = {
 	.fill_reply		= fill_rxflow,
 	.cleanup		= rxflow_cleanup,
 };
+
+void ethnl_rxflow_notify(struct net_device *dev,
+			 struct netlink_ext_ack *extack, unsigned int cmd,
+			 u32 req_mask, const void *_data)
+{
+	const struct ethtool_rxflow_notification_info *ninfo = _data;
+	struct common_req_info *req_info;
+	struct rxflow_data data = {};
+	struct sk_buff *skb;
+	void *msg_payload;
+	int msg_len;
+	int ret;
+
+	req_info = &data.reqinfo_base;
+	req_info->reply_data = &data.repdata_base;
+	req_info->dev = dev;
+	req_info->req_mask = req_mask;
+	req_info->compact = true;
+	req_info->have_rtnl = true;
+	data.repdata_base.dev = dev;
+	if (ninfo) {
+		data.req_context = ninfo->context;
+		data.req_flow_type = ninfo->flow_type;
+	}
+
+	ret = prepare_rxflow(req_info, NULL);
+	if (ret < 0)
+		goto err_data;
+	msg_len = rxflow_size(req_info);
+	if (msg_len < 0)
+		goto err_data;
+	skb = genlmsg_new(msg_len, GFP_KERNEL);
+	if (!skb)
+		goto err_data;
+	msg_payload = genlmsg_put(skb, 0, ++ethnl_bcast_seq,
+				  &ethtool_genl_family, 0,
+				  ETHNL_CMD_SET_RXFLOW);
+	if (!msg_payload)
+		goto err_skb;
+
+	ret = ethnl_fill_dev(skb, dev, ETHA_RXFLOW_DEV);
+	if (ret < 0)
+		goto err_skb;
+	if (ninfo) {
+		ret = -EMSGSIZE;
+		if (ninfo->ctx_op &&
+		    nla_put_u32(skb, ETHA_RXFLOW_CTXOP, ninfo->ctx_op))
+			goto err_skb;
+	}
+
+	if (ninfo && ninfo->ctx_op == ETH_RXFLOW_CTXOP_DEL) {
+		ret = -EMSGSIZE;
+		if (nla_put_u32(skb, ETHA_RXFLOW_CONTEXT, ninfo->context))
+			goto err_skb;
+	} else {
+		ret = fill_rxflow(skb, req_info);
+		if (ret < 0)
+			goto err_skb;
+	}
+	rxflow_cleanup(req_info);
+	genlmsg_end(skb, msg_payload);
+
+	genlmsg_multicast(&ethtool_genl_family, skb, 0, ETHNL_MCGRP_MONITOR,
+			  GFP_KERNEL);
+	return;
+
+err_skb:
+	nlmsg_free(skb);
+err_data:
+	rxflow_cleanup(req_info);
+}
-- 
2.20.1

