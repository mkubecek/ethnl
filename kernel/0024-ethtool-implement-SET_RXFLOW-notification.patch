From 98f18c6f93bd7fc5178eacfa94752a7d12684fea Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 15 Sep 2018 22:05:29 +0200
Subject: [PATCH 24/25] ethtool: implement SET_RXFLOW notification

SET_RXFLOW notification message uses the same format as response to
GET_RXFLOW request except for ETHA_RXFLOW_CTXOP attribute which may be
set to

  - ETH_RXFLOW_CTXOP_NEW when new context is allocated;
    ETHA_RXFLOW_CONTEXT then contains id of the newly allocated context
  - ETH_RXFLOW_CTXOP_DEL when a context is deleted; ETHA_RXFLOW_CONTEXT
    then contains id of the deleted context and other attributes (except
    ETHA_RXFLOW_DEV) are omitted

The notification is also sent if related data is modified using the ioctl
interface (ETHTOOL_SRSSH or ETHTOOL_SRXFHINDIR command).

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/linux/ethtool_netlink.h |  5 +++
 net/ethtool/ioctl.c             | 25 ++++++++++++++-
 net/ethtool/netlink.c           |  1 +
 net/ethtool/netlink.h           |  2 ++
 net/ethtool/rxflow.c            | 68 +++++++++++++++++++++++++++++++++++++++++
 5 files changed, 100 insertions(+), 1 deletion(-)

diff --git a/include/linux/ethtool_netlink.h b/include/linux/ethtool_netlink.h
index fba8ff961887..5d4205750723 100644
--- a/include/linux/ethtool_netlink.h
+++ b/include/linux/ethtool_netlink.h
@@ -14,4 +14,9 @@ enum ethtool_multicast_groups {
 	ETHNL_MCGRP_MONITOR,
 };
 
+struct ethtool_rxflow_notification_info {
+	u32	ctx_op;
+	u32	context;
+};
+
 #endif /* _LINUX_ETHTOOL_NETLINK_H_ */
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index 54f8da415e48..31456984ecca 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -967,6 +967,8 @@ static noinline_for_stack int ethtool_set_rxfh_indir(struct net_device *dev,
 	ret = ops->set_rxfh(dev, indir, NULL, ETH_RSS_HASH_NO_CHANGE);
 	if (ret)
 		goto out;
+	ethtool_notify(dev, NULL, ETHNL_CMD_SET_RXFLOW, ETH_RXFLOW_IM_INDTBL,
+		       NULL);
 
 	/* indicate whether rxfh was set to default */
 	if (user_size == 0)
@@ -1062,6 +1064,9 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 					       void __user *useraddr)
 {
 	int ret;
+	struct ethtool_rxflow_notification_info notify_info = {
+		.ctx_op		= ETH_RXFLOW_CTXOP_SET,
+	};
 	const struct ethtool_ops *ops = dev->ethtool_ops;
 	struct ethtool_rxnfc rx_rings;
 	struct ethtool_rxfh rxfh;
@@ -1071,6 +1076,7 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 	u8 *rss_config;
 	u32 rss_cfg_offset = offsetof(struct ethtool_rxfh, rss_config[0]);
 	bool delete = false;
+	u32 notify_mask = 0;
 
 	if (!ops->get_rxnfc || !ops->set_rxfh)
 		return -EOPNOTSUPP;
@@ -1101,8 +1107,18 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 	     rxfh.key_size == 0 && rxfh.hfunc == ETH_RSS_HASH_NO_CHANGE))
 		return -EINVAL;
 
-	if (rxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE)
+	if (rxfh.hfunc != ETH_RSS_HASH_NO_CHANGE)
+		notify_mask |= ETH_RXFLOW_IM_HASHFN;
+	if (rxfh.key_size)
+		notify_mask |= ETH_RXFLOW_IM_HKEY;
+	if (rxfh.indir_size != ETH_RXFH_INDIR_NO_CHANGE) {
 		indir_bytes = dev_indir_size * sizeof(indir[0]);
+		notify_mask |= ETH_RXFLOW_IM_INDTBL;
+	}
+	if (rxfh.rss_context == ETH_RXFH_CONTEXT_ALLOC)
+		notify_info.ctx_op = ETH_RXFLOW_CTXOP_NEW;
+	else
+		notify_info.context = rxfh.rss_context;
 
 	rss_config = kzalloc(indir_bytes + rxfh.key_size, GFP_USER);
 	if (!rss_config)
@@ -1132,6 +1148,7 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 			for (i = 0; i < dev_indir_size; i++)
 				indir[i] = ethtool_rxfh_indir_default(i, rx_rings.data);
 		} else {
+			notify_info.ctx_op = ETH_RXFLOW_CTXOP_DEL;
 			delete = true;
 		}
 	}
@@ -1153,6 +1170,12 @@ static noinline_for_stack int ethtool_set_rxfh(struct net_device *dev,
 		ret = ops->set_rxfh(dev, indir, hkey, rxfh.hfunc);
 	if (ret)
 		goto out;
+	if (notify_mask) {
+		if (notify_info.ctx_op == ETH_RXFLOW_CTXOP_NEW)
+			notify_info.context = rxfh.rss_context;
+		ethtool_notify(dev, NULL, ETHNL_CMD_SET_RXFLOW, notify_mask,
+			       &notify_info);
+	}
 
 	if (copy_to_user(useraddr + offsetof(struct ethtool_rxfh, rss_context),
 			 &rxfh.rss_context, sizeof(rxfh.rss_context)))
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index 6f0f9da605e7..3b5983555af4 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -921,6 +921,7 @@ ethnl_notify_handler_t ethnl_notify_handlers[] = {
 	[ETHNL_CMD_ACT_NWAY_RST]	= ethnl_nwayrst_notify,
 	[ETHNL_CMD_ACT_PHYS_ID]		= ethnl_physid_notify,
 	[ETHNL_CMD_ACT_RESET]		= ethnl_reset_notify,
+	[ETHNL_CMD_SET_RXFLOW]		= ethnl_rxflow_notify,
 };
 
 void ethtool_notify(struct net_device *dev, struct netlink_ext_ack *extack,
diff --git a/net/ethtool/netlink.h b/net/ethtool/netlink.h
index ee1f8498353b..21fec8e03207 100644
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@ -298,5 +298,7 @@ void ethnl_physid_notify(struct net_device *dev, struct netlink_ext_ack *extack,
 			 unsigned int cmd, u32 req_mask, const void *data);
 void ethnl_reset_notify(struct net_device *dev, struct netlink_ext_ack *extack,
 			unsigned int cmd, u32 req_mask, const void *data);
+void ethnl_rxflow_notify(struct net_device *dev, struct netlink_ext_ack *extack,
+			 unsigned int cmd, u32 req_mask, const void *data);
 
 #endif /* _NET_ETHTOOL_NETLINK_H */
diff --git a/net/ethtool/rxflow.c b/net/ethtool/rxflow.c
index d49d342ab7a3..8a426a532ba1 100644
--- a/net/ethtool/rxflow.c
+++ b/net/ethtool/rxflow.c
@@ -1,5 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 
+#include <linux/ethtool_netlink.h>
 #include "netlink.h"
 #include "common.h"
 
@@ -326,3 +327,70 @@ const struct get_request_ops rxflow_request_ops = {
 	.fill_reply		= fill_rxflow,
 	.cleanup		= rxflow_cleanup,
 };
+
+void ethnl_rxflow_notify(struct net_device *dev,
+			 struct netlink_ext_ack *extack, unsigned int cmd,
+			 u32 req_mask, const void *_data)
+{
+	const struct ethtool_rxflow_notification_info *ninfo = _data;
+	struct common_req_info *req_info;
+	struct rxflow_data data = {};
+	struct sk_buff *skb;
+	void *msg_payload;
+	int msg_len;
+	int ret;
+
+	req_info = &data.reqinfo_base;
+	req_info->reply_data = &data.repdata_base;
+	req_info->dev = dev;
+	req_info->req_mask = req_mask;
+	req_info->compact = true;
+	req_info->have_rtnl = true;
+	data.repdata_base.dev = dev;
+
+	ret = prepare_rxflow(req_info, NULL);
+	if (ret < 0)
+		goto err_data;
+	msg_len = rxflow_size(req_info);
+	if (msg_len < 0)
+		goto err_data;
+	skb = genlmsg_new(msg_len, GFP_KERNEL);
+	if (!skb)
+		goto err_data;
+	msg_payload = genlmsg_put(skb, 0, ++ethnl_bcast_seq,
+				  &ethtool_genl_family, 0,
+				  ETHNL_CMD_SET_RXFLOW);
+	if (!msg_payload)
+		goto err_skb;
+
+	ret = ethnl_fill_dev(skb, dev, ETHA_RXFLOW_DEV);
+	if (ret < 0)
+		goto err_skb;
+	if (ninfo) {
+		ret = -EMSGSIZE;
+		if (nla_put_u32(skb, ETHA_RXFLOW_CTXOP, ninfo->ctx_op))
+			goto err_skb;
+		data.req_context = ninfo->context;
+	}
+
+	if (ninfo && ninfo->ctx_op == ETH_RXFLOW_CTXOP_DEL) {
+		ret = -EMSGSIZE;
+		if (nla_put_u32(skb, ETHA_RXFLOW_CONTEXT, ninfo->context))
+			goto err_skb;
+	} else {
+		ret = fill_rxflow(skb, req_info);
+		if (ret < 0)
+			goto err_skb;
+	}
+	rxflow_cleanup(req_info);
+	genlmsg_end(skb, msg_payload);
+
+	genlmsg_multicast(&ethtool_genl_family, skb, 0, ETHNL_MCGRP_MONITOR,
+			  GFP_KERNEL);
+	return;
+
+err_skb:
+	nlmsg_free(skb);
+err_data:
+	rxflow_cleanup(req_info);
+}
-- 
2.16.4

