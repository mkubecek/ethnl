From 65bf0530f1388a8b83867ac113ecfcd0e60269f3 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Tue, 4 Sep 2018 07:36:33 +0200
Subject: [PATCH 31/34] ethtool: implement ACT_RESET message

Request reset of a NIC or its part(s), equivalent of ETHTOOL_RESET.

If successful and at least one component was reset, send a notification.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Documentation/networking/ethtool-netlink.txt |  25 +-
 include/uapi/linux/ethtool.h                 |   3 +
 include/uapi/linux/ethtool_netlink.h         |  16 ++
 net/ethtool/actions.c                        | 236 +++++++++++++++++++
 net/ethtool/ioctl.c                          |   5 +
 net/ethtool/netlink.c                        |   6 +
 net/ethtool/netlink.h                        |   4 +
 net/ethtool/strset.c                         |   6 +
 8 files changed, 300 insertions(+), 1 deletion(-)

diff --git a/Documentation/networking/ethtool-netlink.txt b/Documentation/networking/ethtool-netlink.txt
index 5544f83fcd80..7a6cb997b39f 100644
--- a/Documentation/networking/ethtool-netlink.txt
+++ b/Documentation/networking/ethtool-netlink.txt
@@ -580,6 +580,29 @@ other ACT_PHYS_ID requests for any device fail with EBUSY. The same holds for
 requests using ETHTOOL_PHYS_ID ioctl command.
 
 
+ACT_RESET
+---------
+
+Reset whole device or selected components (equivalent of ETHTOOL_RESET).
+
+Request contents:
+
+    ETHA_RESET_DEV		(nested)	device identification
+    ETHA_RESET_COMPACT		(flag)		request compact bitmaps
+    ETHA_RESET_ALL		(flag)		reset all compontents
+    ETHA_RESET_ALL_DEDICATED	(flag)		reset all dedicated components
+    ETHA_RESET_DEDICATED	(bitset)	dedicated components to reset
+    ETHA_RESET_SHARED		(bitset)	shared components to reset
+
+Masks for both bitsets are ignored. When ETHA_RESET_ALL_DEDICATED flag is
+present, it overrides ETHA_RESET_DEDICATED. When ETHA_RESET_ALL flag is
+present, it overrides both ETHA_RESET_DEDICATED and ETHA_RESET_SHARED.
+
+If the request is successful, a message in the same format is returned,
+indicating which components _were_ actually reset (this is different from
+ioctl interface). The same message is also broadcasted as a notification.
+
+
 Request translation
 -------------------
 
@@ -639,7 +662,7 @@ ETHTOOL_GRXCLSRLALL		n/a
 ETHTOOL_SRXCLSRLDEL		n/a
 ETHTOOL_SRXCLSRLINS		n/a
 ETHTOOL_FLASHDEV		n/a
-ETHTOOL_RESET			n/a
+ETHTOOL_RESET			ETHNL_CMD_ACT_RESET
 ETHTOOL_SRXNTUPLE		n/a
 ETHTOOL_GRXNTUPLE		n/a
 ETHTOOL_GSSET_INFO		ETHNL_CMD_GET_STRSET
diff --git a/include/uapi/linux/ethtool.h b/include/uapi/linux/ethtool.h
index ef1288eb737c..79fb94881c4b 100644
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@ -567,6 +567,7 @@ struct ethtool_pauseparam {
  * @ETH_SS_TSTAMP_TX_TYPE: timestamping Tx type names
  * @ETH_SS_TSTAMP_RX_FILTER: timestamping Rx filter names
  * @ETH_SS_LINK_MODES: link mode names
+ * @ETH_SS_RESET_FLAGS: components for device reset
  */
 enum ethtool_stringset {
 	ETH_SS_TEST		= 0,
@@ -582,6 +583,7 @@ enum ethtool_stringset {
 	ETH_SS_TSTAMP_TX_TYPE,
 	ETH_SS_TSTAMP_RX_FILTER,
 	ETH_SS_LINK_MODES,
+	ETH_SS_RESET_FLAGS,
 
 	ETH_SS_COUNT
 };
@@ -1743,6 +1745,7 @@ enum ethtool_reset_flags {
 	ETH_RESET_ALL		= 0xffffffff,	/* All components used by this
 						 * interface, even if shared */
 };
+#define ETH_RESET_NFLAGS 9
 #define ETH_RESET_SHARED_SHIFT	16
 
 
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 13a570134dd4..4d6d8e0b1340 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -24,6 +24,7 @@ enum {
 	ETHNL_CMD_SET_PARAMS,
 	ETHNL_CMD_ACT_NWAY_RST,
 	ETHNL_CMD_ACT_PHYS_ID,
+	ETHNL_CMD_ACT_RESET,
 
 	__ETHNL_CMD_CNT,
 	ETHNL_CMD_MAX = (__ETHNL_CMD_CNT - 1)
@@ -394,6 +395,21 @@ enum {
 	ETHA_PHYSID_MAX = (__ETHA_PHYSID_CNT - 1)
 };
 
+/* ACT_RESET */
+
+enum {
+	ETHA_RESET_UNSPEC,
+	ETHA_RESET_DEV,				/* nest - ETHA_DEV_* */
+	ETHA_RESET_COMPACT,			/* flag */
+	ETHA_RESET_ALL,				/* flag */
+	ETHA_RESET_ALL_DEDICATED,		/* flag */
+	ETHA_RESET_DEDICATED,			/* bitset */
+	ETHA_RESET_SHARED,			/* bitset */
+
+	__ETHA_RESET_CNT,
+	ETHA_RESET_MAX = (__ETHA_RESET_CNT - 1)
+};
+
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
 #define ETHTOOL_GENL_VERSION 1
diff --git a/net/ethtool/actions.c b/net/ethtool/actions.c
index a131a92b7957..a22fecd8e272 100644
--- a/net/ethtool/actions.c
+++ b/net/ethtool/actions.c
@@ -2,6 +2,7 @@
 
 #include "netlink.h"
 #include "common.h"
+#include "bitset.h"
 
 /* ACT_NWAY_RST */
 
@@ -148,3 +149,238 @@ int ethnl_act_phys_id(struct sk_buff *skb, struct genl_info *info)
 	dev_put(dev);
 	return ret;
 }
+
+/* ACT_RESET */
+
+const char *const reset_flag_names[] = {
+	"mgmt",
+	"irq",
+	"dma",
+	"filter",
+	"offload",
+	"mac",
+	"phy",
+	"ram",
+	"ap"
+};
+
+static const struct nla_policy reset_policy[ETHA_RESET_MAX + 1] = {
+	[ETHA_RESET_UNSPEC]		= { .type = NLA_REJECT },
+	[ETHA_RESET_DEV]		= { .type = NLA_NESTED },
+	[ETHA_RESET_COMPACT]		= { .type = NLA_FLAG },
+	[ETHA_RESET_ALL]		= { .type = NLA_FLAG },
+	[ETHA_RESET_ALL_DEDICATED]	= { .type = NLA_FLAG },
+	[ETHA_RESET_DEDICATED]		= { .type = NLA_NESTED },
+	[ETHA_RESET_SHARED]		= { .type = NLA_NESTED },
+};
+
+static int reset_size(u32 flags, u32 orig_flags, bool compact)
+{
+	const unsigned int bitset_flags = compact ? ETHNL_BITSET_COMPACT : 0;
+	int len = dev_ident_size();
+	u32 bitmap, bitmask;
+	int ret;
+
+	BUILD_BUG_ON(ETH_RESET_NFLAGS > 16);
+
+	if (flags == ETH_RESET_ALL)
+		return len + nla_total_size(0);
+	bitmap = flags >> 16;
+	bitmask = orig_flags >> 16;
+	ret = ethnl_bitset32_size(ETH_RESET_NFLAGS, &bitmap, &bitmask,
+				  reset_flag_names, bitset_flags);
+	if (ret < 0)
+		return ret;
+	len += ret;
+
+	if ((flags & ETH_RESET_DEDICATED) == ETH_RESET_DEDICATED) {
+		len += nla_total_size(0);
+	} else {
+		bitmap = flags & ETH_RESET_DEDICATED;
+		bitmask = orig_flags & ETH_RESET_DEDICATED;
+		ret = ethnl_bitset32_size(ETH_RESET_NFLAGS, &bitmap, &bitmask,
+					  reset_flag_names, bitset_flags);
+		if (ret < 0)
+			return ret;
+		len += ret;
+	}
+
+	return len;
+}
+
+static int fill_reset(struct sk_buff *skb, u32 flags, u32 orig_flags,
+		      bool compact)
+{
+	const unsigned int bitset_flags = compact ? ETHNL_BITSET_COMPACT : 0;
+	u32 bitmap, bitmask;
+	int ret;
+
+	if (flags == ETH_RESET_ALL)
+		return nla_put_flag(skb, ETHA_RESET_ALL) ? -EMSGSIZE : 0;
+
+	if ((flags & ETH_RESET_DEDICATED) == ETH_RESET_DEDICATED) {
+		if (nla_put_flag(skb, ETHA_RESET_ALL_DEDICATED))
+			return -EMSGSIZE;
+	} else {
+		bitmap = flags & ETH_RESET_DEDICATED;
+		bitmask = orig_flags & ETH_RESET_DEDICATED;
+		ret = ethnl_put_bitset32(skb, ETHA_RESET_DEDICATED,
+					 ETH_RESET_NFLAGS, &bitmap, &bitmask,
+					 reset_flag_names, bitset_flags);
+		if (ret < 0)
+			return ret;
+	}
+
+	bitmap = flags >> ETH_RESET_SHARED_SHIFT;
+	bitmask = orig_flags >> ETH_RESET_SHARED_SHIFT;
+	return ethnl_put_bitset32(skb, ETHA_RESET_SHARED, ETH_RESET_NFLAGS,
+				  &bitmap, &bitmask, reset_flag_names,
+				  bitset_flags);
+}
+
+void ethnl_reset_notify(struct net_device *dev,
+                          struct netlink_ext_ack *extack, unsigned int cmd,
+                          u32 req_mask, const void *data)
+{
+	u32 flags = *(const u32 *)data;
+	struct sk_buff *skb;
+	void *msg_payload;
+	int msg_len;
+	int ret;
+
+	msg_len = reset_size(flags, flags, true);
+	if (msg_len < 0)
+		return;
+	skb = genlmsg_new(msg_len, GFP_KERNEL);
+	if (!skb)
+		return;
+	msg_payload = genlmsg_put(skb, 0, ++ethnl_bcast_seq,
+				  &ethtool_genl_family, 0,
+				  ETHNL_CMD_ACT_RESET);
+	if (!msg_payload)
+		goto err_skb;
+
+	ret = ethnl_fill_dev(skb, dev, ETHA_RESET_DEV);
+	if (ret < 0)
+		goto err_skb;
+	ret = fill_reset(skb, flags, flags, true);
+	if (ret < 0)
+		goto err_skb;
+
+	genlmsg_end(skb, msg_payload);
+	genlmsg_multicast(&ethtool_genl_family, skb, 0, ETHNL_MCGRP_MONITOR,
+			  GFP_KERNEL);
+	return;
+
+err_skb:
+	nlmsg_free(skb);
+}
+
+static int parse_reset(struct nlattr **tb, u32 *val, struct genl_info *info)
+{
+	u32 flags;
+	int ret;
+
+	if (tb[ETHA_RESET_ALL]) {
+		*val = ETH_RESET_ALL;
+		return 0;
+	}
+
+	*val = 0;
+	flags = 0;
+	ethnl_update_bitset32(&flags, NULL, ETH_RESET_NFLAGS,
+			      tb[ETHA_RESET_SHARED], &ret, reset_flag_names,
+			      false, info);
+	if (ret < 0)
+		return ret;
+	*val |= (flags << ETH_RESET_SHARED_SHIFT);
+
+	if (tb[ETHA_RESET_ALL_DEDICATED])
+		*val |= ETH_RESET_DEDICATED;
+	else {
+		flags = 0;
+		ethnl_update_bitset32(&flags, NULL, ETH_RESET_NFLAGS,
+				      tb[ETHA_RESET_DEDICATED], &ret,
+				      reset_flag_names, false, info);
+		if (ret < 0)
+			return ret;
+		*val |= flags;
+	}
+
+	return 0;
+}
+
+int ethnl_act_reset(struct sk_buff *skb, struct genl_info *info)
+{
+	struct nlattr *tb[ETHA_RESET_MAX + 1];
+	struct sk_buff *rskb = NULL;
+	struct net_device *dev;
+	u32 orig_flags, flags;
+	void *reply_payload;
+	int reply_ret = 0;
+	int reply_len;
+	bool compact;
+	int ret;
+
+	ret = ethnlmsg_parse(info->nlhdr, tb, ETHA_RESET_MAX, reset_policy,
+			     info);
+	if (ret < 0)
+		return ret;
+	dev = ethnl_dev_get(info, tb[ETHA_RESET_DEV]);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+	if (!dev->ethtool_ops->reset)
+		return -EOPNOTSUPP;
+	compact = (tb[ETHA_RESET_COMPACT] != NULL);
+	ret = parse_reset(tb, &flags, info);
+	if (ret < 0)
+		goto out_dev;
+
+	orig_flags = flags;
+	rtnl_lock();
+	ret = ethnl_before_ops(dev);
+	if (ret < 0)
+		goto out_rtnl;
+	ret = dev->ethtool_ops->reset(dev, &flags);
+	ethnl_after_ops(dev);
+	if (ret < 0)
+		goto out_rtnl;
+
+	flags = orig_flags & ~flags;
+	if (flags)
+		ethnl_reset_notify(dev, NULL, ETHNL_CMD_ACT_RESET, 0, &flags);
+
+	/* compose reply message */
+	reply_len = reset_size(flags, orig_flags, compact);
+	reply_ret = -EFAULT;
+	if (reply_len < 0)
+		goto out;
+	reply_ret = -ENOMEM;
+	rskb = ethnl_reply_init(reply_len, dev, ETHNL_CMD_ACT_RESET,
+				ETHA_RESET_DEV, info, &reply_payload);
+	if (!rskb)
+		goto err_rskb;
+	reply_ret = fill_reset(rskb, flags, orig_flags, compact);
+	if (reply_ret < 0)
+		goto err_rskb;
+	rtnl_unlock();
+	dev_put(dev);
+	genlmsg_end(rskb, reply_payload);
+	reply_ret = genlmsg_reply(rskb, info);
+	goto out;
+
+err_rskb:
+	WARN_ONCE(ret == -EMSGSIZE,
+		  "calculated message payload length (%d) not sufficient\n",
+		  reply_len);
+	if (rskb)
+		nlmsg_free(rskb);
+out_rtnl:
+	rtnl_unlock();
+out_dev:
+	dev_put(dev);
+out:
+	if (reply_ret < 0)
+		ETHNL_SET_ERRMSG(info, "failed to send reply message");
+	return ret;
+}
diff --git a/net/ethtool/ioctl.c b/net/ethtool/ioctl.c
index dfe306d7676d..5c266dea008e 100644
--- a/net/ethtool/ioctl.c
+++ b/net/ethtool/ioctl.c
@@ -1188,6 +1188,7 @@ static int ethtool_get_regs(struct net_device *dev, char __user *useraddr)
 static int ethtool_reset(struct net_device *dev, char __user *useraddr)
 {
 	struct ethtool_value reset;
+	u32 reset_flags;
 	int ret;
 
 	if (!dev->ethtool_ops->reset)
@@ -1196,9 +1197,13 @@ static int ethtool_reset(struct net_device *dev, char __user *useraddr)
 	if (copy_from_user(&reset, useraddr, sizeof(reset)))
 		return -EFAULT;
 
+	reset_flags = reset.data;
 	ret = dev->ethtool_ops->reset(dev, &reset.data);
 	if (ret)
 		return ret;
+	reset_flags &= ~reset.data;
+	if (reset_flags)
+		ethtool_notify(dev, NULL, ETHNL_CMD_ACT_RESET, 0, &reset_flags);
 
 	if (copy_to_user(useraddr, &reset, sizeof(reset)))
 		return -EFAULT;
diff --git a/net/ethtool/netlink.c b/net/ethtool/netlink.c
index 54e073aa2f2c..508a9ff1cd77 100644
--- a/net/ethtool/netlink.c
+++ b/net/ethtool/netlink.c
@@ -567,6 +567,7 @@ ethnl_notify_handler_t ethnl_notify_handlers[] = {
 	[ETHNL_CMD_SET_PARAMS]		= ethnl_std_notify,
 	[ETHNL_CMD_ACT_NWAY_RST]	= ethnl_nwayrst_notify,
 	[ETHNL_CMD_ACT_PHYS_ID]		= ethnl_physid_notify,
+	[ETHNL_CMD_ACT_RESET]		= ethnl_reset_notify,
 };
 
 void ethtool_notify(struct net_device *dev, struct netlink_ext_ack *extack,
@@ -706,6 +707,11 @@ static const struct genl_ops ethtool_genl_ops[] = {
 		.flags	= GENL_UNS_ADMIN_PERM,
 		.doit	= ethnl_act_phys_id,
 	},
+	{
+		.cmd	= ETHNL_CMD_ACT_RESET,
+		.flags	= GENL_ADMIN_PERM,
+		.doit	= ethnl_act_reset,
+	},
 };
 
 static const struct genl_multicast_group ethtool_nl_mcgrps[] = {
diff --git a/net/ethtool/netlink.h b/net/ethtool/netlink.h
index 2a3d762911e2..25098c150fa1 100644
--- a/net/ethtool/netlink.h
+++ b/net/ethtool/netlink.h
@@ -24,6 +24,7 @@ extern const char *const so_timestamping_labels[];
 extern const char *const tstamp_tx_type_labels[];
 extern const char *const tstamp_rx_filter_labels[];
 extern const char *const link_mode_names[];
+extern const char *const reset_flag_names[];
 
 struct net_device *ethnl_dev_get(struct genl_info *info, struct nlattr *nest);
 int ethnl_fill_dev(struct sk_buff *msg, struct net_device *dev, u16 attrtype);
@@ -291,6 +292,7 @@ int ethnl_set_settings(struct sk_buff *skb, struct genl_info *info);
 int ethnl_set_params(struct sk_buff *skb, struct genl_info *info);
 int ethnl_act_nway_rst(struct sk_buff *skb, struct genl_info *info);
 int ethnl_act_phys_id(struct sk_buff *skb, struct genl_info *info);
+int ethnl_act_reset(struct sk_buff *skb, struct genl_info *info);
 
 /* notify handlers */
 
@@ -299,5 +301,7 @@ void ethnl_nwayrst_notify(struct net_device *dev,
 			  u32 req_mask, const void *data);
 void ethnl_physid_notify(struct net_device *dev, struct netlink_ext_ack *extack,
 			 unsigned int cmd, u32 req_mask, const void *data);
+void ethnl_reset_notify(struct net_device *dev, struct netlink_ext_ack *extack,
+			unsigned int cmd, u32 req_mask, const void *data);
 
 #endif /* _NET_ETHTOOL_NETLINK_H */
diff --git a/net/ethtool/strset.c b/net/ethtool/strset.c
index 577d1309ba6f..14ab47ff1577 100644
--- a/net/ethtool/strset.c
+++ b/net/ethtool/strset.c
@@ -91,6 +91,12 @@ static const struct strset_info info_template[] = {
 		.count		= __ETHTOOL_LINK_MODE_MASK_NBITS,
 		.data		= { .simple = link_mode_names },
 	},
+	[ETH_SS_RESET_FLAGS] = {
+		.type		= ETH_SS_TYPE_SIMPLE,
+		.per_dev	= false,
+		.count		= ETH_RESET_NFLAGS,
+		.data		= { .simple = reset_flag_names },
+	},
 };
 
 struct strset_data {
-- 
2.21.0

