From ee664db55f247b8fe8d1fcbfcc5ca6f377cac91a Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 2 Nov 2018 19:41:56 +0100
Subject: [PATCH 34/34] netlink: add netlink handler for setting flow hash
 options (-N rx-flow-hash)

Implement "ethtool -N <dev> rx-flow-hash" subcommand using netlink
interface command ETHTOOL_MSG_RXFLOW_SET.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 ethtool.c        |   3 +-
 netlink/extapi.h |   1 +
 netlink/rxflow.c | 112 +++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 115 insertions(+), 1 deletion(-)

diff --git a/ethtool.c b/ethtool.c
index a63be354ddfa..5ad1b6fc8a71 100644
--- a/ethtool.c
+++ b/ethtool.c
@@ -5003,6 +5003,7 @@ static int show_usage(struct cmd_context *ctx);
 #define nl_grxfh	NULL
 #define nl_srxfh	NULL
 #define nl_grxclass	NULL
+#define nl_srxclass	NULL
 #endif
 
 static const struct option {
@@ -5106,7 +5107,7 @@ static const struct option {
 	  "		[ rx-flow-hash tcp4|udp4|ah4|esp4|sctp4|"
 	  "tcp6|udp6|ah6|esp6|sctp6 [context %d] |\n"
 	  "		  rule %d ]\n" },
-	{ "-N|-U|--config-nfc|--config-ntuple", 1, do_srxclass, NULL,
+	{ "-N|-U|--config-nfc|--config-ntuple", 1, do_srxclass, nl_srxclass,
 	  "Configure Rx network flow classification options or rules",
 	  "		rx-flow-hash tcp4|udp4|ah4|esp4|sctp4|"
 	  "tcp6|udp6|ah6|esp6|sctp6 m|v|t|s|d|f|n|r... [context %d] |\n"
diff --git a/netlink/extapi.h b/netlink/extapi.h
index 30ec79f0e94e..c86a4c7d0aa3 100644
--- a/netlink/extapi.h
+++ b/netlink/extapi.h
@@ -39,6 +39,7 @@ int nl_reset(struct cmd_context *ctx);
 int nl_grxfh(struct cmd_context *ctx);
 int nl_srxfh(struct cmd_context *ctx);
 int nl_grxclass(struct cmd_context *ctx);
+int nl_srxclass(struct cmd_context *ctx);
 int nl_monitor(struct cmd_context *ctx);
 
 void monitor_usage();
diff --git a/netlink/rxflow.c b/netlink/rxflow.c
index 7d8f6a1e797f..d37cab569144 100644
--- a/netlink/rxflow.c
+++ b/netlink/rxflow.c
@@ -799,3 +799,115 @@ out_free:
 	free(data.weight.weights);
 	return ret;
 }
+
+static const struct bitfield32_parser_special rxh_parser_specials[] = {
+	{ 'r', RXH_DISCARD },
+	{}
+};
+static const struct bitfield32_parser_data rxh_parser_data = {
+	.bits = {
+		[1]	= 'm',
+		[2]	= 'v',
+		[3]	= 't',
+		[4]	= 's',
+		[5]	= 'd',
+		[6]	= 'f',
+		[7]	= 'n',
+	},
+	.specials = rxh_parser_specials,
+};
+
+int ethnl_set_hashopts(struct cmd_context *ctx)
+{
+	struct nl_context *nlctx = ctx->nlctx;
+	struct nlattr *opts_attr, *opt_attr;
+	struct nla_bitfield32 flags;
+	unsigned int nopts = 0;
+	uint32_t context = 0;
+	int ret;
+
+	ret = ethnl_prep_get_request(ctx, ETHTOOL_MSG_RXFLOW_SET,
+				     ETHTOOL_A_RXFLOW_HEADER, 0, 0, 0);
+	if (ret < 0)
+		return 2;
+
+	opts_attr = ethnla_nest_start(nlctx, ETHTOOL_A_RXFLOW_HASH_OPTS);
+	if (!opts_attr)
+		return 2;
+	while (nlctx->argc > 0) {
+		if (nlctx->argc < 2) {
+			fprintf(stderr, "extra argument '%s' for -N\n",
+				nlctx->argp[0]);
+			return 2;
+		}
+		if (!strcmp(nlctx->argp[0], "context")) {
+			ret = parse_u32(nlctx->argp[1], &context);
+			if (ret < 0)
+				return 2;
+			nlctx->argc -= 2;
+			nlctx->argp += 2;
+			continue;
+		}
+
+		opt_attr = ethnla_nest_start(nlctx, ETHTOOL_A_RXHASHOPTS_OPT);
+		if (!opts_attr)
+			return 2;
+		ret = nl_parse_lookup_u32(nlctx, ETHTOOL_A_RXHASHOPT_FLOWTYPE,
+					  flow_types, NULL);
+		if (ret < 0)
+			return 2;
+		ret = nl_parse_char_bitfield32(nlctx, 0, &rxh_parser_data,
+					       &flags);
+		if (ret < 0)
+			return 2;
+		if (flags.value & RXH_DISCARD)
+			ret = ethnla_put_flag(nlctx,
+					      ETHTOOL_A_RXHASHOPT_DISCARD,
+					      true);
+		else
+			ret = ethnla_put(nlctx, ETHTOOL_A_RXHASHOPT_FIELDS,
+					 sizeof(flags), &flags);
+		if (ret < 0)
+			return 2;
+		mnl_attr_nest_end(nlctx->nlhdr, opt_attr);
+
+		nlctx->argc -= 2;
+		nlctx->argp += 2;
+		nopts++;
+	}
+	if (nopts == 0) {
+		fprintf(stderr, "no hash opts present, ignoring\n");
+		return 0;
+	}
+	mnl_attr_nest_end(nlctx->nlhdr, opts_attr);
+
+	return ethnl_send_get_request(nlctx, nomsg_reply_cb);
+}
+
+int nl_srxclass(struct cmd_context *ctx)
+{
+	struct nl_context *nlctx = ctx->nlctx;
+	const char *arg;
+
+	nlctx->cmd = "-N";
+	nlctx->argp = ctx->argp;
+	nlctx->argc = ctx->argc;
+
+	if (nlctx->argc == 0) {
+		fprintf(stderr, "ethtool: missing argument for '-N'\n");
+		exit(2);
+	}
+	arg = ctx->argp[0];
+
+	if (!strcmp(arg, "rx-flow-hash")) {
+		nlctx->argc--;
+		nlctx->argp++;
+		return ethnl_set_hashopts(ctx);
+	} else {
+		fprintf(stderr, "ethtool: unknown argument '%s' for '-N'\n",
+			arg);
+		exit(2);
+	}
+
+	return -EOPNOTSUPP;
+}
-- 
2.22.0

