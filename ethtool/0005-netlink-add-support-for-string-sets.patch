From 7cd60e72cbe35f015652ebbe01761549646a6bf3 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 23 Jul 2018 14:09:19 +0200
Subject: [PATCH 05/21] netlink: add support for string sets

Add infrastructure for querying kernel string sets (analog to ioct commands
ETHTOOL_GSSET_INFO and ETHTOOL_GSTRINGS).

Let notification monitor request string sets on start so that it can
resolve bit indices to names when processing bitsets in compact format.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 netlink.c | 225 +++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 224 insertions(+), 1 deletion(-)

diff --git a/netlink.c b/netlink.c
index c16c6731e2aa..ae07f80df0cb 100644
--- a/netlink.c
+++ b/netlink.c
@@ -639,6 +639,204 @@ bool show_only(const struct nl_context *nlctx, uint32_t bits)
 	return nlctx->filter_mask & ~bits;
 }
 
+/* GET_STRSET */
+
+struct stringset {
+	const char		**strings;
+	void			*raw_data;
+	unsigned int		count;
+};
+
+struct perdev_strings {
+	char			devname[IFNAMSIZ];
+	struct stringset	strings[ETH_SS_MAX + 1];
+	struct perdev_strings	*next;
+};
+
+/* universal string sets */
+static struct stringset global_strings[ETH_SS_MAX + 1];
+/* linked list of string sets related to network devices */
+static struct perdev_strings *device_strings;
+
+static void drop_stringset(struct stringset *set)
+{
+	free(set->strings);
+	free(set->raw_data);
+	set->count = 0;
+}
+
+static int import_stringset(struct stringset *dest, const struct nlattr *nest)
+{
+	const struct nlattr *tb_stringset[ETHA_STRINGSET_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb_stringset);
+	const struct nlattr *string;
+	unsigned int size;
+	unsigned int count;
+	unsigned int idx;
+	int ret;
+
+	ret = mnl_attr_parse_nested(nest, attr_cb, &tb_stringset_info);
+	if (ret < 0)
+		return ret;
+	if (!tb_stringset[ETHA_STRINGSET_ID] ||
+	    !tb_stringset[ETHA_STRINGSET_COUNT] ||
+	    !tb_stringset[ETHA_STRINGSET_STRINGS])
+		return -EFAULT;
+	idx = mnl_attr_get_u32(tb_stringset[ETHA_STRINGSET_ID]);
+	if (idx > ETH_SS_MAX)
+		return 0;
+	count = mnl_attr_get_u32(tb_stringset[ETHA_STRINGSET_COUNT]);
+	if (count == 0)
+		return 0;
+
+	size = mnl_attr_get_len(tb_stringset[ETHA_STRINGSET_STRINGS]);
+	ret = -ENOMEM;
+	dest[idx].raw_data = malloc(size);
+	if (!dest[idx].raw_data)
+		goto err;
+	memcpy(dest[idx].raw_data, tb_stringset[ETHA_STRINGSET_STRINGS], size);
+	dest[idx].strings = malloc(count * sizeof(dest[idx].strings[0]));
+	if (!dest[idx].strings)
+		goto err;
+	dest[idx].count = count;
+
+	nest = dest[idx].raw_data;
+	mnl_attr_for_each_nested(string, nest) {
+		const struct nlattr *tb[ETHA_STRING_MAX + 1] = {};
+		DECLARE_ATTR_TB_INFO(tb);
+		unsigned int i;
+
+		if (mnl_attr_get_type(string) != ETHA_STRINGS_STRING)
+			continue;
+		ret = mnl_attr_parse_nested(string, attr_cb, &tb_info);
+		if (ret < 0)
+			goto err;
+		ret = -EFAULT;
+		if (!tb[ETHA_STRING_INDEX] || !tb[ETHA_STRING_VALUE])
+			goto err;
+
+		i = mnl_attr_get_u32(tb[ETHA_STRING_INDEX]);
+		if (i >= count)
+			goto err;
+		dest[idx].strings[i] =
+			mnl_attr_get_payload(tb[ETHA_STRING_VALUE]);
+	}
+
+	return 0;
+err:
+	drop_stringset(&dest[idx]);
+	return ret;
+}
+
+static void drop_strings(const char *devname)
+{
+	struct perdev_strings **p = &device_strings;
+	unsigned int i;
+
+	for (p = &device_strings; *p; p = &((*p)->next)) {
+		struct perdev_strings *perdev = *p;
+
+		if (devname && strcmp(perdev->devname, devname))
+			continue;
+		*p = perdev->next;
+		for (i = 0; i <= ETH_SS_MAX; i++)
+			drop_stringset(&perdev->strings[i]);
+		free(*p);
+	}
+
+	if (!devname) {
+		for (i = 0; i <= ETH_SS_MAX; i++)
+			drop_stringset(&global_strings[i]);
+	}
+}
+
+static const char *stringset_names[] = {
+	[ETH_SS_TEST] = "test",
+	[ETH_SS_STATS] = "stats",
+	[ETH_SS_PRIV_FLAGS] = "priv-flags",
+	[ETH_SS_NTUPLE_FILTERS] = "ntuple-filters",
+	[ETH_SS_FEATURES] = "features",
+	[ETH_SS_RSS_HASH_FUNCS] = "rss-hash-funcs",
+	[ETH_SS_TUNABLES] = "tunables",
+	[ETH_SS_PHY_STATS] = "phy-stats",
+	[ETH_SS_PHY_TUNABLES] = "phy-tunables",
+	[ETH_SS_LINK_MODES] = "link-modes",
+};
+
+void debug_stringsets(const struct stringset *sets)
+{
+	unsigned int i;
+
+	for (i = 0; i <= ETH_SS_MAX; i++) {
+		if (sets[i].count > 0) {
+			printf("    set %s, count %u\n", stringset_names[i],
+			       sets[i].count);
+		}
+	}
+}
+
+void debug_strings()
+{
+	struct perdev_strings *pd;
+
+	fputs("global strings:\n", stdout);
+	debug_stringsets(global_strings);
+
+	for (pd = device_strings; pd; pd = pd->next) {
+		printf("strings for %s:\n", pd->devname);
+		debug_stringsets(pd->strings);
+	}
+}
+
+static int strset_reply_cb(const struct nlmsghdr *nlhdr, void *data)
+{
+	const struct nlattr *tb[ETHA_STRSET_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb);
+	struct nl_context *nlctx = data;
+	struct stringset *dest;
+	struct nlattr *attr;
+	unsigned int i;
+	int ret;
+
+	ret = mnl_attr_parse(nlhdr, GENL_HDRLEN, attr_cb, &tb_info);
+	if (ret < 0)
+		return ret;
+	nlctx->devname = get_dev_name(tb[ETHA_STRSET_DEV]);
+	if (!dev_ok(nlctx))
+		return MNL_CB_OK;
+
+	if (nlctx->devname) {
+		struct perdev_strings *perdev = device_strings;
+
+		while (perdev && strcmp(perdev->devname, nlctx->devname))
+			perdev = perdev->next;
+		if (perdev) {
+			for (i = 0; i <= ETH_SS_MAX; i++)
+				drop_stringset(&perdev->strings[i]);
+		} else {
+			perdev = calloc(sizeof(*perdev), 1);
+			if (!perdev)
+				return -ENOMEM;
+			strncpy(perdev->devname, nlctx->devname, IFNAMSIZ);
+			perdev->devname[IFNAMSIZ - 1] = '\0';
+			perdev->next = device_strings;
+			device_strings = perdev;
+		}
+		dest = perdev->strings;
+	} else {
+		for (i = 0; i <= ETH_SS_MAX; i++)
+			drop_stringset(&global_strings[i]);
+		dest = global_strings;
+	}
+
+	mnl_attr_for_each(attr, nlhdr, GENL_HDRLEN) {
+		if (mnl_attr_get_type(attr) == ETHA_STRSET_STRINGSET)
+			import_stringset(dest, attr);
+	}
+
+	return MNL_CB_OK;
+}
+
 /* monitor */
 
 static struct {
@@ -730,6 +928,7 @@ opt_found:
 
 int nl_monitor(struct cmd_context *ctx)
 {
+	bool is_dev;
 	struct nl_context *nlctx = ctx->nlctx;
 	uint32_t grpid = nlctx->mon_mcgrp_id;
 	int ret;
@@ -740,18 +939,42 @@ int nl_monitor(struct cmd_context *ctx)
 	}
 	if (parse_monitor(ctx) < 0)
 		return 1;
+	is_dev = ctx->devname && strcmp(ctx->devname, WILDCARD_DEVNAME);
+
+	ret = msg_init(nlctx, ETHNL_CMD_GET_STRSET, NLM_F_REQUEST | NLM_F_ACK);
+	if (ret < 0)
+		return ret;
+	ret = ethnl_send_get_request(ctx, strset_reply_cb);
+	if (ret < 0)
+		return ret;
 
 	ret = mnl_socket_setsockopt(nlctx->sk, NETLINK_ADD_MEMBERSHIP,
 				    &grpid, sizeof(grpid));
 	if (ret < 0)
 		return ret;
 
+	ret = msg_init(nlctx, ETHNL_CMD_GET_STRSET,
+		       NLM_F_REQUEST | NLM_F_ACK | (is_dev ? 0 : NLM_F_DUMP));
+	if (ret < 0)
+		return ret;
+	if (is_dev) {
+		if (ethnla_put_dev(nlctx, ETHA_STRSET_DEV, ctx->devname))
+			return -EMSGSIZE;
+	}
+	ret = ethnl_send_get_request(ctx, strset_reply_cb);
+	if (ret < 0)
+		return ret;
+
 	nlctx->filter_devname = ctx->devname;
 	nlctx->is_monitor = true;
 	nlctx->port = 0;
 	nlctx->seq = 0;
 
-	return ethnl_process_reply(nlctx, monitor_any_cb);
+	fputs("listening...\n", stdout);
+	fflush(stdout);
+	ret = ethnl_process_reply(nlctx, monitor_any_cb);
+	drop_strings(NULL);
+	return ret;
 }
 
 void monitor_usage()
-- 
2.18.0

