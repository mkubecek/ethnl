From 85e6f661e5bf8da5b64c97b769931a093c6e17d1 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 23 Jul 2018 14:09:19 +0200
Subject: [PATCH 05/34] netlink: add support for string sets

Add infrastructure for querying kernel string sets (analog to ioctl
commands ETHTOOL_GSSET_INFO and ETHTOOL_GSTRINGS).

Let notification monitor request string sets on start so that it can
resolve bit indices to names when processing bitsets in compact format.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Makefile.am       |   1 +
 netlink/netlink.c |  66 ++++++++++
 netlink/netlink.h |   4 +
 netlink/strset.c  | 313 ++++++++++++++++++++++++++++++++++++++++++++++
 netlink/strset.h  |  18 +++
 5 files changed, 402 insertions(+)
 create mode 100644 netlink/strset.c
 create mode 100644 netlink/strset.h

diff --git a/Makefile.am b/Makefile.am
index 140769d20e4c..1e07f5d742e3 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -27,6 +27,7 @@ endif
 if ETHTOOL_ENABLE_NETLINK
 ethtool_SOURCES += \
 		  netlink/netlink.c netlink/netlink.h netlink/extapi.h \
+		  netlink/strset.c netlink/strset.h \
 		  uapi/linux/ethtool_netlink.h \
 		  uapi/linux/netlink.h uapi/linux/genetlink.h
 ethtool_CFLAGS += @MNL_CFLAGS@
diff --git a/netlink/netlink.c b/netlink/netlink.c
index 7a8f21c4f180..27d4f602977b 100644
--- a/netlink/netlink.c
+++ b/netlink/netlink.c
@@ -6,6 +6,7 @@
 #include "../internal.h"
 #include "netlink.h"
 #include "extapi.h"
+#include "strset.h"
 
 /* misc helpers */
 
@@ -162,6 +163,70 @@ err:
 	return true;
 }
 
+int walk_bitset(const struct nlattr *bitset, const struct stringset *labels,
+		bitset_walk_callback cb, void *data)
+{
+	const struct nlattr *bitset_tb[ETHTOOL_A_BITSET_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(bitset_tb);
+	const struct nlattr *bits;
+	const struct nlattr *bit;
+	bool is_list;
+	int ret;
+
+	ret = mnl_attr_parse_nested(bitset, attr_cb, &bitset_tb_info);
+	if (ret < 0)
+		return ret;
+	is_list = bitset_tb[ETHTOOL_A_BITSET_LIST];
+
+	bits = bitset_tb[ETHTOOL_A_BITSET_VALUE];
+	if (bits) {
+		const struct nlattr *mask = bitset_tb[ETHTOOL_A_BITSET_MASK];
+		unsigned int count, nwords, idx;
+		uint32_t *val_bm;
+		uint32_t *mask_bm;
+
+		if (!bitset_tb[ETHTOOL_A_BITSET_SIZE])
+			return -EFAULT;
+		count = mnl_attr_get_u32(bitset_tb[ETHTOOL_A_BITSET_SIZE]);
+		nwords = (count + 31) / 32;
+		if ((mnl_attr_get_payload_len(bits) / 4 < nwords) ||
+		    (mask && mnl_attr_get_payload_len(mask) / 4 < nwords))
+			return -EFAULT;
+
+		val_bm = mnl_attr_get_payload(bits);
+		mask_bm = mask ? mnl_attr_get_payload(mask) : NULL;
+		for (idx = 0; idx < count; idx++)
+			if (!mask_bm || (mask_bm[idx / 32] & (1 << (idx % 32))))
+				cb(idx, get_string(labels, idx),
+				   val_bm[idx / 32] & (1 << (idx % 32)), data);
+		return 0;
+	}
+
+	bits = bitset_tb[ETHTOOL_A_BITSET_BITS];
+	if (!bits)
+		return -EFAULT;
+	mnl_attr_for_each_nested(bit, bits) {
+		const struct nlattr *tb[ETHTOOL_A_BIT_MAX + 1] = {};
+		DECLARE_ATTR_TB_INFO(tb);
+		const char *name;
+		unsigned int idx;
+
+		if (mnl_attr_get_type(bit) != ETHTOOL_A_BITS_BIT)
+			continue;
+
+		ret = mnl_attr_parse_nested(bit, attr_cb, &tb_info);
+		if (ret < 0 ||
+		    !tb[ETHTOOL_A_BIT_INDEX] || !tb[ETHTOOL_A_BIT_NAME])
+			return -EFAULT;
+
+		idx = mnl_attr_get_u32(tb[ETHTOOL_A_BIT_INDEX]);
+		name = mnl_attr_get_str(tb[ETHTOOL_A_BIT_NAME]);
+		cb(idx, name, is_list || tb[ETHTOOL_A_BIT_VALUE], data);
+	}
+
+	return 0;
+}
+
 static int msg_realloc(struct nl_context *nlctx, unsigned int new_size)
 {
 	unsigned int nlhdr_offset = (char *)nlctx->nlhdr - nlctx->buff;
@@ -696,4 +761,5 @@ void netlink_done(struct cmd_context *ctx)
 	nlctx_done(ctx->nlctx);
 	free(ctx->nlctx);
 	ctx->nlctx = NULL;
+	cleanup_all_strings();
 }
diff --git a/netlink/netlink.h b/netlink/netlink.h
index 69736a4e6faf..b4a22d41911d 100644
--- a/netlink/netlink.h
+++ b/netlink/netlink.h
@@ -41,6 +41,8 @@ struct attr_tb_info {
 #define DECLARE_ATTR_TB_INFO(tbl) \
 	struct attr_tb_info tbl ## _info = { (tbl), (MNL_ARRAY_SIZE(tbl) - 1) }
 
+struct stringset;
+
 unsigned int nl_copy_payload(void *buff, unsigned int maxlen,
 			     const struct nlattr *attr);
 bool ethnla_put(struct nl_context *nlctx, uint16_t type, size_t len,
@@ -57,6 +59,8 @@ bool bitset_get_bit(const struct nlattr *bitset, bool mask, unsigned int idx,
 		    int *retptr);
 bool bitset_is_empty(const struct nlattr *bitset, bool mask, int *retptr);
 typedef void (*bitset_walk_callback)(unsigned int, const char *, bool, void *);
+int walk_bitset(const struct nlattr *bitset, const struct stringset *label,
+		bitset_walk_callback cb, void *data);
 
 int msg_init(struct nl_context *nlctx, int cmd, unsigned int flags);
 int ethnl_process_reply(struct nl_context *nlctx, mnl_cb_t reply_cb);
diff --git a/netlink/strset.c b/netlink/strset.c
new file mode 100644
index 000000000000..d32a87d50476
--- /dev/null
+++ b/netlink/strset.c
@@ -0,0 +1,313 @@
+#include <errno.h>
+#include <string.h>
+
+#include "../internal.h"
+#include "netlink.h"
+
+struct stringset {
+	const char		**strings;
+	void			*raw_data;
+	unsigned int		count;
+};
+
+struct perdev_strings {
+	int			ifindex;
+	char			devname[IFNAMSIZ];
+	struct stringset	strings[ETH_SS_COUNT];
+	struct perdev_strings	*next;
+};
+
+/* universal string sets */
+static struct stringset global_strings[ETH_SS_COUNT];
+/* linked list of string sets related to network devices */
+static struct perdev_strings *device_strings;
+
+static void drop_stringset(struct stringset *set)
+{
+	if (!set)
+		return;
+
+	free(set->strings);
+	free(set->raw_data);
+	set->count = 0;
+}
+
+static int import_stringset(struct stringset *dest, const struct nlattr *nest)
+{
+	const struct nlattr *tb_stringset[ETHTOOL_A_STRINGSET_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb_stringset);
+	const struct nlattr *string;
+	unsigned int size;
+	unsigned int count;
+	unsigned int idx;
+	int ret;
+
+	ret = mnl_attr_parse_nested(nest, attr_cb, &tb_stringset_info);
+	if (ret < 0)
+		return ret;
+	if (!tb_stringset[ETHTOOL_A_STRINGSET_ID] ||
+	    !tb_stringset[ETHTOOL_A_STRINGSET_COUNT] ||
+	    !tb_stringset[ETHTOOL_A_STRINGSET_STRINGS])
+		return -EFAULT;
+	idx = mnl_attr_get_u32(tb_stringset[ETHTOOL_A_STRINGSET_ID]);
+	if (idx >= ETH_SS_COUNT)
+		return 0;
+	count = mnl_attr_get_u32(tb_stringset[ETHTOOL_A_STRINGSET_COUNT]);
+	if (count == 0)
+		return 0;
+
+	size = mnl_attr_get_len(tb_stringset[ETHTOOL_A_STRINGSET_STRINGS]);
+	ret = -ENOMEM;
+	dest[idx].raw_data = malloc(size);
+	if (!dest[idx].raw_data)
+		goto err;
+	memcpy(dest[idx].raw_data, tb_stringset[ETHTOOL_A_STRINGSET_STRINGS],
+	       size);
+	dest[idx].strings = calloc(count, sizeof(dest[idx].strings[0]));
+	if (!dest[idx].strings)
+		goto err;
+	dest[idx].count = count;
+
+	nest = dest[idx].raw_data;
+	mnl_attr_for_each_nested(string, nest) {
+		const struct nlattr *tb[ETHTOOL_A_STRING_MAX + 1] = {};
+		DECLARE_ATTR_TB_INFO(tb);
+		unsigned int i;
+
+		if (mnl_attr_get_type(string) != ETHTOOL_A_STRINGS_STRING)
+			continue;
+		ret = mnl_attr_parse_nested(string, attr_cb, &tb_info);
+		if (ret < 0)
+			goto err;
+		ret = -EFAULT;
+		if (!tb[ETHTOOL_A_STRING_INDEX] || !tb[ETHTOOL_A_STRING_VALUE])
+			goto err;
+
+		i = mnl_attr_get_u32(tb[ETHTOOL_A_STRING_INDEX]);
+		if (i >= count)
+			goto err;
+		dest[idx].strings[i] =
+			mnl_attr_get_payload(tb[ETHTOOL_A_STRING_VALUE]);
+	}
+
+	return 0;
+err:
+	drop_stringset(&dest[idx]);
+	return ret;
+}
+
+static const char *stringset_names[] = {
+	[ETH_SS_TEST] = "test",
+	[ETH_SS_STATS] = "stats",
+	[ETH_SS_PRIV_FLAGS] = "priv-flags",
+	[ETH_SS_NTUPLE_FILTERS] = "ntuple-filters",
+	[ETH_SS_FEATURES] = "features",
+	[ETH_SS_RSS_HASH_FUNCS] = "rss-hash-funcs",
+	[ETH_SS_TUNABLES] = "tunables",
+	[ETH_SS_PHY_STATS] = "phy-stats",
+	[ETH_SS_PHY_TUNABLES] = "phy-tunables",
+	[ETH_SS_LINK_MODES] = "link-modes",
+};
+
+void debug_stringsets(const struct stringset *sets)
+{
+	unsigned int i;
+
+	for (i = 0; i < ETH_SS_COUNT; i++) {
+		if (sets[i].count > 0) {
+			printf("    set %s, count %u\n", stringset_names[i],
+			       sets[i].count);
+		}
+	}
+}
+
+void debug_strings()
+{
+	struct perdev_strings *pd;
+
+	fputs("global strings:\n", stdout);
+	debug_stringsets(global_strings);
+
+	for (pd = device_strings; pd; pd = pd->next) {
+		printf("strings for %s:\n", pd->devname);
+		debug_stringsets(pd->strings);
+	}
+}
+
+static int strset_reply_cb(const struct nlmsghdr *nlhdr, void *data)
+{
+	const struct nlattr *tb[ETHTOOL_A_STRSET_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb);
+	struct nl_context *nlctx = data;
+	char devname[IFNAMSIZ] = "";
+	struct stringset *dest;
+	struct nlattr *attr;
+	int ifindex = 0;
+	unsigned int i;
+	int ret;
+
+	ret = mnl_attr_parse(nlhdr, GENL_HDRLEN, attr_cb, &tb_info);
+	if (ret < 0)
+		return ret;
+	if (tb[ETHTOOL_A_STRSET_HEADER]) {
+		ret = get_dev_info(tb[ETHTOOL_A_STRSET_HEADER], &ifindex,
+				   devname);
+		if (ret < 0)
+			return MNL_CB_OK;
+		nlctx->devname = devname;
+	}
+
+	if (ifindex) {
+		struct perdev_strings *perdev = device_strings;
+
+		while (perdev && perdev->ifindex != ifindex)
+			perdev = perdev->next;
+		if (perdev) {
+			for (i = 0; i < ETH_SS_COUNT; i++)
+				drop_stringset(&perdev->strings[i]);
+		} else {
+			perdev = calloc(sizeof(*perdev), 1);
+			if (!perdev)
+				return MNL_CB_OK;
+			perdev->ifindex = ifindex;
+			copy_devname(perdev->devname, devname);
+			perdev->next = device_strings;
+			device_strings = perdev;
+		}
+		dest = perdev->strings;
+	} else {
+		for (i = 0; i < ETH_SS_COUNT; i++)
+			drop_stringset(&global_strings[i]);
+		dest = global_strings;
+	}
+
+	if (!tb[ETHTOOL_A_STRSET_STRINGSETS])
+		return MNL_CB_OK;
+	mnl_attr_for_each_nested(attr, tb[ETHTOOL_A_STRSET_STRINGSETS]) {
+		if (mnl_attr_get_type(attr) ==
+		    ETHTOOL_A_STRINGSETS_STRINGSET)
+			import_stringset(dest, attr);
+	}
+
+	return MNL_CB_OK;
+}
+
+/* interface */
+
+const struct stringset *global_stringset(unsigned int type)
+{
+	if (type >= ETH_SS_COUNT)
+		return NULL;
+	return &global_strings[type];
+}
+
+const struct stringset *perdev_stringset(const char *dev, unsigned int type)
+{
+	const struct perdev_strings *p;
+
+	if (type >= ETH_SS_COUNT)
+		return NULL;
+	for (p = device_strings; p; p = p->next)
+		if (!strcmp(p->devname, dev))
+			return &p->strings[type];
+
+	return NULL;
+}
+
+unsigned int get_count(const struct stringset *set)
+{
+	return set->count;
+}
+
+const char *get_string(const struct stringset *set, unsigned int idx)
+{
+	if (idx >= set->count)
+		return NULL;
+	return set->strings[idx];
+}
+
+int load_global_strings(struct nl_context *nlctx)
+{
+	int ret;
+
+	ret = msg_init(nlctx, ETHTOOL_MSG_STRSET_GET,
+		       NLM_F_REQUEST | NLM_F_ACK);
+	if (ret < 0)
+		return ret;
+	if (ethnla_fill_header(nlctx, ETHTOOL_A_STRSET_HEADER, NULL, 0, 0, 0))
+		return -EMSGSIZE;
+	ret = ethnl_send_get_request(nlctx, strset_reply_cb);
+	return ret;
+}
+
+int load_perdev_strings(struct nl_context *nlctx, const char *dev)
+{
+	int ret;
+
+	ret = msg_init(nlctx, ETHTOOL_MSG_STRSET_GET,
+		       NLM_F_REQUEST | NLM_F_ACK | (dev ? 0 : NLM_F_DUMP));
+	if (ret < 0)
+		return ret;
+	if (ethnla_fill_header(nlctx, ETHTOOL_A_STRSET_HEADER, dev, 0, 0, 0))
+		return -EMSGSIZE;
+	ret = ethnl_send_get_request(nlctx, strset_reply_cb);
+	return ret;
+}
+
+void free_perdev_strings(const char *devname)
+{
+	struct perdev_strings **p = &device_strings;
+	unsigned int i;
+
+	p = &device_strings;
+	while (*p) {
+		struct perdev_strings *perdev = *p;
+
+		if (devname && strcmp(perdev->devname, devname)) {
+			p = &((*p)->next);
+			continue;
+		}
+		*p = perdev->next;
+		for (i = 0; i < ETH_SS_COUNT; i++)
+			drop_stringset(&perdev->strings[i]);
+		free(perdev);
+	}
+
+	if (!devname) {
+		for (i = 0; i < ETH_SS_COUNT; i++)
+			drop_stringset(&global_strings[i]);
+	}
+}
+
+int rename_perdev_strings(int ifindex, const char *newname, char *oldname)
+{
+	struct perdev_strings *perdev = device_strings;
+
+	while (perdev && perdev->ifindex != ifindex)
+		perdev = perdev->next;
+	if (!perdev)
+		return -ENODEV;
+
+	if (oldname)
+		copy_devname(oldname, perdev->devname);
+	copy_devname(perdev->devname, newname);
+	return 0;
+}
+
+void cleanup_all_strings(void)
+{
+	struct perdev_strings *perdev;
+	unsigned int i;
+
+	for (i = 0; i < ETH_SS_COUNT; i++)
+		drop_stringset(&global_strings[i]);
+
+	perdev = device_strings;
+	while (perdev) {
+		device_strings = perdev->next;
+		for (i = 0; i < ETH_SS_COUNT; i++)
+			drop_stringset(&perdev->strings[i]);
+		free(perdev);
+		perdev = device_strings;
+	}
+}
diff --git a/netlink/strset.h b/netlink/strset.h
new file mode 100644
index 000000000000..1fd75ebd351b
--- /dev/null
+++ b/netlink/strset.h
@@ -0,0 +1,18 @@
+#ifndef ETHTOOL_NETLINK_STRSET_H__
+#define ETHTOOL_NETLINK_STRSET_H__
+
+struct stringset;
+
+const struct stringset *global_stringset(unsigned int type);
+const struct stringset *perdev_stringset(const char *dev, unsigned int type);
+
+unsigned int get_count(const struct stringset *set);
+const char *get_string(const struct stringset *set, unsigned int idx);
+
+int load_global_strings(struct nl_context *nlctx);
+int load_perdev_strings(struct nl_context *nlctx, const char *dev);
+void free_perdev_strings(const char *devname);
+int rename_perdev_strings(int ifindex, const char *newname, char *oldname);
+void cleanup_all_strings(void);
+
+#endif /* ETHTOOL_NETLINK_STRSET_H__ */
-- 
2.22.0

