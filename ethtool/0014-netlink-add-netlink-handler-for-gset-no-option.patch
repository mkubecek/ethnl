From 3897d58bbdef876eb31730459a88ac7343575314 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Wed, 22 Nov 2017 17:54:35 +0100
Subject: [PATCH 14/16] netlink: add netlink handler for gset (no option)

Implement "ethtool <dev>" subcommand using netlink interface commands
ETHTOOL_MSG_LINKINFO_GET, ETHTOOL_MSG_LINKMODES_GET and
ETHTOOL_MSG_LINKSTATE_GET.

Move some output helpers used by both ioctl() and netlink from ethtool.c
into new file common.c.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 Makefile.am        |   1 +
 ethtool.c          |   1 +
 netlink/extapi.h   |   3 +
 netlink/monitor.c  |  37 ++++
 netlink/settings.c | 532 +++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 574 insertions(+)
 create mode 100644 netlink/settings.c

diff --git a/Makefile.am b/Makefile.am
index 65586d9f51a1..e4e864add586 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -30,6 +30,7 @@ ethtool_SOURCES += \
 		  netlink/msgbuff.c netlink/msgbuff.h netlink/nlsock.c \
 		  netlink/nlsock.h netlink/strset.c netlink/strset.h \
 		  netlink/monitor.c netlink/bitset.c netlink/bitset.h \
+		  netlink/settings.c \
 		  uapi/linux/ethtool_netlink.h \
 		  uapi/linux/netlink.h uapi/linux/genetlink.h
 ethtool_CFLAGS += @MNL_CFLAGS@
diff --git a/ethtool.c b/ethtool.c
index b55430fa0335..3545b7f34560 100644
--- a/ethtool.c
+++ b/ethtool.c
@@ -5805,6 +5805,7 @@ int main(int argc, char **argp)
 	}
 	if ((*argp)[0] == '-')
 		exit_bad_args();
+	nlfunc = nl_gset;
 	func = do_gset;
 	no_dev = false;
 
diff --git a/netlink/extapi.h b/netlink/extapi.h
index b4910401ae11..782963c4987c 100644
--- a/netlink/extapi.h
+++ b/netlink/extapi.h
@@ -15,6 +15,7 @@ struct nl_context;
 int netlink_init(struct cmd_context *ctx);
 void netlink_done(struct cmd_context *ctx);
 
+int nl_gset(struct cmd_context *ctx);
 int nl_monitor(struct cmd_context *ctx);
 
 void nl_monitor_usage(void);
@@ -34,6 +35,8 @@ static inline void nl_monitor_usage(void)
 {
 }
 
+#define nl_gset			NULL
+
 #endif /* ETHTOOL_ENABLE_NETLINK */
 
 #endif /* ETHTOOL_EXTAPI_H__ */
diff --git a/netlink/monitor.c b/netlink/monitor.c
index b81d38e38368..c0cfecdcf1ca 100644
--- a/netlink/monitor.c
+++ b/netlink/monitor.c
@@ -5,10 +5,31 @@
 #include "nlsock.h"
 #include "strset.h"
 
+int linkmodes_reply_cb(const struct nlmsghdr *nlhdr, void *data);
+int linkinfo_reply_cb(const struct nlmsghdr *nlhdr, void *data);
+int wol_reply_cb(const struct nlmsghdr *nlhdr, void *data);
+int debug_reply_cb(const struct nlmsghdr *nlhdr, void *data);
+
 static struct {
 	uint8_t		cmd;
 	mnl_cb_t	cb;
 } monitor_callbacks[] = {
+	{
+		.cmd	= ETHTOOL_MSG_LINKMODES_NTF,
+		.cb	= linkmodes_reply_cb,
+	},
+	{
+		.cmd	= ETHTOOL_MSG_LINKINFO_NTF,
+		.cb	= linkinfo_reply_cb,
+	},
+	{
+		.cmd	= ETHTOOL_MSG_WOL_NTF,
+		.cb	= wol_reply_cb,
+	},
+	{
+		.cmd	= ETHTOOL_MSG_DEBUG_NTF,
+		.cb	= debug_reply_cb,
+	},
 };
 
 static void clear_filter(struct nl_context *nlctx)
@@ -64,6 +85,22 @@ static struct monitor_option monitor_opts[] = {
 		.pattern	= "|--all",
 		.cmd		= 0,
 	},
+	{
+		.pattern	= "-s|--change",
+		.cmd		= ETHTOOL_MSG_LINKINFO_NTF,
+	},
+	{
+		.pattern	= "-s|--change",
+		.cmd		= ETHTOOL_MSG_LINKMODES_NTF,
+	},
+	{
+		.pattern	= "-s|--change",
+		.cmd		= ETHTOOL_MSG_WOL_NTF,
+	},
+	{
+		.pattern	= "-s|--change",
+		.cmd		= ETHTOOL_MSG_DEBUG_NTF,
+	},
 };
 
 static bool pattern_match(const char *s, const char *pattern)
diff --git a/netlink/settings.c b/netlink/settings.c
new file mode 100644
index 000000000000..6687e1e575e0
--- /dev/null
+++ b/netlink/settings.c
@@ -0,0 +1,532 @@
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "../internal.h"
+#include "../common.h"
+#include "netlink.h"
+#include "strset.h"
+#include "bitset.h"
+
+/* GET_SETTINGS */
+
+static int dump_pause(const struct nlattr *attr, bool mask, const char *label)
+{
+	bool pause, asym;
+	int ret = 0;
+
+	pause = bitset_get_bit(attr, mask, ETHTOOL_LINK_MODE_Pause_BIT, &ret);
+	if (ret < 0)
+		goto err;
+	asym = bitset_get_bit(attr, mask, ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+			      &ret);
+	if (ret < 0)
+		goto err;
+
+	printf("\t%s", label);
+	if (pause)
+		printf("%s\n", asym ?  "Symmetric Receive-only" : "Symmetric");
+	else
+		printf("%s\n", asym ? "Transmit-only" : "No");
+
+	return 0;
+err:
+	fprintf(stderr, "malformed netlink message (pause modes)\n");
+	return ret;
+}
+
+static void print_banner(struct nl_context *nlctx, bool *first)
+{
+	if (!*first)
+		return;
+	printf("Settings for %s:\n", nlctx->devname);
+	*first = false;
+}
+
+static int dump_link_modes(struct nl_context *nlctx,
+			   const struct nlattr *bitset, bool mask,
+			   unsigned class, const char *before,
+			   const char *between, const char *after,
+			   const char *if_none)
+{
+	const struct nlattr *bitset_tb[ETHTOOL_A_BITSET_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(bitset_tb);
+	const unsigned int before_len = strlen(before);
+	const struct nlattr *bits;
+	const struct nlattr *bit;
+	bool first = true;
+	int prev = -2;
+	int ret;
+
+	ret = mnl_attr_parse_nested(bitset, attr_cb, &bitset_tb_info);
+	bits = bitset_tb[ETHTOOL_A_BITSET_BITS];
+	if (ret < 0)
+		goto err_nonl;
+	if (!bits) {
+		const struct stringset *lm_strings;
+		unsigned int count;
+		unsigned int idx;
+		const char *name;
+
+		ret = netlink_init_ethnl2_socket(nlctx);
+		if (ret < 0)
+			goto err_nonl;
+		lm_strings = global_stringset(ETH_SS_LINK_MODES,
+					      nlctx->ethnl2_socket);
+		bits = mask ? bitset_tb[ETHTOOL_A_BITSET_MASK] :
+			      bitset_tb[ETHTOOL_A_BITSET_VALUE];
+		ret = -EFAULT;
+		if (!bits || !bitset_tb[ETHTOOL_A_BITSET_SIZE])
+			goto err_nonl;
+		count = mnl_attr_get_u32(bitset_tb[ETHTOOL_A_BITSET_SIZE]);
+		if (mnl_attr_get_payload_len(bits) / 4 < (count + 31) / 32)
+			goto err_nonl;
+
+		printf("\t%s", before);
+		for (idx = 0; idx < count; idx++) {
+			const uint32_t *raw_data = mnl_attr_get_payload(bits);
+			char buff[10];
+
+			if (!(raw_data[idx / 32] & (1U << (idx % 32))))
+				continue;
+			if (!lm_class_match(idx, class))
+				continue;
+			name = get_string(lm_strings, idx);
+			if (!name) {
+				snprintf(buff, sizeof(buff), "BIT%u", idx);
+				name = buff;
+			}
+			if (first)
+				first = false;
+			/* ugly hack to preserve old output format */
+			if ((class == LM_CLASS_REAL) && (prev == idx - 1) &&
+			    (prev < link_modes_count) &&
+			    (link_modes[prev].class == LM_CLASS_REAL) &&
+			    (link_modes[prev].duplex == DUPLEX_HALF))
+				putchar(' ');
+			else if (between)
+				printf("\t%s", between);
+			else
+				printf("\n\t%*s", before_len, "");
+			printf("%s", name);
+			prev = idx;
+		}
+		goto after;
+	}
+
+	printf("\t%s", before);
+	mnl_attr_for_each_nested(bit, bits) {
+		const struct nlattr *tb[ETHTOOL_A_BITSET_BIT_MAX + 1] = {};
+		DECLARE_ATTR_TB_INFO(tb);
+		unsigned int idx;
+		const char *name;
+
+		if (mnl_attr_get_type(bit) != ETHTOOL_A_BITSET_BITS_BIT)
+			continue;
+		ret = mnl_attr_parse_nested(bit, attr_cb, &tb_info);
+		if (ret < 0)
+			goto err;
+		ret = -EFAULT;
+		if (!tb[ETHTOOL_A_BITSET_BIT_INDEX] ||
+		    !tb[ETHTOOL_A_BITSET_BIT_NAME])
+			goto err;
+		if (!mask && !tb[ETHTOOL_A_BITSET_BIT_VALUE])
+			continue;
+
+		idx = mnl_attr_get_u32(tb[ETHTOOL_A_BITSET_BIT_INDEX]);
+		name = mnl_attr_get_str(tb[ETHTOOL_A_BITSET_BIT_NAME]);
+		if (!lm_class_match(idx, class))
+			continue;
+		if (first) {
+			first = false;
+		} else {
+			/* ugly hack to preserve old output format */
+			if ((class == LM_CLASS_REAL) && (prev == idx - 1) &&
+			    (prev < link_modes_count) &&
+			    (link_modes[prev].class == LM_CLASS_REAL) &&
+			    (link_modes[prev].duplex == DUPLEX_HALF))
+				putchar(' ');
+			else if (between)
+				printf("\t%s", between);
+			else
+				printf("\n\t%*s", before_len, "");
+		}
+		printf("%s", name);
+		prev = idx;
+	}
+after:
+	if (first && if_none)
+		printf("%s", if_none);
+	printf(after);
+
+	return 0;
+err:
+	putchar('\n');
+err_nonl:
+	fflush(stdout);
+	fprintf(stderr, "malformed netlink message (link_modes)\n");
+	return ret;
+}
+
+static int dump_our_modes(struct nl_context *nlctx, const struct nlattr *attr,
+			  bool *first)
+{
+	bool autoneg;
+	int ret;
+
+	print_banner(nlctx, first);
+	ret = dump_link_modes(nlctx, attr, true, LM_CLASS_PORT,
+			      "Supported ports: [ ", " ", " ]\n", NULL);
+	if (ret < 0)
+		return ret;
+
+	ret = dump_link_modes(nlctx, attr, true, LM_CLASS_REAL,
+			      "Supported link modes:   ", NULL, "\n",
+			      "Not reported");
+	if (ret < 0)
+		return ret;
+	ret = dump_pause(attr, true, "Supported pause frame use: ");
+	if (ret < 0)
+		return ret;
+
+	autoneg = bitset_get_bit(attr, true, ETHTOOL_LINK_MODE_Autoneg_BIT,
+				 &ret);
+	if (ret < 0)
+		return ret;
+	printf("\tSupports auto-negotiation: %s\n", autoneg ? "Yes" : "No");
+
+	ret = dump_link_modes(nlctx, attr, true, LM_CLASS_FEC,
+			      "Supported FEC modes: ", " ", "\n",
+			      "Not reported");
+	if (ret < 0)
+		return ret;
+
+	ret = dump_link_modes(nlctx, attr, false, LM_CLASS_REAL,
+			      "Advertised link modes:  ", NULL, "\n",
+			      "Not reported");
+	if (ret < 0)
+		return ret;
+
+	ret = dump_pause(attr, false, "Advertised pause frame use: ");
+	if (ret < 0)
+		return ret;
+	autoneg = bitset_get_bit(attr, false, ETHTOOL_LINK_MODE_Autoneg_BIT,
+				 &ret);
+	if (ret < 0)
+		return ret;
+	printf("\tAdvertised auto-negotiation: %s\n", autoneg ? "Yes" : "No");
+
+	ret = dump_link_modes(nlctx, attr, true, LM_CLASS_FEC,
+			      "Advertised FEC modes: ", " ", "\n",
+			      "Not reported");
+	return ret;
+}
+
+static int dump_peer_modes(struct nl_context *nlctx, const struct nlattr *attr,
+			   bool *first)
+{
+	bool autoneg;
+	int ret;
+
+	print_banner(nlctx, first);
+	ret = dump_link_modes(nlctx, attr, false, LM_CLASS_REAL,
+			      "Link partner advertised link modes:  ",
+			      NULL, "\n", "Not reported");
+	if (ret < 0)
+		return ret;
+
+	ret = dump_pause(attr, false,
+			 "Link partner advertised pause frame use: ");
+	if (ret < 0)
+		return ret;
+
+	autoneg = bitset_get_bit(attr, false,
+				 ETHTOOL_LINK_MODE_Autoneg_BIT, &ret);
+	if (ret < 0)
+		return ret;
+	printf("\tLink partner advertised auto-negotiation: %s\n",
+	       autoneg ? "Yes" : "No");
+
+	ret = dump_link_modes(nlctx, attr, true, LM_CLASS_FEC,
+			      "Link partner advertised FEC modes: ",
+			      " ", "\n", "No");
+	return ret;
+}
+
+int linkmodes_reply_cb(const struct nlmsghdr *nlhdr, void *data)
+{
+	const struct nlattr *tb[ETHTOOL_A_LINKMODES_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb);
+	struct nl_context *nlctx = data;
+	bool first = true;
+	int ret;
+
+	ret = mnl_attr_parse(nlhdr, GENL_HDRLEN, attr_cb, &tb_info);
+	if (ret < 0)
+		return ret;
+	nlctx->devname = get_dev_name(tb[ETHTOOL_A_LINKMODES_HEADER]);
+	if (!dev_ok(nlctx))
+		return MNL_CB_OK;
+
+	if (tb[ETHTOOL_A_LINKMODES_OURS]) {
+	    ret = dump_our_modes(nlctx, tb[ETHTOOL_A_LINKMODES_OURS], &first);
+	    if (ret < 0)
+		    goto err;
+	}
+	if (tb[ETHTOOL_A_LINKMODES_PEER]) {
+	    ret = dump_peer_modes(nlctx, tb[ETHTOOL_A_LINKMODES_PEER], &first);
+	    if (ret < 0)
+		    goto err;
+	}
+	if (tb[ETHTOOL_A_LINKMODES_SPEED]) {
+		uint32_t val = mnl_attr_get_u32(tb[ETHTOOL_A_LINKMODES_SPEED]);
+
+		print_banner(nlctx, &first);
+		if (val == 0 || val == (uint16_t)(-1) || val == (uint32_t)(-1))
+			printf("\tSpeed: Unknown!\n");
+		else
+			printf("\tSpeed: %uMb/s\n", val);
+	}
+	if (tb[ETHTOOL_A_LINKMODES_DUPLEX]) {
+		uint8_t val = mnl_attr_get_u8(tb[ETHTOOL_A_LINKMODES_DUPLEX]);
+
+		print_banner(nlctx, &first);
+		print_enum(names_duplex, val, "\tDuplex: ", "Unknown! (%i)");
+	}
+	if (tb[ETHTOOL_A_LINKMODES_AUTONEG]) {
+		int autoneg = mnl_attr_get_u8(tb[ETHTOOL_A_LINKMODES_AUTONEG]);
+
+		print_banner(nlctx, &first);
+		printf("\tAuto-negotiation: %s\n",
+		       (autoneg == AUTONEG_DISABLE) ? "off" : "on");
+	}
+
+	return MNL_CB_OK;
+err:
+	if (nlctx->is_monitor || nlctx->is_dump)
+		return MNL_CB_OK;
+	fputs("No data available\n", stdout);
+	nlctx->exit_code = 75;
+	return MNL_CB_ERROR;
+}
+
+int linkinfo_reply_cb(const struct nlmsghdr *nlhdr, void *data)
+{
+	const struct nlattr *tb[ETHTOOL_A_LINKINFO_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb);
+	struct nl_context *nlctx = data;
+	bool first = true;
+	int port = -1;
+	int ret;
+
+	ret = mnl_attr_parse(nlhdr, GENL_HDRLEN, attr_cb, &tb_info);
+	if (ret < 0)
+		return ret;
+	nlctx->devname = get_dev_name(tb[ETHTOOL_A_LINKINFO_HEADER]);
+	if (!dev_ok(nlctx))
+		return MNL_CB_OK;
+
+	if (tb[ETHTOOL_A_LINKINFO_PORT]) {
+		uint8_t val = mnl_attr_get_u8(tb[ETHTOOL_A_LINKINFO_PORT]);
+
+		print_banner(nlctx, &first);
+		print_enum(names_port, val, "\tPort: ", "Unknown! (%i)\n");
+		port = val;
+	}
+	if (tb[ETHTOOL_A_LINKINFO_PHYADDR]) {
+		uint8_t val = mnl_attr_get_u8(tb[ETHTOOL_A_LINKINFO_PHYADDR]);
+
+		print_banner(nlctx, &first);
+		printf("\tPHYAD: %u\n", val);
+	}
+	if (tb[ETHTOOL_A_LINKINFO_TRANSCEIVER]) {
+		uint8_t val;
+
+		val = mnl_attr_get_u8(tb[ETHTOOL_A_LINKINFO_TRANSCEIVER]);
+		print_banner(nlctx, &first);
+		print_enum(names_transceiver, val, "\tTransceiver: ",
+			   "Unknown!");
+	}
+	if (tb[ETHTOOL_A_LINKINFO_TP_MDIX] && tb[ETHTOOL_A_LINKINFO_TP_MDIX] &&
+	    port == PORT_TP) {
+		uint8_t mdix = mnl_attr_get_u8(tb[ETHTOOL_A_LINKINFO_TP_MDIX]);
+		uint8_t mdix_ctrl =
+			mnl_attr_get_u8(tb[ETHTOOL_A_LINKINFO_TP_MDIX_CTRL]);
+
+		print_banner(nlctx, &first);
+		dump_mdix(mdix, mdix_ctrl);
+	}
+
+	return MNL_CB_OK;
+}
+
+int linkstate_reply_cb(const struct nlmsghdr *nlhdr, void *data)
+{
+	const struct nlattr *tb[ETHTOOL_A_LINKSTATE_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb);
+	struct nl_context *nlctx = data;
+	bool first = true;
+	int ret;
+
+	ret = mnl_attr_parse(nlhdr, GENL_HDRLEN, attr_cb, &tb_info);
+	if (ret < 0)
+		return ret;
+	nlctx->devname = get_dev_name(tb[ETHTOOL_A_LINKSTATE_HEADER]);
+	if (!dev_ok(nlctx))
+		return MNL_CB_OK;
+
+	if (tb[ETHTOOL_A_LINKSTATE_LINK]) {
+		uint8_t val = mnl_attr_get_u8(tb[ETHTOOL_A_LINKSTATE_LINK]);
+
+		print_banner(nlctx, &first);
+		printf("\tLink detected: %s\n", val ? "yes" : "no");
+	}
+
+	return MNL_CB_OK;
+}
+
+void wol_modes_cb(unsigned int idx, const char *name, bool val, void *data)
+{
+	struct ethtool_wolinfo *wol = data;
+
+	if (idx >= 32)
+		return;
+	wol->supported |= (1U << idx);
+	if (val)
+		wol->wolopts |= (1U << idx);
+}
+
+int wol_reply_cb(const struct nlmsghdr *nlhdr, void *data)
+{
+	const struct nlattr *tb[ETHTOOL_A_WOL_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb);
+	struct nl_context *nlctx = data;
+	struct ethtool_wolinfo wol = {};
+	int ret;
+
+	ret = mnl_attr_parse(nlhdr, GENL_HDRLEN, attr_cb, &tb_info);
+	if (ret < 0)
+		return ret;
+	nlctx->devname = get_dev_name(tb[ETHTOOL_A_WOL_HEADER]);
+	if (!dev_ok(nlctx))
+		return MNL_CB_OK;
+
+	if (tb[ETHTOOL_A_WOL_MODES])
+		walk_bitset(tb[ETHTOOL_A_WOL_MODES], NULL, wol_modes_cb, &wol);
+	if (tb[ETHTOOL_A_WOL_SOPASS]) {
+		unsigned int len;
+	       
+		len = mnl_attr_get_payload_len(tb[ETHTOOL_A_WOL_SOPASS]);
+		if (len != SOPASS_MAX)
+			fprintf(stderr, "invalid SecureOn password length %u (should be %u)\n",
+				len, SOPASS_MAX);
+		else
+			memcpy(wol.sopass,
+			       mnl_attr_get_payload(tb[ETHTOOL_A_WOL_SOPASS]),
+			       SOPASS_MAX);
+	}
+	dump_wol(&wol);
+
+	return MNL_CB_OK;
+}
+
+void msgmask_cb(unsigned int idx, const char *name, bool val, void *data)
+{
+	u32 *msg_mask = data;
+
+	if (idx >= 32)
+		return;
+	if (val)
+		*msg_mask |= (1U << idx);
+}
+
+void msgmask_cb2(unsigned int idx, const char *name, bool val, void *data)
+{
+	if (val)
+		printf(" %s", name);
+}
+
+int debug_reply_cb(const struct nlmsghdr *nlhdr, void *data)
+{
+	const struct nlattr *tb[ETHTOOL_A_DEBUG_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb);
+	const struct stringset *msgmask_strings;
+	struct nl_context *nlctx = data;
+	u32 msg_mask = 0;
+	int ret;
+
+	ret = mnl_attr_parse(nlhdr, GENL_HDRLEN, attr_cb, &tb_info);
+	if (ret < 0)
+		return ret;
+	nlctx->devname = get_dev_name(tb[ETHTOOL_A_DEBUG_HEADER]);
+	if (!dev_ok(nlctx))
+		return MNL_CB_OK;
+
+	if (!tb[ETHTOOL_A_DEBUG_MSGMASK])
+		return MNL_CB_OK;
+	ret = netlink_init_ethnl2_socket(nlctx);
+	if (ret < 0)
+		return MNL_CB_OK;
+	msgmask_strings = global_stringset(ETH_SS_MSG_CLASSES,
+					   nlctx->ethnl2_socket);
+	walk_bitset(tb[ETHTOOL_A_DEBUG_MSGMASK], NULL, msgmask_cb, &msg_mask);
+	printf("        Current message level: 0x%08x (%u)\n"
+	       "                              ",
+	       msg_mask, msg_mask);
+	walk_bitset(tb[ETHTOOL_A_DEBUG_MSGMASK], msgmask_strings, msgmask_cb2,
+		    NULL);
+	fputc('\n', stdout);
+
+	return MNL_CB_OK;
+}
+
+int nl_gset(struct cmd_context *ctx)
+{
+	struct nl_context *nlctx = ctx->nlctx;
+	struct nl_socket *nlsk = nlctx->ethnl_socket;
+	int ret;
+
+	ret = nlsock_prep_get_request(nlsk, ETHTOOL_MSG_LINKMODES_GET,
+				      ETHTOOL_A_LINKMODES_HEADER, 0);
+	if (ret < 0)
+		goto err;
+	ret = nlsock_send_get_request(nlsk, linkmodes_reply_cb);
+	if (ret < 0)
+		goto err;
+
+	ret = nlsock_prep_get_request(nlsk, ETHTOOL_MSG_LINKINFO_GET,
+				      ETHTOOL_A_LINKINFO_HEADER, 0);
+	if (ret < 0)
+		goto err;
+	ret = nlsock_send_get_request(nlsk, linkinfo_reply_cb);
+	if (ret < 0)
+		goto err;
+
+	ret = nlsock_prep_get_request(nlsk, ETHTOOL_MSG_LINKSTATE_GET,
+				      ETHTOOL_A_LINKSTATE_HEADER, 0);
+	if (ret < 0)
+		goto err;
+	ret = nlsock_send_get_request(nlsk, linkstate_reply_cb);
+	if (ret < 0)
+		goto err;
+
+	ret = nlsock_prep_get_request(nlsk, ETHTOOL_MSG_WOL_GET,
+				      ETHTOOL_A_WOL_HEADER, 0);
+	if (ret < 0)
+		goto err;
+	ret = nlsock_send_get_request(nlsk, wol_reply_cb);
+	if (ret < 0)
+		goto err;
+
+	ret = nlsock_prep_get_request(nlsk, ETHTOOL_MSG_DEBUG_GET,
+				      ETHTOOL_A_DEBUG_HEADER, 0);
+	if (ret < 0)
+		goto err;
+	ret = nlsock_send_get_request(nlsk, debug_reply_cb);
+	if (ret < 0)
+		goto err;
+
+	return 0;
+err:
+	return 75;
+}
-- 
2.25.0

