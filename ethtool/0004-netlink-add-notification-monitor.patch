From 9d1264aeaf90a205e5a151fa6d4f1dc41826de3b Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 14 Jul 2018 19:28:19 -0400
Subject: [PATCH 04/21] netlink: add notification monitor

With 'ethtool --monitor [ --all | opt ] [dev]', let ethtool listen to
netlink notification and display them in a format similar to output of
related "get" commands. With --all, show all types of notifications. If
device name is specified, show only notifications for that device, if no
device name or "*" is passed, show notifications for all devices.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 ethtool.c |  17 +++++
 netlink.c | 192 +++++++++++++++++++++++++++++++++++++++++++++++++++++-
 netlink.h |   4 ++
 3 files changed, 212 insertions(+), 1 deletion(-)

diff --git a/ethtool.c b/ethtool.c
index 0fee2cfe7acc..417ec95822ab 100644
--- a/ethtool.c
+++ b/ethtool.c
@@ -5289,6 +5289,9 @@ static int show_usage(struct cmd_context *ctx)
 		if (args[i].opthelp)
 			fputs(args[i].opthelp, stdout);
 	}
+#ifdef ETHTOOL_ENABLE_NETLINK
+	monitor_usage();
+#endif
 
 	return 0;
 }
@@ -5330,6 +5333,20 @@ int main(int argc, char **argp)
 	argp++;
 	argc--;
 
+#ifdef ETHTOOL_ENABLE_NETLINK
+	if (*argp && !strcmp(*argp, "--monitor")) {
+		if (netlink_init(&ctx)) {
+			fprintf(stderr,
+				"Option --monitor is only available with netlink.\n");
+			return 1;
+		} else {
+			ctx.argp = ++argp;
+			ctx.argc = --argc;
+			return nl_monitor(&ctx);
+		}
+	}
+#endif
+
 	/* First argument must be either a valid option or a device
 	 * name to get settings for (which we don't expect to begin
 	 * with '-').
diff --git a/netlink.c b/netlink.c
index 5aa94ab14659..c16c6731e2aa 100644
--- a/netlink.c
+++ b/netlink.c
@@ -16,6 +16,7 @@
 
 struct nl_context {
 	int ethnl_fam;
+	uint32_t mon_mcgrp_id;
 	struct mnl_socket *sk;
 	char *buff;
 	unsigned int buffsize;
@@ -27,6 +28,10 @@ struct nl_context {
 	const char *devname;
 	bool is_dump;
 	int exit_code;
+	bool is_monitor;
+	uint8_t filter_cmd;
+	uint32_t filter_mask;
+	const char *filter_devname;
 };
 
 struct attr_tb_info {
@@ -483,6 +488,31 @@ static void show_u32_yn(const struct nlattr **tb, unsigned int idx,
 }
 /* get ethtool family id */
 
+static void ethnl_find_monitor_group(struct nl_context *nlctx,
+				     struct nlattr *nest)
+{
+	const struct nlattr *grp_tb[CTRL_ATTR_MCAST_GRP_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(grp_tb);
+	struct nlattr *grp_attr;
+	int ret;
+
+	nlctx->mon_mcgrp_id = 0;
+	mnl_attr_for_each_nested(grp_attr, nest) {
+		ret = mnl_attr_parse_nested(grp_attr, attr_cb, &grp_tb_info);
+		if (ret < 0)
+			return;
+		if (!grp_tb[CTRL_ATTR_MCAST_GRP_NAME] ||
+		    !grp_tb[CTRL_ATTR_MCAST_GRP_ID])
+			continue;
+		if (strcmp(mnl_attr_get_str(grp_tb[CTRL_ATTR_MCAST_GRP_NAME]),
+			   ETHTOOL_MCGRP_MONITOR_NAME))
+			continue;
+		nlctx->mon_mcgrp_id =
+			mnl_attr_get_u32(grp_tb[CTRL_ATTR_MCAST_GRP_ID]);
+		return;
+	}
+}
+
 static int ethnl_family_cb(const struct nlmsghdr *nlhdr, void *data)
 {
 	struct nl_context *nlctx = data;
@@ -490,9 +520,13 @@ static int ethnl_family_cb(const struct nlmsghdr *nlhdr, void *data)
 
 	nlctx->ethnl_fam = 0;
 	mnl_attr_for_each(attr, nlhdr, GENL_HDRLEN) {
-		if (mnl_attr_get_type(attr) == CTRL_ATTR_FAMILY_ID) {
+		switch(mnl_attr_get_type(attr)) {
+		case CTRL_ATTR_FAMILY_ID:
 			nlctx->ethnl_fam = mnl_attr_get_u16(attr);
 			break;
+		case CTRL_ATTR_MCAST_GROUPS:
+			ethnl_find_monitor_group(nlctx, attr);
+			break;
 		}
 	}
 
@@ -585,3 +619,159 @@ int netlink_done(struct cmd_context *ctx)
 
 	return 0;
 }
+
+bool mask_ok(const struct nl_context *nlctx, uint32_t bits)
+{
+	return !nlctx->filter_mask || (nlctx->filter_mask & bits);
+}
+
+bool dev_ok(const struct nl_context *nlctx)
+{
+	return !nlctx->filter_devname ||
+	       (nlctx->devname &&
+		!strcmp(nlctx->devname, nlctx->filter_devname));
+}
+
+bool show_only(const struct nl_context *nlctx, uint32_t bits)
+{
+	if (nlctx->is_monitor || !nlctx->filter_mask)
+		return false;
+	return nlctx->filter_mask & ~bits;
+}
+
+/* monitor */
+
+static struct {
+	uint8_t		cmd;
+	mnl_cb_t	cb;
+} monitor_callbacks[] = {
+};
+
+static int monitor_any_cb(const struct nlmsghdr *nlhdr, void *data)
+{
+	const struct genlmsghdr *ghdr = (const struct genlmsghdr *)(nlhdr + 1);
+	struct nl_context *nlctx = data;
+	unsigned i;
+
+	if (nlctx->filter_cmd && ghdr->cmd != nlctx->filter_cmd)
+		return MNL_CB_OK;
+
+	for (i = 0; i < MNL_ARRAY_SIZE(monitor_callbacks); i++)
+		if (monitor_callbacks[i].cmd == ghdr->cmd)
+			return monitor_callbacks[i].cb(nlhdr, data);
+
+	return MNL_CB_OK;
+}
+
+struct monitor_option {
+	const char	*pattern;
+	uint8_t		cmd;
+	uint32_t	info_mask;
+};
+
+static struct monitor_option monitor_opts[] = {
+	{
+		.pattern	= "--all",
+		.cmd		= 0,
+	},
+};
+
+static bool pattern_match(const char *s, const char *pattern)
+{
+	const char *opt = pattern;
+	const char *next;
+	int slen = strlen(s);
+	int optlen;
+
+	do {
+		next = opt;
+		while (*next && *next != '|')
+			next++;
+		optlen = next - opt;
+		if (slen == optlen && !strncmp(s, opt, optlen))
+			return true;
+
+		opt = next;
+		if (*opt == '|')
+			opt++;
+	} while (*opt);
+
+	return false;
+}
+
+static int parse_monitor(struct cmd_context *ctx)
+{
+	struct nl_context *nlctx = ctx->nlctx;
+	char **argp = ctx->argp;
+	int argc = ctx->argc;
+	const char *opt = "";
+	unsigned int i;
+
+	if (*argp && argp[0][0] == '-') {
+		opt = *argp;
+		argp++;
+		argc--;
+	}
+	for (i = 0; i < MNL_ARRAY_SIZE(monitor_opts); i++) {
+		if (pattern_match(opt, monitor_opts[i].pattern)) {
+			nlctx->filter_cmd = monitor_opts[i].cmd;
+			nlctx->filter_mask = monitor_opts[i].info_mask;
+			goto opt_found;
+		}
+	}
+	fprintf(stderr, "monitoring for option '%s' not supported\n", *argp);
+	return -1;
+
+opt_found:
+	if (*argp && strcmp(*argp, WILDCARD_DEVNAME))
+		ctx->devname = *argp;
+	return 0;
+}
+
+int nl_monitor(struct cmd_context *ctx)
+{
+	struct nl_context *nlctx = ctx->nlctx;
+	uint32_t grpid = nlctx->mon_mcgrp_id;
+	int ret;
+
+	if (!grpid) {
+		fprintf(stderr, "multicast group 'monitor' not found\n");
+		return -EOPNOTSUPP;
+	}
+	if (parse_monitor(ctx) < 0)
+		return 1;
+
+	ret = mnl_socket_setsockopt(nlctx->sk, NETLINK_ADD_MEMBERSHIP,
+				    &grpid, sizeof(grpid));
+	if (ret < 0)
+		return ret;
+
+	nlctx->filter_devname = ctx->devname;
+	nlctx->is_monitor = true;
+	nlctx->port = 0;
+	nlctx->seq = 0;
+
+	return ethnl_process_reply(nlctx, monitor_any_cb);
+}
+
+void monitor_usage()
+{
+	const char *p;
+	unsigned i;
+
+	fputs("        ethtool --monitor               Show kernel notifications\n",
+	      stdout);
+	for (i = 0; i < MNL_ARRAY_SIZE(monitor_opts); i++) {
+		if (i > 0)
+			fputs("\n                  | ", stdout);
+		else
+			fputs("                ( ", stdout);
+		for (p = monitor_opts[i].pattern; *p; p++)
+			if (*p == '|')
+				fputs(" | ", stdout);
+			else
+				fputc(*p, stdout);
+	}
+	fputs(" )\n", stdout);
+	fputs("                [ DEVNAME | * ]\n", stdout);
+}
diff --git a/netlink.h b/netlink.h
index b10b168b1f5b..39b5e3600567 100644
--- a/netlink.h
+++ b/netlink.h
@@ -7,4 +7,8 @@ struct nl_context;
 int netlink_init(struct cmd_context *ctx);
 int netlink_done(struct cmd_context *ctx);
 
+int nl_monitor(struct cmd_context *ctx);
+
+void monitor_usage();
+
 #endif /* ETHTOOL_NETLINK_H__ */
-- 
2.18.0

