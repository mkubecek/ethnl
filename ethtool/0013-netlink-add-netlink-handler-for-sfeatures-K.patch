From 005b0eaa4e731567a1184650cbad9672134bcc64 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sun, 29 Jul 2018 16:25:31 +0200
Subject: [PATCH 13/34] netlink: add netlink handler for sfeatures (-K)

Implement "ethtool -K <dev>" subcommand using netlink interface command
ETHTOOL_MSG_SETTINGS_SET.

The implementation tries to emulate legacy flags but the result is not
exactly equal to the ioctl code. In particular, we map netdev features to
legacy flags based on name patterns in off_flag_def[] but this mapping is
slightly different from mapping used by kernel ioctl code. It also does not
try to emulate legacy flags in "actual changes" output show when actual
change of device features does not match userspace request exactly.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 ethtool.c          |   3 +-
 netlink/extapi.h   |   1 +
 netlink/settings.c | 289 +++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 292 insertions(+), 1 deletion(-)

diff --git a/ethtool.c b/ethtool.c
index d9c68a295bce..3df59831aa41 100644
--- a/ethtool.c
+++ b/ethtool.c
@@ -4982,6 +4982,7 @@ static int show_usage(struct cmd_context *ctx);
 #define nl_gset		NULL
 #define nl_sset		NULL
 #define nl_gfeatures	NULL
+#define nl_sfeatures	NULL
 #endif
 
 static const struct option {
@@ -5048,7 +5049,7 @@ static const struct option {
 	  "		[ tx N ]\n" },
 	{ "-k|--show-features|--show-offload", 1, do_gfeatures, nl_gfeatures,
 	  "Get state of protocol offload and other features" },
-	{ "-K|--features|--offload", 1, do_sfeatures, NULL,
+	{ "-K|--features|--offload", 1, do_sfeatures, nl_sfeatures,
 	  "Set protocol offload and other features",
 	  "		FEATURE on|off ...\n" },
 	{ "-i|--driver", 1, do_gdrv, nl_gdrv,
diff --git a/netlink/extapi.h b/netlink/extapi.h
index f4bbb0b456ef..d0199cb440f8 100644
--- a/netlink/extapi.h
+++ b/netlink/extapi.h
@@ -18,6 +18,7 @@ int nl_tsinfo(struct cmd_context *ctx);
 int nl_gset(struct cmd_context *ctx);
 int nl_sset(struct cmd_context *ctx);
 int nl_gfeatures(struct cmd_context *ctx);
+int nl_sfeatures(struct cmd_context *ctx);
 int nl_monitor(struct cmd_context *ctx);
 
 void monitor_usage();
diff --git a/netlink/settings.c b/netlink/settings.c
index b8b60ccd1fc0..2ee2bf256dc6 100644
--- a/netlink/settings.c
+++ b/netlink/settings.c
@@ -792,3 +792,292 @@ int nl_sset(struct cmd_context *ctx)
 		return 0;
 	return nlctx->exit_code ?: 75;
 }
+
+/* features */
+
+struct sfeatures_context {
+	uint32_t		req_mask[0];
+};
+
+static void show_feature_changes(struct nl_context *nlctx,
+				 const struct nlattr *feat_attr)
+{
+	struct sfeatures_context *sfctx = nlctx->cmd_private;
+	const struct stringset *feature_names =
+		global_stringset(ETH_SS_FEATURES);
+	const unsigned int count = get_count(feature_names);
+	const unsigned int words = (count + 31) / 32;
+	const struct nlattr *tb[ETHTOOL_A_FEATURES_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb);
+	const uint32_t *wanted_val;
+	const uint32_t *wanted_mask;
+	const uint32_t *active_val;
+	const uint32_t *active_mask;
+	unsigned int i;
+	bool diff;
+	int ret;
+
+	ret = mnl_attr_parse_nested(feat_attr, attr_cb, &tb_info);
+	if (ret < 0)
+		goto err;
+	if (!tb[ETHTOOL_A_FEATURES_WANTED] || !tb[ETHTOOL_A_FEATURES_ACTIVE])
+		goto err;
+	if (bitset_get_count(tb[ETHTOOL_A_FEATURES_WANTED], &ret) != count ||
+	    ret < 0)
+		goto err;
+	if (bitset_get_count(tb[ETHTOOL_A_FEATURES_ACTIVE], &ret) != count ||
+	    ret < 0)
+		goto err;
+	wanted_val = get_compact_bitset_value(tb[ETHTOOL_A_FEATURES_WANTED]);
+	wanted_mask = get_compact_bitset_mask(tb[ETHTOOL_A_FEATURES_WANTED]);
+	active_val = get_compact_bitset_value(tb[ETHTOOL_A_FEATURES_ACTIVE]);
+	active_mask = get_compact_bitset_mask(tb[ETHTOOL_A_FEATURES_ACTIVE]);
+	if (!wanted_val || !wanted_mask || !active_val || !active_mask)
+		goto err;
+
+	diff = false;
+	for (i = 0; i < words; i++)
+		if (wanted_mask[i] || active_mask[i])
+			diff = true;
+	if (!diff)
+		return;
+
+	/* result is not exactly as requested, show differences */
+	printf("Actual changes:\n");
+	for (i = 0; i < count; i++) {
+		const char *name = get_string(feature_names, i);
+
+		if (!name)
+			continue;
+		if (!feature_on(wanted_mask, i) && !feature_on(active_mask, i))
+			continue;
+		printf("%s: ", name);
+		if (feature_on(wanted_mask, i))
+			/* we requested a value but result is different */
+			printf("%s [requested %s]",
+			       feature_on(wanted_val, i) ? "off" : "on",
+			       feature_on(wanted_val, i) ? "on" : "off");
+		else if (!feature_on(sfctx->req_mask, i))
+			/* not requested but changed anyway */
+			printf("%s [not requested]",
+			       feature_on(active_val, i) ? "on" : "off");
+		else
+			printf("%s", feature_on(active_val, i) ? "on" : "off");
+		fputc('\n', stdout);
+	}
+
+	return;
+err:
+	fprintf(stderr, "malformed diff info from kernel\n");
+}
+
+static int find_feature(const char *name)
+{
+	const struct stringset *feature_names =
+		global_stringset(ETH_SS_FEATURES);
+	const unsigned int count = get_count(feature_names);
+	unsigned int i;
+
+	for (i = 0; i < count; i++)
+		if (!strcmp(name, get_string(feature_names, i)))
+			return i;
+
+	return -1;
+}
+
+static int fill_feature(struct nl_context *nlctx, const char *name, bool val)
+{
+	struct nlattr *bit_attr;
+
+	bit_attr = ethnla_nest_start(nlctx, ETHTOOL_A_BITS_BIT);
+	if (!bit_attr)
+		return -EMSGSIZE;
+	if (ethnla_put_strz(nlctx, ETHTOOL_A_BIT_NAME, name))
+		return -EMSGSIZE;
+	if (ethnla_put_flag(nlctx, ETHTOOL_A_BIT_VALUE, val))
+		return -EMSGSIZE;
+	mnl_attr_nest_end(nlctx->nlhdr, bit_attr);
+
+	return 0;
+}
+
+static void set_sf_req_mask(struct nl_context *nlctx, unsigned int idx)
+{
+	struct sfeatures_context *sfctx = nlctx->cmd_private;
+
+	sfctx->req_mask[idx / 32] |= (1 << (idx % 32));
+}
+
+static int fill_legacy_flag(struct nl_context *nlctx, const char *flag_name,
+			    bool val)
+{
+	const struct stringset *feature_names =
+		global_stringset(ETH_SS_FEATURES);
+	const unsigned int count = get_count(feature_names);
+	unsigned int i, j;
+	int ret;
+
+	for (i = 0; i < OFF_FLAG_DEF_SIZE; i++) {
+		const char *pattern;
+
+		if (strcmp(flag_name, off_flag_def[i].short_name) &&
+		    strcmp(flag_name, off_flag_def[i].long_name))
+			continue;
+		pattern = off_flag_def[i].kernel_name;
+
+		for (j = 0; j < count; j++) {
+			const char *name = get_string(feature_names, j);
+
+			if (flag_pattern_match(name, pattern)) {
+				ret = fill_feature(nlctx, name, val);
+				if (ret < 0)
+					return ret;
+				set_sf_req_mask(nlctx, j);
+			}
+		}
+
+		return 0;
+	}
+
+	return 1;
+}
+
+int sfeatures_reply_cb(const struct nlmsghdr *nlhdr, void *data)
+{
+	const struct genlmsghdr *ghdr = (const struct genlmsghdr *)(nlhdr + 1);
+	const struct nlattr *tb[ETHTOOL_A_SETTINGS_MAX + 1] = {};
+	DECLARE_ATTR_TB_INFO(tb);
+	struct nl_context *nlctx = data;
+	const char *devname;
+	int ret;
+
+	if (ghdr->cmd != ETHTOOL_MSG_SETTINGS_SET_REPLY) {
+		fprintf(stderr, "warning: unexpected reply message type %u\n",
+			ghdr->cmd);
+		return MNL_CB_OK;
+	}
+	ret = mnl_attr_parse(nlhdr, GENL_HDRLEN, attr_cb, &tb_info);
+	if (ret < 0)
+		return ret;
+	devname = get_dev_name(tb[ETHTOOL_A_SETTINGS_HEADER]);
+	if (strcmp(devname, nlctx->devname)) {
+		fprintf(stderr, "warning: unexpected message for device %s\n",
+			devname);
+		return MNL_CB_OK;
+	}
+	if (!tb[ETHTOOL_A_SETTINGS_FEATURES])
+		return MNL_CB_OK;
+
+	show_feature_changes(nlctx, tb[ETHTOOL_A_SETTINGS_FEATURES]);
+	return MNL_CB_OK;
+}
+
+int fill_sfeatures_bitmap(struct nl_context *nlctx)
+{
+	struct nlmsghdr *nlhdr = nlctx->nlhdr;
+	struct nlattr *bitset_attr;
+	struct nlattr *bits_attr;
+	int ret;
+
+	ret = -EMSGSIZE;
+	bitset_attr = ethnla_nest_start(nlctx, ETHTOOL_A_FEATURES_WANTED);
+	if (!bitset_attr)
+		return ret;
+	bits_attr = ethnla_nest_start(nlctx, ETHTOOL_A_BITSET_BITS);
+	if (!bits_attr)
+		goto err;
+
+	while (nlctx->argc > 0) {
+		bool val;
+
+		if (!strcmp(*nlctx->argp, "--")) {
+			nlctx->argp++;
+			nlctx->argc--;
+			break;
+		}
+		ret = -EINVAL;
+		if (nlctx->argc < 2 ||
+		    (strcmp(nlctx->argp[1], "on") &&
+		     strcmp(nlctx->argp[1], "off"))) {
+			fprintf(stderr,
+				"ethtool (%s): flag '%s' for parameter '%s' is"
+				" not followed by 'on' or 'off'\n",
+				nlctx->cmd, nlctx->argp[1], nlctx->param);
+			goto err;
+		}
+
+		val = !strcmp(nlctx->argp[1], "on");
+		ret = fill_legacy_flag(nlctx, nlctx->argp[0], val);
+		if (ret > 0) {
+			ret = fill_feature(nlctx, nlctx->argp[0], val);
+			if (ret == 0) {
+				int idx = find_feature(nlctx->argp[0]);
+
+				if (idx >= 0)
+					set_sf_req_mask(nlctx, idx);
+			}
+		}
+		if (ret < 0)
+			goto err;
+
+		nlctx->argp += 2;
+		nlctx->argc -= 2;
+	}
+
+	mnl_attr_nest_end(nlhdr, bits_attr);
+	mnl_attr_nest_end(nlhdr, bitset_attr);
+	return 0;
+err:
+	mnl_attr_nest_cancel(nlhdr, bitset_attr);
+	return ret;
+}
+
+int nl_sfeatures(struct cmd_context *ctx)
+{
+	const struct stringset *feature_names;
+	struct sfeatures_context *sfctx;
+	struct nl_context *nlctx = ctx->nlctx;
+	struct nlattr *feat_attr;
+	unsigned int words;
+	int ret;
+
+	nlctx->cmd = "-K";
+	nlctx->argp = ctx->argp;
+	nlctx->argc = ctx->argc;
+	nlctx->cmd_private = &sfctx;
+
+	load_global_strings(nlctx);
+	feature_names = global_stringset(ETH_SS_FEATURES);
+	words = (get_count(feature_names) + 31) / 32;
+	sfctx = malloc(sizeof(*sfctx) + words * sizeof(sfctx->req_mask[0]));
+	if (!sfctx)
+		return -ENOMEM;
+	memset(sfctx, '\0',
+	       sizeof(*sfctx) + words * sizeof(sfctx->req_mask[0]));
+	nlctx->cmd_private = sfctx;
+
+	nlctx->devname = ctx->devname;
+	ret = msg_init(nlctx, ETHTOOL_MSG_SETTINGS_SET,
+		       NLM_F_REQUEST | NLM_F_ACK);
+	if (ret < 0)
+		return 2;
+	if (ethnla_fill_header(nlctx, ETHTOOL_A_SETTINGS_HEADER, ctx->devname,
+			       0, ETHTOOL_GFLAG_COMPACT_BITSETS, 0))
+		return -EMSGSIZE;
+
+	feat_attr = ethnla_nest_start(nlctx, ETHTOOL_A_SETTINGS_FEATURES);
+	if (!feat_attr)
+		return -EMSGSIZE;
+	ret = fill_sfeatures_bitmap(nlctx);
+	if (ret < 0)
+		return ret;
+	mnl_attr_nest_end(nlctx->nlhdr, feat_attr);
+
+	ret = ethnl_sendmsg(nlctx);
+	if (ret < 0)
+		return 92;
+	ret = ethnl_process_reply(nlctx, sfeatures_reply_cb);
+	if (ret == 0)
+		return 0;
+	return nlctx->exit_code ?: 92;
+}
-- 
2.22.0

